(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
xAct`xBrauer`$Version={"0.1.0",{2022,28,10}};
xAct`xBrauer`$xTensorVersionExpected={"1.2.0",{2021,10,17}};
xAct`xTras`$xTrasVersionExpected={"1.0.6",{2014,10,30}};


(* ::Input::Initialization:: *)
(* xBrauer : Applications of the Brauer algebra for tensor calculus *)

(* Copyright (C) 2020 T. Helpin *)

(* This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License,or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

*)


(* ::Input::Initialization:: *)
(* :Title: xBrauer *)

(* :Author: Thomas Helpin *)

(* :Summary: xBrauer; Application of the Brauer algebra to tensor calculus. *)

(* :Brief Discussion:  *)
  
(* :Context: xBrauer` *)

(* :Package Version: 0.1.0 *)

(* :Copyright: T.Helpin (2020) *)

(* :History: TODO *)

(* :Keywords: TODO *)

(* :Source: xBrauer.nb *)

(* :Warning:  *)

(* :Mathematica Version: 8.0 and later *)

(* :Limitations: *)
	
(* :Acknowledgements: *)


(* ::Input::Initialization:: *)
If[Unevaluated[xAct`xCore`Private`$LastPackage]===xAct`xCore`Private`$LastPackage,xAct`xCore`Private`$LastPackage="xAct`xBrauer`"];
Off[General::nostdvar]
Off[General::nostdopt]

BeginPackage["xAct`xBrauer`",{"xAct`xTensor`","xAct`xPerm`","xAct`xCore`","xAct`Invar`","xAct`SymManipulator`","xAct`xPert`","xAct`xTras`","xAct`SymmetricFunctions`","xAct`BrauerAlgebra`"}]


(* ::Input::Initialization:: *)
If[Not@OrderedQ@Map[Last,{$xTensorVersionExpected,xAct`xTensor`$Version}],Throw@Message[General::versions,"xTensor",xAct`xTensor`$Version,$xTensorVersionExpected]]

(*If[Not@OrderedQ@Map[Last,{$xTrasVersionExpected,xAct`xTras`$Version}],Throw@Message[General::versions,"xTras",xAct`xTras`$Version,$xTrasVersionExpected]]*)


(* ::Input::Initialization:: *)
Print[xAct`xCore`Private`bars]
Print["Package xAct`xBrauer`  version ",$Version[[1]],", ",$Version[[2]]];
Print["Copyright (C) 2020-2022, Thomas Helpin, under the General Public License."];


(* ::Input::Initialization:: *)
Off[General::shdw]
xAct`xForm`Disclaimer[]:=Print["These are points 11 and 12 of the General Public License:\n\nBECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM `AS IS\.b4 WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\nIN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES."]
On[General::shdw]


(* ::Input::Initialization:: *)
If[xAct`xCore`Private`$LastPackage==="xAct`xBrauer`",
Unset[xAct`xCore`Private`$LastPackage];
Print[xAct`xCore`Private`bars];
Print["These packages come with ABSOLUTELY NO WARRANTY; for details type Disclaimer[]. This is free software, and you are welcome to redistribute it under certain conditions. See the General Public License for details."];
Print[xAct`xCore`Private`bars]]





(* ::Input::Initialization:: *)
(*** VERSIONS ***)
$Version::usage="$Version is a global variable giving the version of the package xBrauer in use.";



(**************************************************************************************************************)
(************************************************* Symplectic Manifold ****************************************)
(**************************************************************************************************************)

SymplecticFormQ::usage="SymplecticFormQ[expr] gives True if expr has been registered as a symplectic form, and False otherwise";
SymplecticFormsOfVBundle::usage="SymplecticFormsOfVBundle[vbundle] gives the list of symplectic forms that have been defined on the vector bundle vbundle.";
VBundleOfSymplecticForm::usage="VBundleOfSymplecticForm[symplecticform] gives the vector bundle where symplecticform lives.";
$SymplecticForms::usage="$SymplecticForms is a global variable storing the list of all currently defined symplectic forms.";
DefSymplecticForm::usage="DefSymplecticForm[\[Omega][-i1,-i2]] defines the symplectic 2-form \[Omega][-i1,-i2] on the manifold with tangent bundle associated with the indices -i1 and -i2.";
ContractSymplecticForm::usage="ContractSymplecticForm[expr,symplecticform] contracts all instances of symplecticform (and Inv[symplecticform]) in expr.
ContractSymplecticForm[expr] contracts all instances of the symplectic associated to expr in expr.";
SeparateSymplecticForm::usage="To do.";
SymplecticFormOfTensor::usage="SymplecticFormOfTensor[tens] returns the symplectic form associated to the tensor tens. 
This symplectic form is used to raised and lowered the indices of tens.
For a tensor to be associated with a symplectic form \[Omega] one should set the option Master-> \[Omega] .";
(****************************************************************************************************************************************)
(*********************** Realisation of the Brauer alegebra as operators on tensors and action on tensors *******************************)
(****************************************************************************************************************************************)
BrauerToTensor::usage="BrauerToTensor[d,metric,inds] transforms a BrauerList d into a product of metrics metric where the vertices numbers of d are mapped to the indices inds.
BrauerToTensor[d,metric] is equivalent to BrauerToTensor[d,metric,inds] where inds are the first indices of IndicesOfVBundle[VBundleOfMetric[metric]]. The Vertex in the upper part of d are converted to UpIndex 
and vertex in the lower part are converted to DownIndex.
BrauerToTensor[d] is equivalent to  BrauerToTensor[d,First[$Metrics]].";
(****************************************************************************************************************************************)
(************************************************ Action of the Brauer algebra on tensors ***********************************************)
(****************************************************************************************************************************************)
TracePermuteIndices::usage="TracePermuteIndices[expr,indices,diagram/bracelet,g] traces and permutes the indices of expr given by the list indices (Head List) according
to the element of the Brauer algebra diagram (Head BrauerList) or to the conjugacy class bracelet (Head Bracelets) using metric (or symplectic form) g. 
In general diagram/bracelet can be a linear combination of such elements.
Note that the action of a diagram on tensor[indices] with TracePermuteIndices correspond to the action of the diagram on indices placing diagram above indices. 
The input g is optionnal. The default value is the first metric (or symplectic form) defined in the vector bundle associated to the indices.
If both a metric and a symplectic form has been defined on the vector bundle the priority is given to the metric.
When the input is a bracelet (conjugacy class in the Brauer algebra) which size is equal to the number of Free indices of expr the result is independent of indices which become optionnal.";
ClassTensor::usage="ClassTensor[tenslist,bracelet][inds] represents a tensor expression where the product of tensors in tenslist is dressed with a conjugacy class sum of the Brauer algebra
 with (Head Bracelets).
More precisely the result of ExpandClassTensor[ClassTensor[tensorlist,bracelet][inds]] is the same as TracePermuteIndices[exp,bracelet] where exp is the product of tenslist 
dressed with the indices inds.";
ExpandClassTensor::usage="ExpandClassTensor[ClassTensor[tensorlist,bracelet][inds],g], expand a ClassTensor object as a sum of tensors using metric g.
The metric input g is optional.";
ToClassTensor::usage="ToClassTensor[tensor,bracelets] dresses tensor with bracelets to form a ClassTensor object.";
ClassAction::usage="ClassAction[bracelets1,ClassTensor[{tens},bracelets2][inds]] multplies bracelets1 with bracelets2 using the ConjugacyClassProduct function of the
package BrauerAlgebra and returns the associted linear combination of ClassTensor.
The function can be applied to any linear combination of ClassTensor objects.";


(**************************************************************************************************************)
(************* Irreducible decomposition of a tensor under the action of GL(N) ********************************)
(**************************************************************************************************************)

(*CentralYoungProjectorTensor::usage="CentralYoungProjectorTensor[\[Mu],g,inds] returns the central Young projector.";*)
(*CentralYoungProject::usage="To do.";*)
(*YoungSymmetrize::usage="YoungSymmetrize[exp,tab,indices] projects exp to the irreducible representation space parametrized by the standard tableau tab.";*)
SemiNormalYoungProject::usage="SemiNormalYoungProject[exp,tableau,indices] projects exp to the irreducible representation space parametrized by the standard tableau tab.";
GeneralLinearGroup::usage="In SymmetricFunctions GeneralLinearGroup is a parameter for DimOfIrrep and for BranchingRule.";
GLIrreducibleProject::usage="GLIrreducibleProject[exp,tableau,indices] projects exp to the irreducible space parametrized by tableau.";
GLIsotypicProject::usage="GLIsotypicProject[exp,\[Mu]] projects exp to the isotypic component with respect to the action of GL, parametrized by the partition \[Mu]. 
In other words GLIsotypicProject[exp,\[Mu]] projects exp to the direct sum of equivalent irreducible GL-module parametrized by the partition \[Mu].";
GLCentralIrreducibleProject::usage="GLCentralIrreducibleProject[exp,\[Mu]] projects exp to the isotypic component with respect to the action of GL, parametrized by the partition \[Mu]. 
In other words GLCentralIrreducibleProject[exp,\[Mu]] projects exp to the direct sum of equivalent irreducible GL-module parametrized by the partition \[Mu].";
GLIrrepsOfTensor::usage="GLIrrepsOfTensor[tensor] returns a list of partitions corresponding to the irreducible representations of GL (with multiplicities) associated with tensor.
(** Remark on the limitations of this function **)
This function analyses the symmetry of tensor, but exchange symmetries of n-tuple of indices are not taken into account yet. Therefore when a tensor has some exchange 
symmetries (like the metric Riemann tensor) some irreps in the list GLIrrepsOfTensor[tensor] may still not be present in tensor. Also, more complicated symmetries like Bianchi type 
identies are not taken into account.";

(**************************************************************************************************************)
(************************************** Trace decomposition of a tensor ***************************************)
(**************************************************************************************************************)
TracelessProjectorTensor::usage="(************ The function **************)
TracelessProjectorTensor[n,f,{dim},g,inds] returns the f-traceless projector for tensors of order n, dimension of tangent space dim,  using metric g and indices inds.
TracelessProjectorTensor[n,f,g,inds] returns the f-traceless projector for tensors of order n using metric g and indices inds with dim=DimOfManifold@@DependenciesOfTensor[g].
TracelessProjectorTensor[n,g,inds] returns the traceless projector for tensors of order n using metric g and indices inds.
TracelessProjectorTensor[n,f,g], TracelessProjectorTensor[n,g], TracelessProjectorTensor[n,\[Mu],g] returns the corresponding traceless projectors using the first indices of IndicesOfVBundle[VBundleOfMetric[g]].
TracelessProjectorTensor[n,f], TracelessProjectorTensor[n], TracelessProjectorTensor[n,\[Mu]] returns the corresponding traceless projectors using the metric First[$Metrics].
(************* Options ******************)
The function TracelessProjectorTensor has two options : Output and SymplecticGroup. Output can take the value Tensor or SymH. The Default value is Tensor. SymplecticGroup is a boolean option.
the default value is False. If SymplecticGroup is set to True TracelessProjectorTensor returns the traceless projector for tensors defined on a symplectic manifold. The antisymmetric symplectic 2-form 
has to be defined accordingly for the function to work properly. (See the examples in the documentation).";
GLTracelessProjector::usage="GLTracelessProjector[n,\[Mu],g,inds] returns the traceless projector for GL(N)-irreducible tensors associated to the integer partition \[Mu], using metric g and indices inds."
TraceProjectorTensor::usage="TraceProjectorTensor[n,g,inds_List] returns the fmax-trace projector for tensors of order n using metric g and indices inds.";
TracelessProject::usage="TracelessProject[exp,f,g] projects exp onto the space of f-traceless tensors using metric (or symplectic form) g. 
A f-traceless tensors is a tensors such that any f contractions of pairs of indices yield zero. TracelessProject[exp,g] projects exp 
onto the space to totally traceless tensors. The metric input g is optional.";
GLTracelessProject::usage="GLTracelessProject[exp,f,\[Mu]] projects exp onto the space of f-traceless tensors.";
TraceProject::usage="TraceProject[exp] projects exp onto the space of fmax-trace tensors. In particular, if exp is a tensor of even order TraceProject[exp] projects to the 
space of scalar invariants.";
Dressed::usage="In the package BrauerAlgebra Dressed is an option for SnTracelessProjector. In the package xBrauer Dressed is an option for GLTracelessProjector and GLTracelessProject.
It can take the value None or CentralYoungProjector. In all cases the default value is None.";

(**************************************************************************************************************)
(************* Irreducible decomposition of a tensor under the action of the orthogonal group *****************)
(**************************************************************************************************************)

OIrrepsOfTensor::usage="OIrrepsOfTensor[tensor] returns a list of partitions corresponding to the irreducible representations of the orthogonal group (with multiplicities) 
associated with tensor.
(** Remark on the limitations of this function **)
The list of irreps is obtained by the branching rules from GL(N) to O(N) for N large enough. So OIrrepsOfTensor[tensor] has the same limitation as GLIrrepsOfTensor[tensor].
Also the N-dependant restrictions on irreps (when N is small compare to the order of the tensor) are not implemented yet.";

OIsotypicProject::usage="OIsotypicProject[exp,\[Lambda],metric] projects exp to the isotypic component parametrized by the partition \[Lambda], with respect to the action of O(d). 
In other words, OIsotypicProject[exp,\[Lambda],metric] projects exp on the direct sum of equivalent irreducible tensor representation spaces parametrized by a partition \[Lambda], with respect to the
orthogonal group. Note that metric is optional.";

OCentralIrreducibleProject::usage="OCentralIrreducibleProject[exp,\[Lambda],metric] projects exp to the isotypic component parametrized by the partition \[Lambda], with respect to the action of O(d). 
In other words, OCentralIrreducibleProject[exp,\[Lambda],metric] projects exp on the direct sum of equivalent irreducible tensor representation spaces parametrized by a partition \[Lambda], with respect to the
orthogonal group. Note that metric is optional.";

OIrreducibleProject::usage="OIrreducibleProject[exp,path,indices,metric] projects exp to the irreducible space parametrized by the Bratteli path of the Brauer
algebra path. Note that path is a list of integer partitions which has to start by the partition {1}. The input metric is optional.";

(*****************************************************************************************************************)
(******************************* Modification and other extension of xTensor  ************************************)
(*****************************************************************************************************************)

Master::usage="Master is an option for DefType commands specifying the master symbol of the defined symbol. By default, no master is associated.
In xBrauer Master is an important option for DefTensor. Use Master -> met, or Master -> Null. Its default value is Null.
DefTensor[tens[inds],...,Master->g] defines a tensor tens with indices inds which can be raised, lowered or contracted with metric (or symplectic form) g only. 
DefTensor[tens[inds],M,...,Master->Null] defines a tensor tens with indices inds which can be raised, lowered or contracted with the first metric (or symplectic form) of the vector bundle associated with the indices inds.";

MetricOfTensor::usage="MetricOfTensor[tens] returns the metric associated to the tensor tens. This metric is used to raised and lowered the indices of tens.  
For a tensor to be associated with a metric g one should set the option Master->g (or Master->covdg) at definition time of tensor.";

InducedMetricQ::usage="InducedMetricQ[met] returns true if met is the induced metric of another metric.";

LeviCivitaQ::usage="LeviCivitaQ[covd,g] returns True if covd is the Levi-Civita connection associated with g. LeviCivitaQ[covd] returns True if covd is 
the Levi-Civita connection associated with the metric MasterOf[covd] if any.";
SafeCanonical::usage="SafeCanonical[e] is ToCanonical with the option UseMetricOnVBundle -> None";
ConformalTransform::usage="ConformalTransform[exp,g,gc] apply the conformal rules from metric g to metric gc to exp.";
(*TraceFreeQ::usage="TraceFreeQ[tensor[inds],met] returns True if the contraction with the metric met of any pair of the indices of tensor is zero.";*)




(* ::Input::Initialization:: *)
Begin["`Private`"]


(* ::Input::Initialization:: *)
(****** This function is borrowed to xCore Package : Jos\[EAcute] M. Mart\[IAcute]n-Garc\[IAcute]a
jose@xact.es
(c) 2007-2020,under GPL ****)
(*CheckOptions[]:={};
CheckOptions[opts__]:=If[OptionQ[{opts}]&&MemberQ[{1,2},ArrayDepth[{opts}]],
Flatten[{opts},1],
Throw[Message[CheckOptions::invalid,opts,"option or list of options"]]];
Protect[CheckOptions];*)


(* ::Input::Initialization:: *)
Inv[symplecticform_?SymplecticFormQ]:=GiveSymbol[Inv,symplecticform]
$SymplecticForms={};
SymplecticFormsOfVBundle[-vbundle_]:=SymplecticFormsOfVBundle[vbundle];
SymplecticFormQ[_]:=False


(* ::Input::Initialization:: *)
xTension["xBrauer`xTensor`",DefVBundle,"End"]:=xBrauerxTensorDefVBundle;
xBrauerxTensorDefVBundle[vbundle_,manifold_,dimF_,indices_,options___]:=SymplecticFormsOfVBundle[vbundle]^={};


(* ::Input::Initialization:: *)
DefSymplecticForm::dimension="A symplectic form can not be defined on `1` because its dimension is not even.";
Options[DefSymplecticForm]:={PrintAs->Identity,ConformalTo->Null,OtherDependencies->{},WeightedWithBasis->Null,Master->Null,ProtectNewSymbol->$ProtectNewSymbols,DefInfo->{"",""}}
DefSymplecticForm[symplecticform_[-ind1_,-ind2_],options:OptionsPattern[]]:=Catch[With[{vbundle=VBundleOfIndex[ind1]},Module[{confto,odeps,wwb,pns,info,dim,integerdimQ,firstQ,invertQ},
{confto,odeps,wwb,pns,info}=OptionValue[{DefSymplecticForm},{ConformalTo,OtherDependencies,WeightedWithBasis,ProtectNewSymbol,DefInfo}];
dim=DimOfVBundle[vbundle];
integerdimQ=IntegerQ[dim];
firstQ=SymplecticFormsOfVBundle[vbundle]==={};
With[{manifold=BaseOfVBundle[vbundle],deps={BaseOfVBundle[vbundle]}\[Union]odeps,vbQ=xAct`xTensor`Private`VBundleIndexQ[vbundle],vbpmQ=xAct`xTensor`Private`VBundleIndexPMQ[vbundle],invsymplecticform=GiveSymbol[Inv,symplecticform]},
If[IntegerQ[dim]&&OddQ[dim],Throw@Message[DefSymplecticForm::dimension,manifold]];
Off[OptionValue::nodef];DefTensor[symplecticform[-ind1,-ind2],deps,Antisymmetric[{1,2}],ProtectNewSymbol->False,DefInfo:>If[info===False,False,{"symplectic form",""}],options];
MakexTensions[DefSymplecticForm,"Beginning",symplecticform[-ind1,-ind2],options];
AppendToUnevaluated[$SymplecticForms,symplecticform];SymplecticFormQ[symplecticform]^=True;VBundleOfSymplecticForm[symplecticform]^=vbundle;xUpAppendTo[SymplecticFormsOfVBundle[vbundle],symplecticform];
InducedFrom[symplecticform]^=Null;
(***** Definition of inverse metric ******)
DefTensor[invsymplecticform[ind1,ind2],deps,Antisymmetric[{1,2}],ProtectNewSymbol->False,Master->symplecticform,DefInfo:>If[info===False,False,{"inverse symplectic form",""}],PrintAs:>GiveOutputString[Inv,symplecticform],options];
(********* Convention for inverse symplectic form and tensor contraction ***)
symplecticform/:invsymplecticform[i1_Symbol,i2_Symbol]symplecticform[-i1_Symbol,-i3_Symbol]:=-delta[-i3,i2];
symplecticform/:invsymplecticform[i2_Symbol,i1_Symbol]symplecticform[-i1_Symbol,-i3_Symbol]:=delta[-i3,i2];
symplecticform/:invsymplecticform[i2_Symbol,i1_Symbol]symplecticform[-i3_Symbol,-i1_Symbol]:=-delta[-i3,i2];
symplecticform/:invsymplecticform[i1_Symbol,i2_Symbol]symplecticform[-i3_Symbol,-i1_Symbol]:=delta[-i3,i2];
Unprotect[delta];
delta/:delta[i1_Symbol,i2_Symbol]:=invsymplecticform[i1,i2];
delta/:delta[-i1_Symbol,-i2_Symbol]:=-symplecticform[-i1,-i2];
delta/:delta[i1_Symbol,-i1_Symbol]:=-dim;
delta/:delta[i1_Symbol,-i2_Symbol]:=-delta[-i2,i1];
Protect[delta];
symplecticform/:symplecticform[i1_Symbol,i2_Symbol]:=-invsymplecticform[i1, i2];
invsymplecticform/:invsymplecticform[-i1_Symbol,-i2_Symbol]:=-symplecticform[-i1,-i2];
symplecticform/:symplecticform[i1_Symbol,-i2_Symbol]:=delta[-i2,i1];
symplecticform/:symplecticform[-i1_Symbol,i2_Symbol]:=-delta[-i1,i2];
invsymplecticform/:invsymplecticform[i1_Symbol,-i2_Symbol]:=-delta[-i2,i1];
invsymplecticform/:invsymplecticform[-i1_Symbol,i2_Symbol]:=delta[-i1,i2];
(**** Conformal symplectic forms : To do ****)
(*If[confto=!=Null,SetConformalTo[symplecticform[-ind1,-ind2],confto]];*)
MakexTensions[DefSymplecticForm,"End",symplecticform[-ind1,-ind2],options];On[OptionValue::nodef];If[pns,Protect[symplecticform]];]]]]


(* ::Input::Initialization:: *)
BilinearFormsOfVBundle[vbundle_]:=Join[MetricsOfVBundle[vbundle],SymplecticFormsOfVBundle[vbundle]]


(* ::Input::Initialization:: *)
SymplecticFormOfTensor[met_?SymplecticFormQ]:=met;
SymplecticFormOfTensor[delta]:=Null;
SymplecticFormOfTensor[tensor_?xTensorQ]:=If[MasterOf[tensor]===Null,Null,If[SymplecticFormQ[MasterOf[tensor]],MasterOf[tensor],Null]];
SymplecticFormOfTensor[tensor_?xTensorQ[inds__]]:=With[{symplecticform=SymplecticFormOfTensor[tensor]},If[symplecticform===Null,With[{symplecticforms=SymplecticFormsOfVBundle[VBundleOfIndex[{inds}[[1]]]]},If[symplecticforms==={},Null,symplecticforms[[1]]]],symplecticform]];
SymplecticFormOfTensor[tensor_?xTensorQ[]]:=All;


(* ::Input::Initialization:: *)
Unprotect[MasterOf];
SetNumberOfArguments[MasterOf,1,2]
MasterOf[tensor_?xTensorQ,num_?IntegerQ]:=Nest[MasterOf,tensor,num];
Protect[MasterOf];


(* ::Input::Initialization:: *)
MetricOfTensor[met_?MetricQ]:=met;
MetricOfTensor[delta]:=Null;
MetricOfTensor[tensor_?xTensorQ]:=If[MasterOf[tensor]===Null,Null,If[MetricQ[MasterOf[tensor]],MasterOf[tensor],If[CovDQ[MasterOf[tensor]]&&MasterOf[tensor,2]===Null,$Metrics[[1]],If[CovDQ[MasterOf[tensor]]&&MetricQ[MasterOf[tensor,2]],MasterOf[tensor,2]]]]];
MetricOfTensor[tensor_?xTensorQ[inds__]]:=With[{metric=MetricOfTensor[tensor]},If[metric===Null,With[{mets=MetricsOfVBundle[VBundleOfIndex[{inds}[[1]]]]},If[mets==={},Null,mets[[1]]]],metric]];
MetricOfTensor[tensor_?xTensorQ[]]:=All;


(* ::Input::Initialization:: *)
metricOfcovdtens[covd_?CovDQ[inds1__][tensor_?xTensorQ[inds2___]]]:=If[MasterOf[covd]===MetricOfTensor[tensor]||inds2===Null,MasterOf[covd],$Metrics[[1]]];
metricOf[exp_]:=With[{metlist=DeleteCases[DeleteCases[Join[MetricOfTensor/@FindAllOfType[exp,Tensor],metricOfcovdtens/@FindAllOfType[exp,CovD]],Null],All]},
	If[Length[Union[metlist]]===1&&metlist=!={},metlist[[1]],$Metrics[[1]]]];


(* ::Input::Initialization:: *)
BilinearFormOfTensor[met_?SymplecticFormQ||met_?MetricQ]:=met;
BilinearFormOfTensor[delta]:=Null;
BilinearFormOfTensor[tensor_?xTensorQ]:=With[{list=DeleteCases[{MetricOfTensor[tensor],SymplecticFormOfTensor[tensor]},Null]},If[list==={},Null,First[list]]]
BilinearFormOfTensor[tensor_?xTensorQ[inds__]]:=With[{list=DeleteCases[{MetricOfTensor[tensor[inds]],SymplecticFormOfTensor[tensor[inds]]},Null]},If[list==={},Null,First[list]]]
BilinearFormOfTensor[tensor_?xTensorQ[]]:=All;
BilinearFormsOfExpression[exp_]:=DeleteDuplicates[BilinearFormOfTensor/@DeleteDuplicates[Head/@FindAllOfType[exp,Tensor]]]


(* ::Input::Initialization:: *)
ContractSymplecticForm[expr_,symplecticforms_List]:=Fold[ContractSymplecticForm[#1,#2]&,expr,symplecticforms];
ContractSymplecticForm[expr_,symplecticform_Symbol?SymplecticFormQ]:=ContractSymplecticForm0[{symplecticform}][expr];
ContractSymplecticForm[expr_,symplecticform_Symbol,options___]:=Throw@Message[ContractSymplecticForm::unknown,"symplecticform",symplecticform];
ContractSymplecticForm[expr_,options___?OptionQ]:=ContractSymplecticForm[expr,$SymplecticForms,options];
SetNumberOfArguments[ContractSymplecticForm,{1,Infinity}];


(* ::Input::Initialization:: *)
(******* Expand Product ********)
ContractSymplecticForm0[case__][expr_Times]:=ContractSymplecticForm1[case][xAct`xTensor`Private`MathInputExpand[expr]];
ContractSymplecticForm0[case__][expr_]:=ContractSymplecticForm1[case][expr];
(******* Automatic threading ********)
ContractSymplecticForm1[case__][expr_Plus]:=ContractSymplecticForm0[case]/@expr;
ContractSymplecticForm1[case__][expr_SeriesData]:=xAct`xTensor`Private`SeriesDataMap[ContractSymplecticForm0[case],expr];
ContractSymplecticForm1[case__][list_List]:=ContractSymplecticForm0[case]/@list;
ContractSymplecticForm1[case__][eq_Equal]:=ContractSymplecticForm0[case]/@eq;


(* ::Input::Initialization:: *)
(******* rules for contraction of the symplectic form *****)
(CM:ContractSymplecticForm1[{symplecticform_}])[rest_. tensor_?xTensorQ[i1___,c_,i2___]symplecticform_[-b_,-c_]]:=CM[rest tensor[i1,-b,i2]]/;(SymplecticFormOfTensor[tensor]===symplecticform||(SymplecticFormOfTensor[tensor]===Null&&symplecticform===$SymplecticForms[[1]]))
(CM:ContractSymplecticForm1[{symplecticform_}])[rest_. tensor_?xTensorQ[i1___,c_,i2___]symplecticform_[-c_,-b_]]:=CM[-rest tensor[i1,-b,i2]]/;(SymplecticFormOfTensor[tensor]===symplecticform||(SymplecticFormOfTensor[tensor]===Null&&symplecticform===$SymplecticForms[[1]]))
(******* rules for contraction of the inverse of the symplectic form *****)
(CM:ContractSymplecticForm1[{symplecticform_}])[rest_. tensor_?xTensorQ[i1___,-c_,i2___]invsymplecticform_[b_,c_]]:=CM[rest tensor[i1,b,i2]]/;invsymplecticform===Inv[symplecticform]&&(SymplecticFormOfTensor[tensor]===symplecticform||(SymplecticFormOfTensor[tensor]===Null&&symplecticform===$SymplecticForms[[1]]))
(CM:ContractSymplecticForm1[{symplecticform_}])[rest_. tensor_?xTensorQ[i1___,-c_,i2___]invsymplecticform_[c_,b_]]:=CM[-rest tensor[i1,b,i2]]/;invsymplecticform===Inv[symplecticform]&&(SymplecticFormOfTensor[tensor]===symplecticform||(SymplecticFormOfTensor[tensor]===Null&&symplecticform===$SymplecticForms[[1]]))

(* Default case *)
ContractSymplecticForm1[__][expr_]:=expr;


(* ::Input::Initialization:: *)
firstsymplecticformofvbundle[vbundle_,list_List,_]:=First[list]
FirstSymplecticFormOfVBundle[vbundle_,mess_:True]:=firstsymplecticformofvbundle[vbundle,SymplecticFormsOfVBundle[vbundle],mess]


(* ::Input::Initialization:: *)
(* Locate individual tensors *)
SeparateSymplecticForm[args1___][expr_Plus,args2___]:=SeparateSymplecticForm[args1][#,args2]&/@expr;
SeparateSymplecticForm[args1___][expr_SeriesData,args2___]:=xAct`xTensor`Private`SeriesDataMap[SeparateSymplecticForm[args1][#,args2]&,expr];
SeparateSymplecticForm[args1___][expr_Times,args2___]:=SeparateSymplecticForm[args1][#,args2]&/@expr;


(* ::Input::Initialization:: *)
(* Shortcuts to 2 arguments in the first pair of brackets *)
SeparateSymplecticForm[][args__]:=SeparateSymplecticForm[Automatic,AIndex][args];
SeparateSymplecticForm[metric_][args__]:=SeparateSymplecticForm[metric,AIndex][args];
(* Second argument of the second pair of brackets *)
SeparateSymplecticForm[metric_,basis_][expr_,All]:=SeparateSymplecticForm[metric,basis][expr,IndicesOf[][expr]];
SeparateSymplecticForm[metric_,basis_][expr_,vb_?VBundleQ]:=SeparateSymplecticForm[metric,basis][IndicesOf[vb][expr]];
SeparateSymplecticForm[metric_,basis_][expr_,basis2_Symbol?BasisQ]:=SeparateSymplecticForm[metric,basis][expr,IndicesOf[basis2][expr]];
SeparateSymplecticForm[metric_,basis_][expr_,f_IndicesOf]:=SeparateSymplecticForm[metric,basis][expr,f[expr]];
(* Default action of the second argument: Indices not in their original character *)
SeparateSymplecticForm[metric_,basis_][expr_]:=SeparateSymplecticForm[metric,basis][expr,Automatic];
SeparateSymplecticForm[metric_,basis_][expr_,Automatic]:=With[{tensors=FindAllOfType[expr,Tensor]},SeparateSymplecticForm[metric,basis][expr,Flatten@Apply[IndexList,xAct`xTensor`Private`movedindices/@tensors]]];
(* Expand list of indices *)
SeparateSymplecticForm[metric_,basis_][expr_,list_IndexList]:=Fold[SeparateSymplecticForm[metric,basis],expr,DeleteDuplicates[DeleteCases[list,_LI|-_LI]]];


(* ::Input::Initialization:: *)
SeparateSymplecticForm[metric_,basis_][expr_,index_?GIndexQ]:=SeparateSymplecticForm1[basis,metric,FirstSymplecticFormOfVBundle[VBundleOfIndex[index]]][expr,index];


(* ::Input::Initialization:: *)
SeparateSymplecticForm1[basis_,Automatic,metric1_][expr_,index_]:=SeparateSymplecticForm2[basis,metric1][expr,index];
SeparateSymplecticForm1[basis_,metric1_,metric1_][expr_,index_]:=SeparateSymplecticForm2[basis,metric1][expr,index]/;VBundleOfSymplecticForm[metric1]===VBundleOfIndex[index];


(* ::Input::Initialization:: *)
(* SeparateMetric *)
SeparateSymplecticForm2[AIndex,metric_][metric_[i1_,i2_],index_]:=metric[i1,i2];

(*** SeparateMetric driver with option ***)
SeparateSymplecticForm2[basis_,symplecticform_][expr_,index_]:=expr/.{tensor_?xTensorQ[i1___,index,i2___]:>With[{dummy=DummyAs[index,basis]},If[(SymplecticFormOfTensor[tensor]===symplecticform||(SymplecticFormOfTensor[tensor]===Null&&symplecticform===$SymplecticForms[[1]])),If[UpIndexQ[index],Inv[symplecticform][index,dummy],symplecticform[index,dummy]]tensor[i1,ChangeIndex[dummy],i2],tensor[i1,index,i2]]]};
SeparateSymplecticForm[][exp_]:=Fold[SeparateSymplecticForm[#2][#1]&,exp,$SymplecticForms];
SeparateSymplecticForm[exp_?(!SymplecticFormQ[#]&)]:=SeparateSymplecticForm[][exp];


(* ::Input::Initialization:: *)
(********** This is now private ***********)
TraceFreeQ[tensor_?xTensorQ,inds___List,metric_?MetricQ|metric_?SymplecticFormQ]:=Module[{mettraces,traces,tfQ},
mettraces=Map[metric@@#&,ChangeIndex/@Subsets[inds,{2}]];
traces=Map[ContractMetric[ToCanonical[tensor@@inds*#],metric]&,mettraces];
If[AllTrue[traces,#===0&],tfQ=True,tfQ=False];
tfQ
];
TraceFreeQ[tensor_,metric_?MetricQ|metric_?SymplecticFormQ]:=TraceFreeQ[Head@tensor,List@@tensor,metric];
TraceFreeQ[tensor_]:=If[MasterOf[Head@tensor]=!={},TraceFreeQ[Head@tensor,List@@tensor,MetricOfTensor[Head@tensor]],TraceFreeQ[Head@tensor,List@@tensor,$Metrics[[1]]]];


(* ::Input::Initialization:: *)
BrauerToTensorRiemann[x:BrauerList[list_],metric_,inds_List]:=
With[{invmetric=Inv[metric],n=Length[list]},
If[Length[inds]=!=2*n,Throw[Print["The number of indices is not compatible the Brauer diagrams"]]];
Times@@Apply[If[UpIndexQ[#1]&&DownIndexQ[#2],delta[#2,#1],If[UpIndexQ[#1]&&UpIndexQ[#2],invmetric[#1,#2],metric[#1,#2]]]&,list/.Thread[Rule[Join[Range[n],DownInteger[Range[n]]],inds]],{1}]
];

BrauerToTensorRiemann[x_BrauerList,metric_]:=With[{list=Partition[(Flatten@IndicesOfVBundle[VBundleOfMetric[metric]])[[;;2*Length@@x]],Length@@x]},BrauerToTensorRiemann[x,metric,Join[list[[1]],DownIndex/@list[[2]]]]];
BrauerToTensorRiemann[x_BrauerList,inds_List]:=BrauerToTensorRiemann[x,$Metrics[[1]],inds];
BrauerToTensorRiemann[x_BrauerList]:=BrauerToTensorRiemann[x,$Metrics[[1]]];

BrauerToTensorRiemann[cycle_System`Cycles,n_Integer,metric_,inds_List]:=BrauerToTensorRiemann[PermToBrauer[cycle,n],metric,inds];
BrauerToTensorRiemann[cycle_System`Cycles,metric_,inds_List]:=BrauerToTensorRiemann[cycle,Length[inds]/2,metric,inds]


(* ::Input::Initialization:: *)
BrauerToTensorSymplectic0[x:BrauerList[list_],symplecticform_,inds_]:=Module[{rule},
With[{invsymplecticform=Inv[symplecticform],n=Length[list]},
If[Length[inds]=!=2*n,Throw[Print["The number of indices is not compatible the Brauer diagrams"]]];
Times@@MapThread[If[xAct`BrauerAlgebra`Private`ArcUpQ[#2],Inv[symplecticform]@@#1,If[xAct`BrauerAlgebra`Private`LineQ[#2],delta@@Reverse[#1],symplecticform@@#1]]&,{list/.Thread[Rule[Join[Range[n],DownInteger[Range[n]]],inds]],list}]
]
];
BrauerToTensorSymplectic[x_BrauerList,symplecticform_,inds_List]:=SignatureBrauer[x]*BrauerToTensorSymplectic0[x,symplecticform,inds];
BrauerToTensorSymplectic[x_BrauerList,symplecticform_]:=
With[{list=Partition[(Flatten@IndicesOfVBundle[VBundleOfSymplecticForm[symplecticform]])[[;;2*Length@@x]],Length@@x]},BrauerToTensorSymplectic[x,symplecticform,Join[list[[1]],DownIndex/@list[[2]]]]]
BrauerToTensorSymplectic[x_BrauerList,inds_List]:=BrauerToTensorSymplectic[x,$SymplecticForms[[1]],inds];
BrauerToTensorSymplectic[x_BrauerList]:=BrauerToTensorSymplectic[x,$SymplecticForms[[1]]];
(***** Cycles *****)
BrauerToTensorSymplectic[cycle_System`Cycles,n_Integer,symplecticform_,inds_List]:=SignatureBrauer[cycle]*BrauerToTensorSymplectic0[PermToBrauer[cycle,n],symplecticform,inds];

BrauerToTensorSymplectic[cycle_System`Cycles,symplecticform_,inds_List]:=BrauerToTensorSymplectic[cycle,Length[inds]/2,symplecticform,inds];


(* ::Input::Initialization:: *)
Options[BrauerToTensor]:={Output->Tensor,SymplecticGroup->False}
BrauerToTensor[BrauerList[list_],metric_?MetricQ|metric_?SymplecticFormQ,inds_List,options:OptionsPattern[]]:=Module[{indiceslist,metriclist,rule,symplecticQ1,symplecticQ2=SymplecticFormQ[metric]},
{symplecticQ1}=OptionValue[{BrauerToTensor},{options},{SymplecticGroup}];
If[symplecticQ1||symplecticQ2,BrauerToTensorSymplectic[BrauerList[list],metric,inds],
BrauerToTensorRiemann[BrauerList[list],metric,inds]
]
]

BrauerToTensor[cycle_System`Cycles,metric_?MetricQ|metric_?SymplecticFormQ,inds_List,options:OptionsPattern[]]:=With[{symplecticQ=SymplecticGroup/.CheckOptions[options]/. Options[BrauerToTensor]},If[symplecticQ,BrauerToTensorSymplectic[cycle,metric,inds],BrauerToTensorRiemann[cycle,metric,inds]]];

BrauerToTensor[x_BrauerList,metric_?MetricQ|metric_?SymplecticFormQ,options:OptionsPattern[]]:=With[{symplecticQ1=SymplecticGroup/.CheckOptions[options]/. Options[BrauerToTensor],symplecticQ2=SymplecticFormQ[metric]},If[symplecticQ1||symplecticQ2,BrauerToTensorSymplectic[x,metric],BrauerToTensorRiemann[x,metric]]];
BrauerToTensor[x_BrauerList,inds_List,options:OptionsPattern[]]:=With[{symplecticQ1=SymplecticGroup/.CheckOptions[options]/. Options[BrauerToTensor]},If[symplecticQ1,BrauerToTensorSymplectic[x,inds],BrauerToTensorRiemann[x,inds]]];
BrauerToTensor[x_BrauerList,options:OptionsPattern[]]:=With[{symplecticQ1=SymplecticGroup/.CheckOptions[options]/. Options[BrauerToTensor]},If[symplecticQ1,BrauerToTensorSymplectic[x],BrauerToTensorRiemann[x]]];

(***************************************************************)
(****************** Bracelets to tensors ***********************)
(***************************************************************)

(************* SymH notation of SymManipulator Package ************)

(*** SymH notation ***)
BrauerToTensorSymRiemann[x_Bracelets,metric_?MetricQ,inds_List]:=Module[{rep=BrauerToTensor[ToRepresentativeDiagram[x],metric,inds],n=2*Length[Flatten@@x],sym,ruleindices,list1=Normal@PositionIndex[UpIndex/@inds],symGroup,supportstring,heads},
With[{indices=IndicesOf[AIndex]@rep,numofdiagram=xAct`BrauerAlgebra`Private`SizeOfConjugacyClass[x]},
heads=Map[If[(UpIndexQ[#[[1]]]&&DownIndexQ[#[[2]]])||(DownIndexQ[#[[1]]]&&UpIndexQ[#[[2]]]),delta,If[(UpIndexQ[#[[1]]]&&UpIndexQ[#[[2]]]),Inv[metric],metric]]&,Partition[List@@indices,2]];
ruleindices=Map[#[[1,1]]->#[[2,1]]&,(Normal@PositionIndex[UpIndex/@List@@indices])/.list1];
sym=Thread[List[Subsets[Range[n/2],{2}],Subsets[Range[n/2+1,n],{2}]]]/.ruleindices;
symGroup= StrongGenSet[Range[n],GenSet[Sequence@@(Cycles@@@sym)]];
supportstring=StringJoin[Append[Prepend[ToString/@Range[n],"("],")"]];
numofdiagram*SymH[heads, symGroup,supportstring][Sequence@@indices]
]
]
BrauerToTensorSymRiemann[x_Bracelets,metric_?MetricQ|metric_?SymplecticFormQ]:=With[{list=Partition[(Flatten@IndicesOfVBundle[VBundleOfMetric[metric]])[[;;2*Length[Flatten@@x]]],Length[Flatten@@x]]},BrauerToTensorSymRiemann[x,metric,Join[list[[1]],DownIndex/@list[[2]]]]];
BrauerToTensorSymRiemann[x_Bracelets]:=BrauerToTensorSymRiemann[x,$Metrics[[1]]]
BrauerToTensorSymRiemann[x_Bracelets,inds_List]:=BrauerToTensorSymRiemann[x,$Metrics[[1]],inds];
BrauerToTensor[x_Bracelets?(SymmetricGroupQ[#]&),metric_?MetricQ|metric_?SymplecticFormQ,inds_List,options:OptionsPattern[]]:=Module[{output,symplecticQ},
{output,symplecticQ}=OptionValue[{BrauerToTensor},{options},{Output,SymplecticGroup}];
If[output===SymH&&!symplecticQ,
BrauerToTensorSymRiemann[x,metric,inds],
BrauerToTensor[ConjugacyClassSum[x],metric,inds,SymplecticGroup->symplecticQ]]]
BrauerToTensor[btab_Bracelets?(!SymmetricGroupQ[#]&),metric_?MetricQ|metric_?SymplecticFormQ,inds_List,options:OptionsPattern[]]:=Module[{output,symplecticQ},
{output,symplecticQ}=OptionValue[{BrauerToTensor},{options},{Output,SymplecticGroup}];
If[output===SymH&&!symplecticQ,
BrauerToTensorSymRiemann[btab,metric,inds],
BrauerToTensor[ConjugacyClassSum[btab],metric,inds,SymplecticGroup->symplecticQ]]]
BrauerToTensor[btab_Bracelets,metric_?MetricQ|metric_?SymplecticFormQ,options:OptionsPattern[]]:=With[{list=If[MetricQ[metric],Partition[(Flatten@IndicesOfVBundle[VBundleOfMetric[metric]])[[;;2*Length[Flatten@@btab]]],Length[Flatten@@btab]],Partition[(Flatten@IndicesOfVBundle[VBundleOfSymplecticForm[metric]])[[;;2*Length[Flatten@@btab]]],Length[Flatten@@btab]]]},BrauerToTensor[btab,metric,Join[list[[1]],DownIndex/@list[[2]]],options]]
BrauerToTensor[x_Bracelets,inds_List,options:OptionsPattern[]]:=With[{symplecticQ1=SymplecticGroup/.CheckOptions[options]/. Options[BrauerToTensor]},
If[symplecticQ1,BrauerToTensor[x,$SymplecticForms[[1]],inds,options],
BrauerToTensor[x,$Metrics[[1]],inds,options]
]
]
BrauerToTensor[x_Bracelets,options:OptionsPattern[]]:=With[{symplecticQ1=SymplecticGroup/.CheckOptions[options]/. Options[BrauerToTensor]},
If[symplecticQ1,BrauerToTensor[x,$SymplecticForms[[1]],options],
BrauerToTensor[x,$Metrics[[1]],options]
]
]


(* ::Input::Initialization:: *)
BrauerToTensor[exp_,metric_?MetricQ|metric_?SymplecticFormQ,inds_List,options:OptionsPattern[]]:=exp/.x_BrauerList|x_System`Cycles|x_Bracelets:>BrauerToTensor[x,metric,inds,options]
(***** No metric in the argument *****)
BrauerToTensor[exp_,inds_List,options:OptionsPattern[]]:=exp/.x_BrauerList|x_System`Cycles|x_Bracelets:>BrauerToTensor[x,inds,options]
(***** No indices in the argument *****)
BrauerToTensor[exp_,metric_?MetricQ|metric_?SymplecticFormQ,options:OptionsPattern[]]:=exp/.x_BrauerList|x_System`Cycles|x_Bracelets:>BrauerToTensor[x,metric,options]
(***** No metric and no indices in the argument *****)
BrauerToTensor[exp_,options:OptionsPattern[]]:=exp/.x_BrauerList|x_System`Cycles|x_Bracelets:>BrauerToTensor[x,options]


(* ::Input::Initialization:: *)
IntegerListQ[list_]:=And@@(IntegerQ/@list)


(* ::Input::Initialization:: *)
(************************** Traceless projector of V^(\[TensorProduct]n) ***********************************)
Options[TracelessProjectorTensor]:={Output->Tensor}
TracelessProjectorTensor[n_,f_Integer,{dim_Integer|dim_Symbol|dim_Plus},metric_?MetricQ|metric_?SymplecticFormQ,inds_List,options:OptionsPattern[]]:=Module[{output,symplecticQ=SymplecticFormQ[metric]},
{output}=OptionValue[{TracelessProjectorTensor},{options},{Output}];
If[symplecticQ,If[Head[dim]===Integer||Head[dim]===Plus,BrauerToTensor[TracelessProjector[n,f,{-dim},SchurWeylDual->SymplecticGroup],metric,inds,Output->output,SymplecticGroup->symplecticQ],BrauerToTensor[TracelessProjector[n,f,{dim},SchurWeylDual->SymplecticGroup]/.dim->-dim,metric,inds,Output->output,SymplecticGroup->symplecticQ]],
BrauerToTensor[TracelessProjector[n,f,{dim},SchurWeylDual->OrthogonalGroup],metric,inds,Output->output,SymplecticGroup->symplecticQ]
]
]
(***************** No indices in the input *************************************************************)
TracelessProjectorTensor[n_,f_Integer,{dim_Integer|dim_Symbol|dim_Plus},metric_?MetricQ|metric_?SymplecticFormQ,options:OptionsPattern[]]:=With[{inds=If[MetricQ[metric],Partition[(Flatten@IndicesOfVBundle[VBundleOfMetric[metric]])[[;;2*n]],n],Partition[(Flatten@IndicesOfVBundle[VBundleOfSymplecticForm[metric]])[[;;2*n]],n]]},TracelessProjectorTensor[n,f,{dim},metric,Join[inds[[1]],DownIndex/@inds[[2]]],options]];
(*** No metric in the input ***)
TracelessProjectorTensor[n_,f_Integer,{dim_Integer|dim_Symbol?(!MetricQ[#]&&!SymplecticFormQ[#]&)|dim_Plus},inds_List,options:OptionsPattern[]]:=TracelessProjectorTensor[n,f,dim,BilinearFormsOfVBundle[VBundleOfIndex[inds[[1]]]][[1]],inds,options]
TracelessProjectorTensor[n_,f_Integer,{dim_Integer|dim_Symbol?(!MetricQ[#]&&!SymplecticFormQ[#]&)|dim_Plus},options:OptionsPattern[]]:=TracelessProjectorTensor[n,f,{dim},Join[$Metrics,$SymplecticForms][[1]],options];
(************ When there is no dimension in the input : the default value is DimOfManifold is metric/symplectic form is not induced else DimOfManifold-1 (should be generalized) *******)
TracelessProjectorTensor[n_,f_Integer,metric_?MetricQ|metric_?SymplecticFormQ,inds_List,options:OptionsPattern[]]:=Module[{dim=DimOfManifold@@DependenciesOfTensor[metric],indQ=If[InducedFrom[metric]===Null,False,True]},
If[indQ,TracelessProjectorTensor[n,f,{dim-1},metric,inds,options],
TracelessProjectorTensor[n,f,{dim},metric,inds,options]
]
]
TracelessProjectorTensor[n_,f_Integer,metric_?MetricQ|metric_?SymplecticFormQ,options:OptionsPattern[]]:=With[{inds=If[MetricQ[metric],Partition[(Flatten@IndicesOfVBundle[VBundleOfMetric[metric]])[[;;2*n]],n],Partition[(Flatten@IndicesOfVBundle[VBundleOfSymplecticForm[metric]])[[;;2*n]],n]]},TracelessProjectorTensor[n,f,metric,Join[inds[[1]],DownIndex/@inds[[2]]],options]];
(*** No metric in the input ***)
TracelessProjectorTensor[n_,f_Integer,inds_List,options:OptionsPattern[]]:=TracelessProjectorTensor[n,f,BilinearFormsOfVBundle[VBundleOfIndex[inds[[1]]]][[1]],inds,options];
TracelessProjectorTensor[n_,f_Integer,options:OptionsPattern[]]:=TracelessProjectorTensor[n,f,Join[$Metrics,$SymplecticForms][[1]],options]
(********* If the number of traces f is not in the input this correspond to f=1 *******)
TracelessProjectorTensor[n_,{dim_Symbol|dim_Plus},metric_?MetricQ|metric_?SymplecticFormQ,inds_List,options:OptionsPattern[]]:=TracelessProjectorTensor[n,1,{dim},metric,inds,options];
TracelessProjectorTensor[n_,metric_?MetricQ|metric_?SymplecticFormQ,inds_List,options:OptionsPattern[]]:=TracelessProjectorTensor[n,1,metric,inds,options];
TracelessProjectorTensor[n_,inds_List,options:OptionsPattern[]]:=TracelessProjectorTensor[n,1,inds,options];
TracelessProjectorTensor[n_,metric_?MetricQ|metric_?SymplecticFormQ,options:OptionsPattern[]]:=TracelessProjectorTensor[n,1,metric,options];
TracelessProjectorTensor[n_,options:OptionsPattern[]]:=TracelessProjectorTensor[n,1,options];


(* ::Input::Initialization:: *)
(**********************************************************************************************************)
(**********************************************************************************************************)
(************************** Traceless projector of simple GL-modules V^\[Mu] ***********************************)
(**********************************************************************************************************)
(**********************************************************************************************************)
Options[GLTracelessProjector]:={Output->Tensor}
GLTracelessProjector[n_,\[Mu]_List ,{dim_Integer|dim_Symbol|dim_Plus},metric_?MetricQ|metric_?SymplecticFormQ,inds_List,options:OptionsPattern[]]:=Module[{output,dressed,symplecticQ=SymplecticFormQ[metric]},
{output}=OptionValue[{GLTracelessProjector},{options},{Output}];
If[symplecticQ,If[Head[dim]===Integer||Head[dim]===Plus,BrauerToTensor[SnTracelessProjector[n,TransposePartition[\[Mu]],{-dim},SchurWeylDual->SymplecticGroup,Dressed->CentralYoung],metric,inds,Output->output,SymplecticGroup->symplecticQ],BrauerToTensor[SnTracelessProjector[n,TransposePartition[\[Mu]],{dim},SchurWeylDual->SymplecticGroup,Dressed->CentralYoung]/.dim->-dim,metric,inds,Output->output,SymplecticGroup->symplecticQ]],BrauerToTensor[SnTracelessProjector[n,\[Mu],{dim},SchurWeylDual->OrthogonalGroup,Dressed->CentralYoung],metric,inds,Output->output,SymplecticGroup->symplecticQ]]
]
(****** No indices in the input *************)
GLTracelessProjector[n_,\[Mu]_List ,{dim_Integer|dim_Symbol|dim_Plus},metric_?MetricQ|metric_?SymplecticFormQ,options:OptionsPattern[]]:=With[{inds=If[MetricQ[metric],Partition[(Flatten@IndicesOfVBundle[VBundleOfMetric[metric]])[[;;2*n]],n],Partition[(Flatten@IndicesOfVBundle[VBundleOfSymplecticForm[metric]])[[;;2*n]],n]]},GLTracelessProjector[n,\[Mu],{dim},metric,Join[inds[[1]],DownIndex/@inds[[2]]],options]];
(************ No metric in the input ************)
GLTracelessProjector[n_,\[Mu]_List ,{dim_Integer|dim_Symbol|dim_Plus},inds_List,options:OptionsPattern[]]:=GLTracelessProjector[n,\[Mu],{dim},BilinearFormsOfVBundle[VBundleOfIndex[inds[[1]]]][[1]],inds,options];
GLTracelessProjector[n_,\[Mu]_List ,{dim_Integer|dim_Symbol|dim_Plus},options:OptionsPattern[]]:=GLTracelessProjector[n,\[Mu],{dim},Join[$Metrics,$SymplecticForms][[1]],options];
(********************************************************************************************************************************************************)
(************ When there is no dimension input : the default value is DimOfManifold if metric/symplectic form is not induced else DimOfManifold-1 (should be generalized) *******)
(********************************************************************************************************************************************************)
GLTracelessProjector[n_,\[Mu]_List ,metric_?MetricQ|metric_?SymplecticFormQ,inds_List,options:OptionsPattern[]]:=Module[{dim=DimOfManifold@@DependenciesOfTensor[metric],symplecticQ=SymplecticFormQ[metric]},
If[symplecticQ,GLTracelessProjector[n,\[Mu],{dim},metric,inds,options],With[{indQ=If[InducedFrom[metric]===Null,False,True]},
If[indQ,
GLTracelessProjector[n,\[Mu],{dim-1},metric,inds,options],
GLTracelessProjector[n,\[Mu],{dim},metric,inds,options]
]
]
]]
GLTracelessProjector[n_,\[Mu]_List,metric_?MetricQ|metric_?SymplecticFormQ,options:OptionsPattern[]]:=With[{inds=If[MetricQ[metric],Partition[(Flatten@IndicesOfVBundle[VBundleOfMetric[metric]])[[;;2*n]],n],Partition[(Flatten@IndicesOfVBundle[VBundleOfSymplecticForm[metric]])[[;;2*n]],n]]},GLTracelessProjector[n,\[Mu],metric,Join[inds[[1]],DownIndex/@inds[[2]]],options]];

(**** No dim and no metric in the input ***)
GLTracelessProjector[n_,\[Mu]_List,inds_List,options:OptionsPattern[]]:=GLTracelessProjector[n,\[Mu],BilinearFormsOfVBundle[VBundleOfIndex[inds[[1]]]][[1]],inds,options];
GLTracelessProjector[n_,\[Mu]_List?IntegerListQ,options:OptionsPattern[]]:=GLTracelessProjector[n,\[Mu],Join[$Metrics,$SymplecticForms][[1]],options];


(* ::Input::Initialization:: *)
Options[TraceProjectorTensor]:={Output->Tensor}
TraceProjectorTensor[n_,{dim_Integer|dim_Symbol|dim_Plus},metric_?MetricQ|metric_?SymplecticFormQ,inds_List,options:OptionsPattern[]]:=Module[{output,symplecticQ=SymplecticFormQ[metric]},
{output}=OptionValue[{TraceProjectorTensor},{options},{Output}];
If[symplecticQ,If[Head[dim]===Integer||Head[dim]===Plus,BrauerToTensor[TraceProjector[n,{-dim},SchurWeylDual->SymplecticGroup],metric,inds,Output->output,SymplecticGroup->symplecticQ],BrauerToTensor[TraceProjector[n,{dim},SchurWeylDual->SymplecticGroup]/.dim->-dim,metric,inds,Output->output,SymplecticGroup->symplecticQ]],
BrauerToTensor[TraceProjector[n,{dim},SchurWeylDual->OrthogonalGroup],metric,inds,Output->output,SymplecticGroup->symplecticQ]
]
]

(*********************************************************** No indices in the input **********************************************************************************)
TraceProjectorTensor[n_,{dim_Integer|dim_Symbol|dim_Plus},metric_?MetricQ|metric_?SymplecticFormQ,options:OptionsPattern[]]:=With[{inds=If[MetricQ[metric],Partition[(Flatten@IndicesOfVBundle[VBundleOfMetric[metric]])[[;;2*n]],n],Partition[(Flatten@IndicesOfVBundle[VBundleOfSymplecticForm[metric]])[[;;2*n]],n]]},TraceProjectorTensor[n,{dim},metric,Join[inds[[1]],DownIndex/@inds[[2]]],options]];
(************* No metric in the input *******************************)
TraceProjectorTensor[n_,{dim_Integer|dim_Symbol|dim_Plus},options:OptionsPattern[]]:=TraceProjectorTensor[n,{dim},Join[$Metrics,$SymplecticForms][[1]],options];
TraceProjectorTensor[n_,{dim_Integer|dim_Symbol|dim_Plus},inds_List,options:OptionsPattern[]]:=TraceProjectorTensor[n,{dim},BilinearFormsOfVBundle[VBundleOfIndex[inds[[1]]]][[1]],inds,options]
(*****************************************************************************************)
(************ When there is no dimension input : the default value is DimOfManifold if metric/symplectic form is not induced else DimOfManifold-1 (should be generalized) *******)
(*************************************************************************************************************************)
TraceProjectorTensor[n_,metric_?MetricQ|metric_?SymplecticFormQ,inds_List,options:OptionsPattern[]]:=Module[{dim=DimOfManifold@@DependenciesOfTensor[metric],symplecticQ1,symplecticQ2=SymplecticFormQ[metric]},
If[symplecticQ2,TraceProjectorTensor[n,{dim},metric,inds,options],With[{indQ=If[InducedFrom[metric]===Null,False,True]},
If[indQ,TraceProjectorTensor[n,{dim-1},metric,inds,options],
TraceProjectorTensor[n,{dim},metric,inds,options]
]
]
]
]
(*************************************** No indices in the input ******************************************)
TraceProjectorTensor[n_,metric_?MetricQ|metric_?SymplecticFormQ,options:OptionsPattern[]]:=With[{inds=If[MetricQ[metric],Partition[(Flatten@IndicesOfVBundle[VBundleOfMetric[metric]])[[;;2*n]],n],Partition[(Flatten@IndicesOfVBundle[VBundleOfSymplecticForm[metric]])[[;;2*n]],n]]},TraceProjectorTensor[n,metric,Join[inds[[1]],DownIndex/@inds[[2]]],options]];
(*************************************** No metric/symplectic form in the input ******************************************)
TraceProjectorTensor[n_,inds_List,options:OptionsPattern[]]:=TraceProjectorTensor[n,BilinearFormsOfVBundle[VBundleOfIndex[inds[[1]]]][[1]],inds,options]
TraceProjectorTensor[n_,options:OptionsPattern[]]:=TraceProjectorTensor[n,Join[$Metrics,$SymplecticForms][[1]],options];


(* ::Input::Initialization:: *)
(* Borrowed from Francesco Torsello: See  arXiv:1904.10464 : this should be somewhere else  *)
SafeCanonical[e_]:=ToCanonical[e, UseMetricOnVBundle -> None]
SafeMakeRule[e_List]:=MakeRule[e,MetricOn->None,ContractMetrics->False]


(* ::Input::Initialization:: *)
Options[CentralYoungProjectorTensor]:={Output->Tensor}
CentralYoungProjectorTensor[\[Mu]_List,g_?MetricQ|g_?SymplecticFormQ,inds_List,options:OptionsPattern[]]:=Module[{output,symplecticQ=SymplecticFormQ[g]},
{output}=OptionValue[{CentralYoungProjectorTensor},{options},{Output}];
If[symplecticQ,BrauerToTensor[CentralYoungProjector[TransposePartition[\[Mu]]],g,inds,Output->output,SymplecticGroup->symplecticQ],BrauerToTensor[CentralYoungProjector[\[Mu]],g,inds,Output->output,SymplecticGroup->symplecticQ]]];
CentralYoungProjectorTensor[\[Mu]_List,g_?MetricQ|g_?SymplecticFormQ,options:OptionsPattern[]]:=Module[{output,symplecticQ=SymplecticFormQ[g]},
{output}=OptionValue[{CentralYoungProjectorTensor},{options},{Output}];
If[symplecticQ,BrauerToTensor[CentralYoungProjector[TransposePartition[\[Mu]]],g,Output->output,SymplecticGroup->symplecticQ],BrauerToTensor[CentralYoungProjector[\[Mu]],Output->output,SymplecticGroup->symplecticQ]]];
(********************* no metric/symplectic form in the input ***********************)
CentralYoungProjectorTensor[\[Mu]_List,inds_List,options:OptionsPattern[]]:=CentralYoungProjectorTensor[\[Mu],BilinearFormsOfVBundle[VBundleOfIndex[inds[[1]]]][[1]],inds,options];
CentralYoungProjectorTensor[\[Mu]_List,options:OptionsPattern[]]:=CentralYoungProjectorTensor[\[Mu],Join[$Metrics,$SymplecticForms][[1]],options]


(* ::Input::Initialization:: *)
TensorToBrauer[exp_]:=Module[{sortedindofexp,unsortedindofexp,orderbrauer,indlist,indtonum,edgelist,range1,range2,arcsup,arcsdown,lines,brauerdiagram},
SetIndexSortPriorities["positional","free","dummy"];
sortedindofexp=IndexSort@IndicesOf[AIndex][exp];
unsortedindofexp=IndicesOf[AIndex][exp];
orderbrauer=Length[sortedindofexp]/2;
indlist=List@@sortedindofexp;
indtonum=MapThread[Rule,Join[{indlist},{Range[2*orderbrauer]}]];
edgelist=Map[Sort,Partition[List@@unsortedindofexp/.indtonum,2]];
SetIndexSortPriorities["free","lexicographic","up"];
BrauerList[Sort@edgelist]
]
TensorToBrauer[a_Plus,options:OptionsPattern[]]:=Plus@@Map[TensorToBrauer[#]&,List@@a]
TensorToBrauer[Times[n_?NumberQ,a_]]:=Times[n,TensorToBrauer[a]];
TensorToBrauer[Times[a_,n_Power]]:=Times[n,TensorToBrauer[a]];
TensorToBrauer[Power[n_,a_]]:=Times[n,TensorToBrauer[a]];


(* ::Input::Initialization:: *)
TracePermuteIndices[expr_,indices_List,0,metric_]:=0;
TracePermuteIndices[0,rest___,options:OptionsPattern[]]:=0;
(********* TracePermuteIndices with input a permutation ********)
TracePermuteIndices0[expr_,indices_List,cycle_System`Cycles,metric_]:=With[{iperm=InversePermutation[cycle],support=PermutationSupport[cycle]},ReplaceIndex[expr,Thread[indices[[support]]->indices[[PermutationReplace[support,iperm]]]]]]
TracePermuteIndices0[expr_,indices_List,d_BrauerList?SymmetricGroupQ,metric_]:=If[SymplecticFormQ[metric],SignatureBrauer[d]*ReplaceIndex[expr,Map[indices[[xAct`BrauerAlgebra`Private`UpInteger[#[[2]]]]]->indices[[#[[1]]]]&,Sequence@@d]],ReplaceIndex[expr,Map[indices[[xAct`BrauerAlgebra`Private`UpInteger[#[[2]]]]]->indices[[#[[1]]]]&,Sequence@@d]]]
(************************************************************************)
(********* TracePermuteIndices with input a Brauerlist with arcs ********)
(************************************************************************)

(********************* Convention Below : diagram acting on tensor from below : not the convention of xPerm *****************)

(*TracePermuteIndicesReplacementRule[indices_List,d_BrauerList]:=With[{n=Length@@d},Flatten[Map[If[UpArcQ[#,n],With[{dummy=UpIndex[DummyAs[indices[[#[[1]]]]]]},{indices[[#[[1]]]]->-dummy,indices[[#[[2]]]]->dummy}],If[xAct`BrauerAlgebra`Private`LineQ[#,n],indices[[#[[1]]]]->indices[[#[[2]]-n]],Nothing]]&,Sequence@@d]]];
TracePermuteIndicesMetricList[metric_,indices_List,d_BrauerList]:=With[{n=Length@@d},Flatten[Map[If[DownArcQ[#,n],metric@@indices[[#-n]],Nothing]&,Sequence@@d]]]*)

(********************* Convention Above : diagram acting on tensor from above : the convention of xPerm *****************)

TracePermuteIndicesReplacementRule[indices_List,x:BrauerList[d_]]:=Flatten[Map[If[xAct`BrauerAlgebra`Private`ArcDownQ[#],With[{dummy=UpIndex[DummyAs[indices[[xAct`BrauerAlgebra`Private`UpInteger[#[[1]]]]]]]},{indices[[xAct`BrauerAlgebra`Private`UpInteger[#[[1]]]]]->-dummy,indices[[xAct`BrauerAlgebra`Private`UpInteger[#[[2]]]]]->dummy}],If[xAct`BrauerAlgebra`Private`LineQ[#],indices[[xAct`BrauerAlgebra`Private`UpInteger[#[[2]]]]]->indices[[#[[1]]]],Nothing]]&,d]];

TracePermuteIndicesMetricList[metric_,indices_List,x:BrauerList[d_]]:=Flatten[Map[If[xAct`BrauerAlgebra`Private`ArcUpQ[#],metric@@indices[[#]],Nothing]&,d]];


TracePermuteIndices0[expr_,indices_List,d_BrauerList,metric_]:=If[SymplecticFormQ[metric],SignatureBrauer[d]*Times@@TracePermuteIndicesMetricList[metric,indices,d]*ReplaceIndex[expr,TracePermuteIndicesReplacementRule[indices,d]],Times@@TracePermuteIndicesMetricList[metric,indices,d]*ReplaceIndex[expr,TracePermuteIndicesReplacementRule[indices,d]]];

(**************************************************************************************************************************)

(*TracePermuteIndices[expr_,indices_List,x_Plus,metric_]:=(TracePermuteIndices[expr,indices,#1,metric]&)/@x;
TracePermuteIndices[expr_,indices_List,k_*(x_System`Cycles|x_BrauerList|x_Bracelets|x_Plus),metric_]/;TrueQ[xAct`BrauerAlgebra`Private`ScalarExpressionForConjugacyClassProductQ[k,DimOfManifold@@DependenciesOfTensor[metric]]]:=k*TracePermuteIndices[expr,indices,x,metric]*)

(*************************************************************)
(********* TracePermuteIndices with input a Bracelets ********)
(*************************************************************)
TracePermuteIndices0[expr_,indices_List,btab_Bracelets,metric_]:=
Total[TracePermuteIndices0[expr,indices,#,metric]&/@ConjugacyClass[btab]]
(********* TracePermuteIndices on Class Tensor with input a Bracelets ********)
TracePermuteIndices0[ClassTensor[exp___][inds___],btab_Bracelets,metric_]:=TracePermuteIndices[ClassTensor[exp][inds],List[inds],btab,metric]
(*************************************************************)
(************ TracePermuteIndices : main function ************)
(*************************************************************)
TracePermuteIndices[expr_,indices_List,exp1_,metric_]:=exp1/.x_BrauerList|x_System`Cycles|x_Bracelets:>TracePermuteIndices0[expr,indices,x,metric]
(******************************** Default value for the metric (symplectic form) *********************************************)
TracePermuteIndices[expr_,indices_List,x_]:=TracePermuteIndices[expr,indices,x,First[Join[MetricsOfVBundle[VBundleOfIndex[indices[[1]]]],SymplecticFormsOfVBundle[VBundleOfIndex[indices[[1]]]]]]];
(******************************** Default value for the indices (support) *********************************************)
TracePermuteIndices[expr_,x_]:=TracePermuteIndices[expr,List@@IndicesOf[Free][expr],x];
TracePermuteIndices[expr_,x_,g_?MetricQ|g_?SymplecticFormQ]:=TracePermuteIndices[expr,List@@IndicesOf[Free][expr],x,g];


(* ::Input::Initialization:: *)
xTensorQ[ClassTensor[tensorheadslist_,btab_Bracelets]]^:=True;
PrintAs[ClassTensor[tensorheadslist_,btab_Bracelets]]^:=RowBox[{UnderscriptBox["Class",StyleBox[ToString[Sequence@@btab],10]],"[",Sequence@@(PrintAs/@tensorheadslist),"]"}];
SlotsOfTensor[ClassTensor[tensorheadslist_,btab_Bracelets]]^:=Join@@(SlotsOfTensor/@tensorheadslist);
DependenciesOfTensor[ClassTensor[tensorheadslist_,btab_Bracelets]]^:=Union@@(DependenciesOfTensor/@tensorheadslist);
ClassTensor/:SymmetryGroupOfTensor[x:ClassTensor[tensor_,btab_Bracelets]]:=InternalSymmetryClassTensor[x]


(* ::Input::Initialization:: *)
ClassTensor/:ClassTensor[tens_,k_*btab_Bracelets][inds___]:=k*ClassTensor[tens,btab][inds]
ClassTensor/:ClassTensor[tens_,exp_Plus][inds___]:=ClassTensor[tens,#][inds]&/@exp
ClassTensor/:ClassTensor[tens_,k_*exp_Plus][inds___]:=k*ClassTensor[tens,exp][inds]


(* ::Input::Initialization:: *)
InternalExprClassTensor[ClassTensor[headlist_,bracelet_]]:=
Module[{numindices=Length/@SlotsOfTensor/@headlist,slotlist,partitionedslots,internalexpr},
slotlist=xAct`xTensor`Private`slot/@Range[Plus@@numindices];
partitionedslots=IndexList@@@Internal`PartitionRagged[slotlist,numindices];
internalexpr=Inner[(#1@@#2)&,headlist,partitionedslots,Times]
]


(* ::Input::Initialization:: *)
InternalSymmetryClassTensor[x:(ClassTensor[headlist_,bracelet_])]:=Module[{internalexpr=InternalExprClassTensor[x],tempinds=DummyIn/@SlotsOfTensor[x],rule},
rule=Thread[Rule[Flatten[Map[List@@#&,List@@internalexpr]],tempinds]];
SymmetryOf[internalexpr/.rule][[4]]
]


(* ::Input::Initialization:: *)
ExpandClassTensor1[x:(ClassTensor[headlist_,bracelet_][inds___]),g_]:=With[{indlist=List[inds],slotlist=xAct`xTensor`Private`slot/@Range[Length[List[inds]]],internalexpr=InternalExprClassTensor[Head@x]},
TracePermuteIndices[internalexpr/.Thread@Rule[slotlist,indlist],List[inds],bracelet,g]
]
ExpandClassTensor1[x:(ClassTensor[headlist_,bracelet_][inds___])]:=ExpandClassTensor1[x,First[Join[MetricsOfVBundle[VBundleOfIndex[List[inds][[1]]]],SymplecticFormsOfVBundle[VBundleOfIndex[List[inds][[1]]]]]]]


(* ::Input::Initialization:: *)
ExpandClassTensor[expr_,g___]:=
expr/.x:(ClassTensor[___][inds___]):>ExpandClassTensor1[x,g]


(* ::Input::Initialization:: *)
ToClassTensor[expr_,class_]:=ToClassTensor1[xAct`xTensor`Private`MathInputExpand@expr,class]


(* ::Input::Initialization:: *)
ToClassTensor1[expr_Plus,other__]:=ToClassTensor1[#,other]&/@expr
ToClassTensor1[0,other__]:=0


(* ::Input::Initialization:: *)
ToClassTensor1[x_?ConstantQ y_,other__]:=x ToClassTensor1[y,other]
ToClassTensor1[Scalar[x_] y_,other__]:=Scalar[x] ToClassTensor1[y,other]
ToClassTensor1[(F_?ScalarFunctionQ)[Scalar[x_]]y_,other__]:=F[Scalar[x]] ToClassTensor1[y,other]
ToClassTensor1[(F_?ScalarFunctionQ)[x_?xTensorQ[]]y_,other__]:=F[x[]] ToClassTensor1[y,other]
ToClassTensor1[x_?ScalarQ y_,other__]:=x ToClassTensor1[y,other]
ToClassTensor1[Times[x___,y_?xTensorQ[],z___],other__]:=y[]ToClassTensor1[Times[x,z],other]
ToClassTensor1[Times[x___,Power[y_?xTensorQ[],n_],z___],other__]:=Power[y[],n]ToClassTensor1[Times[x,z],other]
ToClassTensor1[Times[x___,Power[Scalar[y_],n_],z___],other__]:=Power[Scalar[y],n]ToClassTensor1[Times[x,z],other]
ToClassTensor1[Times[x___,Power[y_?ScalarQ ,n_],z___],other__]:=Power[y,n]ToClassTensor1[Times[x,z],other]

ToClassTensor1[expr:Times[_?xTensorQ[__],_?xTensorQ[__]...],other__]:=ToClassTensor2[expr,other]
ToClassTensor1[T_?xTensorQ[tensorinds__],other__]:=ToClassTensor2[T[tensorinds],other]


(* ::Input::Initialization:: *)
TimesToList[expr_Times]:=List@@expr
TimesToList[xAct`xTensor`Private`VerbatimProduct[Times][expr__]]:=(List[expr]/.xAct`xTensor`Private`Scalar1[Scalarexpr_]:>Scalarexpr)
TimesToList[T_?xTensorQ[tensorinds__]]:=List[T[tensorinds]]


(* ::Input::Initialization:: *)
ToClassTensor2[expr_,class_]:=
Module[{n,slotexpr,slotrules,internalsym,slotexprlist, slotlist1, slotlist2,HeadList, tensorinds},
{n,slotexpr,slotrules,internalsym}=List@@SymmetryOf[expr];
(* Sort the tensors *)
slotexprlist=Sort[TimesToList@slotexpr];
slotlist1=Join@@List@@@slotexprlist; 
(* Remove slots that does not contain abstract indices *)
slotlist2=Select[slotlist1,Head[#]===xAct`xTensor`Private`slot&];
HeadList=Head/@slotexprlist;
tensorinds=slotlist1/.slotrules;
ClassTensor[HeadList,class]@@tensorinds
]


(* ::Input::Initialization:: *)
(*ClassTensor::class="The size of `1` should be less or equal to the number of indices";
ClassTensor/:ClassTensor[tens_,btab_][inds___]/;Length[Flatten@@btab]>Length[List[inds]]:=Throw@Message[ClassTensor::class,btab]*)


(* ::Input::Initialization:: *)
ClassAction0[btab1_Bracelets,ClassTensor[tens_,btab2_?IdentityTabQ][inds___]]:=ClassTensor[tens,btab1][inds]
ClassAction0[btab1_?IdentityTabQ,ClassTensor[tens_,btab2_][inds___]]:=ClassTensor[tens,btab2][inds]
ClassAction0[btab1_Bracelets,ClassTensor[tens_,btab2_][inds___]]:=If[SymplecticFormQ[BilinearFormOfTensor[tens[[1]]]],ClassTensor[tens,ConjugacyClassProduct[{-DimOfManifold@@DependenciesOfTensor[tens[[1]]]},btab1,btab2]][inds],ClassTensor[tens,ConjugacyClassProduct[{DimOfManifold@@DependenciesOfTensor[tens[[1]]]},btab1,btab2]][inds]]

ClassAction[btab1_Bracelets,exp_]:=exp/.x:ClassTensor[tens_,btab2_][inds___]:>ClassAction0[btab1,x]
ClassAction[btab1_Bracelets,k_*ClassTensor[tens_,btab2_][inds___]]:=k*ClassAction[btab1,ClassTensor[tens,btab2][inds]]
ClassAction[btab1_Bracelets,exp_Plus]:=Map[ClassAction[btab1,#]&,exp]


(* ::Input::Initialization:: *)
Options[CentralYoungProject]:={Output->Tensor}
CentralYoungProject[exp_,\[Mu]_List,options:OptionsPattern[]]:=Module[{indice=List@@IndicesOf[Free][exp],output},
{output}=OptionValue[{CentralYoungProject},{options},{Output}];
If[output===Tensor,
MapIfPlus[TracePermuteIndices[#,indice,CentralYoungProjector[\[Mu]]]&,exp],
If[output===ClassTensor,ToClassTensor[exp,CentralYoungProjector[\[Mu]]]]]];


(* ::Input::Initialization:: *)
SymTableau[tableau:{{___Integer}...},options___?OptionQ]:=Module[{tab,manifestsym,transpose,sgs,cycles},manifestsym=ManifestSym/. CheckOptions[options]/. Options[YoungSymmetrizer];
transpose=TransposeTableau[tableau];
(*The first set of cycles is simply the (anti)symmetrization of the tableau.*)sgs=If[manifestsym===Antisymmetric,Antisymmetric[#,Cycles]&/@transpose,Symmetric[#,Cycles]&/@tableau];
cycles=sgs/. StrongGenSet[_List,GenSet[c___]]:>c;
StrongGenSet[Union@@tableau,GenSet@@cycles]
]


(* ::Input::Initialization:: *)
signperm[cycles_Cycles]:=1
signperm[-cycles_Cycles]:=-1


(* ::Input::Initialization:: *)
(*********** Function from xTras ******************)
TableauSymmetric[tableau_:{{___Integer}...},options___?OptionQ]:=Module[{tab,manifestsym,transpose,sgs,cycles,samelengths,pairs,extracycles,sign},manifestsym=ManifestSym/. CheckOptions[options]/. Options[YoungSymmetrizer];
transpose=TransposeTableau[tableau];
(*The first set of cycles is simply the (anti)symmetrization of the tableau.*)sgs=If[manifestsym===Antisymmetric,Antisymmetric[#,Cycles]&/@transpose,Symmetric[#,Cycles]&/@tableau];
cycles=sgs/. StrongGenSet[_List,GenSet[c___]]:>c;
(*The second set of cycles comes from the additional symmetry present when two or more rows or columns have the same length and can be interchanged.*)tab=If[manifestsym===Antisymmetric,transpose,tableau];
samelengths=Select[(*Can't use GatherBy here,because that's MMA 7 and newer.*)Function[x,Select[tab,Length[#]===x&]]/@DeleteDuplicates[Length/@tab],Length[#]>1&];
If[manifestsym===Antisymmetric,sign=1,sign=-1];
pairs[list_List]:=Cycles@@Transpose[{list[[#]],list[[#+1]]}]&/@Range[Length@list-1];
extracycles=Flatten[pairs/@samelengths]/. c_Cycles:>sign^Length[c]*c;
(*The complete SGS is then:*)StrongGenSet[Union@@tableau,GenSet@@Join[cycles,extracycles]]];


(* ::Input::Initialization:: *)
(*Options[YoungProjectSymH]:={ManifestSym->Symmetric}*)
YoungProjectSymH[tensor_?xTensorQ[inds___],stdtab_List,options:OptionsPattern[]]:=Module[{manifestsym,order=Length@Flatten[stdtab],sgs1,sgs2,group1,group2,symfactor1,symfactor11,symfactor2,supportstring,indiceslist,signs,multiplicities=DimOfIrrepSn[Length/@stdtab]},
{manifestsym}=OptionValue[{YoungSymmetrizer},{options},{ManifestSym}];
If[manifestsym===Antisymmetric,
sgs1=TableauSymmetric[stdtab,ManifestSym->Symmetric];
sgs2=SymTableau[stdtab,ManifestSym->Antisymmetric],
sgs1=TableauSymmetric[stdtab,ManifestSym->Antisymmetric];
sgs2=SymTableau[stdtab,ManifestSym->Symmetric]
];
group1=List@@Dimino[sgs1]/.ID->Cycles[];
group2=List@@Dimino[sgs2]/.ID->Cycles[];
symfactor1=OrderOfGroup[sgs1];
symfactor2=Length[Intersection[group1,group2]];
supportstring=StringJoin[Append[Prepend[ToString/@sgs1[[1]],"("],")"]];
signs=signperm/@group2;
indiceslist=PermuteList[List[inds],#]&/@group2;
symfactor1/symfactor2*multiplicities/(order!)Plus@@MapThread[#1*ToCanonical[#2]&,{signs,Map[SymH[{tensor},sgs1,supportstring]@@#&,indiceslist]}]
]
(*********** Need to be modified to work on general expression ***************)
YoungProjectSymH[k_*exp_Plus,stdtab_List,options:OptionsPattern[]]:=k*YoungProjectSymH[exp,stdtab,options]


(* ::Input::Initialization:: *)
(******** This function is kept private not to clash with the xTras function ********)

Options[YoungSymmetrize]:={Output->Tensor}
YoungSymmetrize[exp_,tableau:{{___Integer}...},options:OptionsPattern[]]:=Module[{indice=List@@IndicesOf[Free][exp],ms,output},
{output}=OptionValue[{YoungSymmetrize},{options},{Output}];
ms=ManifestSym/.CheckOptions[options]/.Options[YoungSymmetrizer];
If[output===Tensor,
MapIfPlus[TracePermuteIndices[#,indice,YoungSymmetrizer[tableau,ManifestSym->ms]]&,exp],
MapIfPlus[YoungProjectSymH[#,tableau,ManifestSym->ms]&,exp]]
];

YoungSymmetrize[exp_,tableau:{{___Integer}...},indices_List,options:OptionsPattern[]]:=Module[{ms,output},
{output}=OptionValue[{YoungSymmetrize},{options},{Output}];
ms=ManifestSym/.CheckOptions[options]/.Options[YoungSymmetrizer];
If[output===Tensor,
MapIfPlus[TracePermuteIndices[#,indices,YoungSymmetrizer[tableau,ManifestSym->ms]]&,exp],
MapIfPlus[YoungProjectSymH[#,tableau,ManifestSym->ms]&,exp]]
];

(*YoungSymmetrize[exp_,indtab_,options:OptionsPattern[]]:=Module[{indice=List@@IndicesOf[Free][exp],tableau,ms,output},
{ms,output}=OptionValue[{YoungSymmetrize},{options},{ManifestSym,Output}];
tableau=indtab/.Thread[Rule[List@@indice,Range[Length@indice]]];
If[output===Tensor,
MapIfPlus[TracePermuteIndices[#,indice,YoungSymmetrizer[tableau,ManifestSym\[Rule]ms]]&,exp],
MapIfPlus[YoungProjectSymH[#,tableau,ManifestSym\[Rule]ms]&,exp]]
];*)


(* ::Input::Initialization:: *)
SemiNormalYoungProject[exp_,tableau:{{___Integer}...},indices_List]:=MapIfPlus[TracePermuteIndices[#,indices,SemiNormalYoungUnit[tableau]]&,exp];

SemiNormalYoungProject[exp_,tableau:{{___Integer}...}]:=With[{indices=List@@IndicesOf[Free][exp]},
MapIfPlus[TracePermuteIndices[#,indices,SemiNormalYoungUnit[tableau]]&,exp]
];


(* ::Input::Initialization:: *)
PositionsIntersectingSublist[list_]:=Module[{j,aj},SparseArray`StronglyConnectedComponents[Sign[# . Transpose@#&@SparseArray@Thread[Join@@(Function[{j,aj},{j,#}&/@Union@aj]@@@Transpose@{Range@Length@list,list/. Thread[#->Range@Length@#]&@Union@Flatten@list})->1]
]
]];

(********* Experimental : may need to be improved -> Taking exchange symmetries of n-tuple of indices into account -> Plethysm ? Also it can be made into an option for DefTensor : also it should depend on the 
dimension of the manifold  *******)
GLIrrepsOfTensor[exp:tensor_?xTensorQ[inds___]]:=Module[{n=Length[List@@IndicesOf[Free][exp]],sym=List@@Last[SymmetryGroupOfTensor[exp]],rule1={-Cycles[a_]:>{-1,a},Cycles[a_]:>{1,a}},rule2={x:{{-1,list_List},y___}:>{-1,{list,Sequence@@(List[y][[All,2]])}},x:{{1,list_List},y___}:>{1,{list,Sequence@@(List[y][[All,2]])}}},symgrouped,exchangesym,plethysmQ,partitions,connectedsym},
If[sym==={},LittlewoodRichardsonRule[Sequence@@ConstantArray[{1},n]],
symgrouped=DeleteCases[sym,Cycles[a_,b__]|-Cycles[a_,b__]]/.rule1;
(*Print[symgrouped];*)
connectedsym=PositionsIntersectingSublist[symgrouped[[All,2]]];
symgrouped=Map[symgrouped[[#]]/.rule2&,connectedsym];
(*Print[symgrouped];
Print[exchangesym];*)
partitions=Map[With[{indices=Union@@#[[2]]},If[#[[1]]==-1,TransposePartition[{Length[indices]}],{Length[indices]}]]&,symgrouped];
partitions=Join[partitions,ConstantArray[{1},n-Tr[Tr/@partitions]]];
(*Print[partitions];*)
partitions=LittlewoodRichardsonRule[Sequence@@partitions]
]
]

(********* Taking exchange of n-tuple of indices into account -> Plethysm  : in developpement *******)
GLIrrepsOfTensorPlethysm[exp:tensor_?xTensorQ[inds___]]:=Module[{n=Length[List@@IndicesOf[Free][exp]],sym=List@@Last[SymmetryGroupOfTensor[exp]],rule1={-Cycles[a_]:>{-1,a},Cycles[a_]:>{1,a}},rule2={x:{{-1,list_List},y___}:>{-1,{list,Sequence@@(List[y][[All,2]])}},x:{{1,list_List},y___}:>{1,{list,Sequence@@(List[y][[All,2]])}}},symgrouped,exchangesym,plethysmQ,partitionsindices,symgroupedindices,connectedsym,nakedindices},
If[sym==={},LittlewoodRichardsonRule[Sequence@@ConstantArray[{1},n]],
symgrouped=DeleteCases[sym,Cycles[a_,b__]|-Cycles[a_,b__]]/.rule1;
Print[symgrouped];
If[symgrouped=!={},connectedsym=PositionsIntersectingSublist[symgrouped[[All,2]]];
symgrouped=Map[symgrouped[[#]]/.rule2&,connectedsym]];
symgroupedindices=DeleteDuplicates[Flatten[symgrouped[[All,2]]]];
Print[symgrouped];
Print[symgroupedindices];
partitionsindices=Map[With[{indices=Union@@#[[2]]},If[#[[1]]==-1,{TransposePartition[{Length[indices]}],indices},{{Length[indices]},indices}]]&,symgrouped];
Print[partitionsindices];
(**** Indices with no "group" symmetries ****)
nakedindices=mycomplementSmall[Range[n],symgroupedindices];
partitionsindices=Join[partitionsindices,Map[{{1},{#}}&,nakedindices]];
Print[partitionsindices];
(*partitionsindices=Join[partitionsindices,ConstantArray[{1},n-Tr[Tr/@partitionsindices]]];*)
exchangesym=DeleteCases[sym,Cycles[a_]|-Cycles[a_]];
Print[exchangesym];
]
]


(* ::Input::Initialization:: *)
Options[GLIsotypicProject]:={Output->Tensor}
(****** Projection onto the direct sum of equivalent irreps *****)
GLIsotypicProject[exp_,diagram:{___Integer},options:OptionsPattern[]]:=Module[{output},
{output}=OptionValue[{GLIrreducibleProject},{options},{Output}];
CentralYoungProject[exp,diagram,Output->output]]
(***** Optimization from symmetries of tensor ***)
GLIsotypicProject[exp:tensor_?xTensorQ[inds___],diagram:{___Integer},options:OptionsPattern[]]/;!MemberQ[GLIrrepsOfTensor[exp],diagram]:=0;
(***** GLCentralIrreducibleProject=GLIsotypicProject ***)
Options[GLIsotypicProject]:={Output->Tensor}
GLCentralIrreducibleProject[exp_,diagram:{___Integer},options:OptionsPattern[]]:=GLIsotypicProject[exp,diagram,options];
GLCentralIrreducibleProject[exp:tensor_?xTensorQ[inds___],diagram:{___Integer},options:OptionsPattern[]]/;!MemberQ[GLIrrepsOfTensor[exp],diagram]:=0;




(* ::Input::Initialization:: *)
Options[GLIrreducibleProject]:={Method->SemiNormalYoungUnit,Output->Tensor}
GLIrreducibleProject[exp_,tableau:{{___Integer}...},indices_List,options:OptionsPattern[]]:=Module[{method,ms},
{method}=OptionValue[{GLIrreducibleProject},{options},{Method}];
If[method===SemiNormalYoungUnit,
SemiNormalYoungProject[exp,tableau,indices],
If[method===YoungSymmetrizer,
YoungSymmetrize[exp,tableau,indices]
]
]
]
GLIrreducibleProject[exp_,tableau:{{___Integer}...},options:OptionsPattern[]]:=GLIrreducibleProject[exp,tableau,List@@IndicesOf[Free][exp],options]

(***** Optimization from symmetries of tensor ***)
GLIrreducibleProject[exp:tensor_?xTensorQ[inds___],tableau:{{___Integer}...},indices_List,options:OptionsPattern[]]/;!MemberQ[GLIrrepsOfTensor[exp],Length/@tableau]:=0


(* ::Input::Initialization:: *)
Unprotect[Plethysm]
Plethysm[\[Mu]_List,\[Lambda]_List]:=Sequence@@@(List@@Plethysm[SchurFunction[\[Mu]],SchurFunction[\[Lambda]]])
Plethysm[\[Mu]_List,x:{\[Lambda]__List}]:=Flatten[Map[Plethysm[\[Mu],#]&,x],1]


(* ::Input::Initialization:: *)
(********** Private functions for collecting expression with metric or symplectic form ***)
MetricProducts[inds_,metric_,1]:=Map[metric@@#&,Subsets[inds,{2}]]
MetricProducts[inds_,metric_,n_]/;n>IntegerPart[Length[inds]/2]:={};
MetricProducts[inds_,metric_,n_]:=Times@@@Select[Subsets[MetricProducts[inds,metric,1],{n}],DuplicateFreeQ[Flatten[Map[List@@#&,#]]]&]

SymplecticFormProducts[inds_,metric_,1]:=Map[If[UpIndexQ[#[[1]]]&&UpIndexQ[#[[2]]],Inv[metric]@@#,If[DownIndexQ[#[[1]]]&&DownIndexQ[#[[2]]],metric@@#,If[DownIndexQ[#[[1]]]&&UpIndexQ[#[[2]]],delta@@#,delta@@{#[[2]],#[[1]]}]]]&,Subsets[inds,{2}]]
SymplecticFormProducts[inds_,metric_,n_]/;n>IntegerPart[Length[inds]/2]:={};
SymplecticFormProducts[inds_,metric_,n_]:=Times@@@Select[Subsets[SymplecticFormProducts[inds,metric,1],{n}],DuplicateFreeQ[Flatten[Map[List@@#&,#]]]&]

BilinearFormProducts[inds_,metric_,1]:=If[SymplecticFormQ[metric],SymplecticFormProducts[inds,metric,1],MetricProducts[inds,metric,1]]
BilinearFormProducts[inds_,metric_,n_]/;n>IntegerPart[Length[inds]/2]:={};
BilinearFormProducts[inds_,metric_,n_]:=If[SymplecticFormQ[metric],SymplecticFormProducts[inds,metric,n],MetricProducts[inds,metric,n]]


(* ::Input::Initialization:: *)
(******** Projections of tensors which are not irreps of GL ***********)
Options[TracelessProject]:={Output->Tensor,Collect->True}
TracelessProject[expr_,f_Integer,metric_?MetricQ|metric_?SymplecticFormQ,inds_List,options:OptionsPattern[]]:=Module[{n=Length@inds,dim=DimOfManifold@@DependenciesOfTensor[metric],projector,symplecticQ=SymplecticFormQ[metric],tensors=Map[ToExpression[StringJoin["_",ToString[#]]]&,DeleteDuplicates[Head/@FindAllOfType[expr,Tensor]]],output,collectQ},
{output,collectQ}=OptionValue[{TracelessProject},{options},{Output,Collect}];
If[symplecticQ,
If[IntegerQ[dim],projector=TracelessProjector[n,f,{-dim},SchurWeylDual->SymplecticGroup],projector=TracelessProjector[n,f,{dim},SchurWeylDual->SymplecticGroup]/.dim->-dim],
projector=TracelessProjector[n,f,{dim},SchurWeylDual->OrthogonalGroup]];
If[output===ClassTensor,
ToClassTensor[expr,projector],
If[output===Tensor,
If[collectQ,With[{collectlist={Flatten[BilinearFormProducts[inds,metric,#]&/@Reverse[Range[IntegerPart[Length[inds]/2]]]],Sequence@@tensors}},Collect[TracePermuteIndices[expr,inds,projector,metric],collectlist,Factor]],
TracePermuteIndices[expr,inds,projector,metric]]]]
];
(************ No indices in input ***************)
TracelessProject[expr_,f_Integer,metric_?MetricQ|metric_?SymplecticFormQ,options:OptionsPattern[]]:=TracelessProject[expr,f,metric,List@@IndicesOf[Free][expr],options];
(************ No f in the input *******)
TracelessProject[expr_,inds_List,metric_?MetricQ|metric_?SymplecticFormQ,options:OptionsPattern[]]:=TracelessProject[expr,1,metric,inds,options];
(************ No metric in the input : need BiliniarForm of Expression and error message if several bilinear forms*******)
TracelessProject[expr_,f_Integer,inds_List,options:OptionsPattern[]]:=With[{bilinearforms=BilinearFormsOfExpression[expr]},TracelessProject[expr,f,bilinearforms[[1]],inds,options]]
(************ No indices and no f in the input ***************)
TracelessProject[expr_,metric_?MetricQ|metric_?SymplecticFormQ,options:OptionsPattern[]]:=TracelessProject[expr,1,metric,options]
(************ No indices and no metric in the input ***************)
TracelessProject[expr_,f_Integer,options:OptionsPattern[]]:=TracelessProject[expr,f,List@@IndicesOf[Free][expr],options]
(************ No f and no metric in the input ***************)
TracelessProject[expr_,inds_List,options:OptionsPattern[]]:=TracelessProject[expr,1,List@@IndicesOf[Free][expr],options]
(************ No indices, no f and no metric in the input ***************)
TracelessProject[expr_,options:OptionsPattern[]]:=TracelessProject[expr,List@@IndicesOf[Free][expr],options];


(* ::Input::Initialization:: *)
(******************************************************************)
(******** Projections of tensors which are irreps of GL ***********)
(******************************************************************)
Options[GLTracelessProject]:={Output->Tensor,Collect->True,Dressed->None}
GLTracelessProject[expr_,\[Mu]_List,metric_?MetricQ|metric_?SymplecticFormQ,inds_List,options:OptionsPattern[]]:=Module[{n=Length@inds,dim=DimOfManifold@@DependenciesOfTensor[metric],projector,symplecticQ=SymplecticFormQ[metric],tensors=Map[ToExpression[StringJoin["_",ToString[#]]]&,DeleteDuplicates[Head/@FindAllOfType[expr,Tensor]]],output,collectQ,dressed},
{output,collectQ,dressed}=OptionValue[{GLTracelessProject},{options},{Output,Collect,Dressed}];
If[symplecticQ,
If[IntegerQ[dim],projector=SnTracelessProjector[n,TransposePartition[\[Mu]],{-dim},SchurWeylDual->SymplecticGroup,Dressed->dressed],projector=SnTracelessProjector[n,TransposePartition[\[Mu]],{dim},SchurWeylDual->SymplecticGroup,Dressed->dressed]/.dim->-dim],
projector=SnTracelessProjector[n,\[Mu],{dim},SchurWeylDual->OrthogonalGroup,Dressed->dressed]];
If[output===ClassTensor,
ToClassTensor[expr,projector],If[output===Tensor,
If[collectQ,With[{collectlist={Flatten[BilinearFormProducts[inds,metric,#]&/@Reverse[Range[IntegerPart[Length[inds]/2]]]],Sequence@@tensors}},Collect[TracePermuteIndices[expr,inds,projector,metric],collectlist,Factor]],
TracePermuteIndices[expr,inds,projector,metric]]]]
];

(************ No indices in input ***************)
GLTracelessProject[expr_,\[Mu]_List,metric_?MetricQ|metric_?SymplecticFormQ,options:OptionsPattern[]]:=GLTracelessProject[expr,\[Mu],metric,List@@IndicesOf[Free][expr],options];
(************ No metric in the input : need BiliniarForm of Expression and error message if several bilinear forms*******)
GLTracelessProject[expr_,\[Mu]_List,inds_List,options:OptionsPattern[]]:=With[{bilinearforms=BilinearFormsOfExpression[expr]},GLTracelessProject[expr,\[Mu],bilinearforms[[1]],inds,options]]
(************ No indices and no metric in the input ***************)
GLTracelessProject[expr_,\[Mu]_List?IntegerListQ,options:OptionsPattern[]]:=GLTracelessProject[expr,\[Mu],List@@IndicesOf[Free][expr],options]


(* ::Input::Initialization:: *)
(*******************************************)
(***** Scalar invariant : TraceProject *****)
(*******************************************)

Options[TraceProject]:={Output->Tensor,Collect->True}
TraceProject[exp_,metric_?MetricQ|metric_?SymplecticFormQ,inds_List,options:OptionsPattern[]]:=Module[{n=Length@inds,projector,dim=DimOfManifold@@DependenciesOfTensor[metric],symplecticQ=SymplecticFormQ[metric],tensors=Map[ToExpression[StringJoin["_",ToString[#]]]&,DeleteDuplicates[Head/@FindAllOfType[exp,Tensor]]],output,collectQ},
{output,collectQ}=OptionValue[{TraceProject},{options},{Output,Collect}];
If[symplecticQ,
If[IntegerQ[dim],projector=TraceProjector[n,{-dim},SchurWeylDual->SymplecticGroup],projector=TraceProjector[n,{dim},SchurWeylDual->SymplecticGroup]/.dim->-dim],
projector=TraceProjector[n,{dim},SchurWeylDual->OrthogonalGroup]];
If[output===ClassTensor,
ToClassTensor[exp,projector],If[output===Tensor,
If[collectQ,With[{collectlist={Flatten[BilinearFormProducts[inds,metric,#]&/@Reverse[Range[IntegerPart[Length[inds]/2]]]],Sequence@@tensors}},Collect[TracePermuteIndices[exp,inds,projector,metric],collectlist,Factor]],
TracePermuteIndices[exp,inds,projector,metric]]]]
];

(**** No indices in the input ****)
TraceProject[expr_,metric_?MetricQ|metric_?SymplecticFormQ,options:OptionsPattern[]]:=TraceProject[expr,metric,List@@IndicesOf[Free][expr],options];
(**** No metric in the input ****)
TraceProject[expr_,inds_List,options:OptionsPattern[]]:=With[{bilinearforms=BilinearFormsOfExpression[expr]},TraceProject[expr,bilinearforms[[1]],inds,options]]
(**** No metric and no indices in the input ****)
TraceProject[exp_,options:OptionsPattern[]]:=TraceProject[exp,List@@IndicesOf[Free][exp],options]


(* ::Input::Initialization:: *)
(********* Like GLIrrepsOfTensor OIrrepsOfTensor should be made to depend on dim of manifold also ****)
OIrrepsOfTensor[exp:tensor_?xTensorQ[inds___]]:=SortBy[Flatten[Map[BranchingRule[#,GeneralLinearGroup,OrthogonalGroup]&,GLIrrepsOfTensor[exp]],1],Tr[#]&]


(* ::Input::Initialization:: *)
OIsotypicProject[exp:tensor_?xTensorQ[inds___],\[Lambda]_List,rest___,options:OptionsPattern[]]/;!MemberQ[OIrrepsOfTensor[exp],\[Lambda]]:=0;

Options[OIsotypicProject]:={Output->Tensor}
OIsotypicProject[exp_,n_Integer,\[Lambda]_List,indices_List,metric_?MetricQ,dim_Symbol|dim_Integer|dim_Plus,options:OptionsPattern[]]:=Module[{output,tensors=Map[ToExpression[StringJoin["_",ToString[#]]]&,DeleteDuplicates[Head/@FindAllOfType[exp,Tensor]]]},
{output}=OptionValue[{OIsotypicProject},{options},{Output}];
If[output===ClassTensor,
ToClassTensor[exp,CentralIdempotent[n,\[Lambda],dim]],
With[{collectlist={Flatten[BilinearFormProducts[indices,metric,#]&/@Reverse[Range[IntegerPart[Length[indices]/2]]]],Sequence@@tensors}},
Collect[TracePermuteIndices[exp,indices,CentralIdempotent[n,\[Lambda],dim],metric],collectlist,Factor]]]];

OIsotypicProject[exp_,n_Integer,\[Lambda]_List,indices_List,metric_?MetricQ,options:OptionsPattern[]]:=OIsotypicProject[exp,n,\[Lambda],indices,metric,DimOfManifold@@DependenciesOfTensor[metric],options]
OIsotypicProject[exp_,n_Integer,\[Lambda]_List,indices_List,dim_Symbol|dim_Integer|dim_Plus,options:OptionsPattern[]]:=With[{metric=BilinearFormsOfExpression[exp][[1]]},OIsotypicProject[exp,n,\[Lambda],indices,metric,dim,options]]
OIsotypicProject[exp_,n_Integer,\[Lambda]_List,indices_List,options:OptionsPattern[]]:=OIsotypicProject[exp,n,\[Lambda],indices,DimOfVBundle[VBundleOfIndex[indices[[1]]]],options]
OIsotypicProject[exp_,n_Integer,\[Lambda]_List,options:OptionsPattern[]]:=OIsotypicProject[exp,n,\[Lambda],List@@IndicesOf[Free][exp],options]
OIsotypicProject[exp_,n_Integer,\[Lambda]_List,metric_?MetricQ,options:OptionsPattern[]]:=OIsotypicProject[exp,n,\[Lambda],List@@IndicesOf[Free][exp],metric,options]
OIsotypicProject[exp_,\[Lambda]_List,rest___,options:OptionsPattern[]]:=OIsotypicProject[exp,Length[List@@IndicesOf[Free][exp]],\[Lambda],rest,options];
(************* OCentralIrreducibleProject=OIsotypicProject ****************)
Options[OCentralIrreducibleProject]:={Output->Tensor}
OCentralIrreducibleProject[exp__,options:OptionsPattern[]]:=OIsotypicProject[exp,options]


(* ::Input::Initialization:: *)
(*OIsotypicProject0[exp_,n_,\[Lambda]_,indices_,metric_,dim_]:=TracePermuteIndices[exp,indices,CentralIdempotent[n,\[Lambda],dim],metric]*)


(* ::Input::Initialization:: *)
OIrreducibleProject[exp:tensor_?xTensorQ[inds___],path_List,rest___,options:OptionsPattern[]]/;!MemberQ[OIrrepsOfTensor[exp],Last[path]]:=0
(*OIrreducibleProject[exp_,path_List,indices_List,metric_?MetricQ,dim_Symbol|dim_Integer|dim_Plus,options:OptionsPattern[]]:=Module[{lp=Length[path],tensors=Map[ToExpression[StringJoin["_",ToString[#]]]&,DeleteDuplicates[Head/@FindAllOfType[exp,Tensor]]],collectlist},
collectlist={Flatten[xAct`xBrauer`Private`BilinearFormProducts[indices,metric,#]&/@Reverse[Range[IntegerPart[Length[indices]/2]]]],Sequence@@tensors};
Collect[Fold[ContractMetric[ToCanonical[OIsotypicProject0[#1,Sequence@@#2,indices,metric,dim]]]&,exp,Rest@Thread[List[Range[lp],path]]],collectlist,Factor]]*)

OIrreducibleProject[exp_,path_List,indices_List,metric_?MetricQ,dim_Symbol|dim_Integer|dim_Plus,options:OptionsPattern[]]:=Module[{lp=Length[path],tensors=Map[ToExpression[StringJoin["_",ToString[#]]]&,DeleteDuplicates[Head/@FindAllOfType[exp,Tensor]]],collectlist},
collectlist={Flatten[xAct`xBrauer`Private`BilinearFormProducts[indices,metric,#]&/@Reverse[Range[IntegerPart[Length[indices]/2]]]],Sequence@@tensors};
Collect[TracePermuteIndices[exp,indices,CanonicalPrimitiveIdempotent[lp,path,dim],metric],collectlist,Factor]]


(* ::Input::Initialization:: *)
OIrreducibleProject[exp_,path_List,indices_List,metric_?MetricQ,options:OptionsPattern[]]:=OIrreducibleProject[exp,path,indices,metric,DimOfManifold@@DependenciesOfTensor[metric],options]
OIrreducibleProject[exp_,path_List,indices_List,dim_Symbol|dim_Integer|dim_Plus,options:OptionsPattern[]]:=With[{metric=xAct`xBrauer`Private`BilinearFormsOfExpression[exp][[1]]},OIrreducibleProject[exp,path,indices,metric,dim,options]]
OIrreducibleProject[exp_,path_List,indices_List,options:OptionsPattern[]]:=OIrreducibleProject[exp,path,indices,DimOfVBundle[VBundleOfIndex[indices[[1]]]],options]
OIrreducibleProject[exp_,path_List,options:OptionsPattern[]]:=OIrreducibleProject[exp,path,List@@IndicesOf[Free][exp],options]
OIrreducibleProject[exp_,path_,metric_?MetricQ,options:OptionsPattern[]]:=OIrreducibleProject[exp,path,List@@IndicesOf[Free][exp],metric,options]


(* ::Input::Initialization:: *)
FirstMetricOfVBundle[vbundle_,mess_:True]:=firstmetricofvbundle[vbundle,MetricsOfVBundle[vbundle],mess];
firstmetricofvbundle[vbundle_,{},True]:=Throw@Message[MetricsOfVBundle::missing,"metric",vbundle];
firstmetricofvbundle[vbundle_,{},False]:=Null;
firstmetricofvbundle[vbundle_,list_List,_]:=First[list];
firstmetricofvbundle[vbundle_,list_,_]:=Throw@Message[MetricsOfVBundle::invalid,list,"list of metrics"];


(* ::Input::Initialization:: *)
FirstMetricQ[Null,___]:=False;
FirstMetricQ[metric_]:=FirstMetricQ[metric,VBundleOfMetric[metric]];
FirstMetricQ[metric_,vbundle_]:=metric===FirstMetricOfVBundle[vbundle,True];


(* ::Input::Initialization:: *)
FrozenMetricQ[metric_]:=And[Not@FirstMetricQ[metric],InducedFrom[metric]===Null];


(* ::Input::Initialization:: *)
LeviCivitaQ[covd_?CovDQ,metric_?MetricQ]:=Module[
{ torsionQ=TorsionQ[covd],
met=MetricOfCovD[covd],
metricQ= MetricOfCovD[covd]=!= Null
},
If[!TorsionQ[covd]&&(metricQ),
	If[ToString[met]==ToString[metric],True,False],False]]
LeviCivitaQ[covd_?CovDQ]:=LeviCivitaQ[covd,MasterOf[covd]]
LeviCivitaQ[covd_?CovDQ,_]:=False;


(* ::Input::Initialization:: *)
(****** Convenient Private functions ***)
SafeCanonical[e_]:=ToCanonical[e, UseMetricOnVBundle -> None]
SafeToRule[exp_]:=ToRule[exp,MetricOn->None,ContractMetrics->False];
SafeMakeRule[e_List]:=MakeRule[e,MetricOn->None,ContractMetrics->False]


(* ::Input::Initialization:: *)
SetConformalTo[metric_?MetricQ,{originalmetric_?MetricQ,confactor_}]:=Module[{prot=Unprotect[metric],
vb=VBundleOfMetric[metric],
indices = GetIndicesOfVBundle[VBundleOfMetric[metric], 4],
covdmet=CovDOfMetric[metric],
covdomet=CovDOfMetric[originalmetric],metToomet,ometTomet,christToochrist,ochristTochrist,
riemTooriem,oriemToriem,ricciTooricci,oricciToricci, riccisTooriccis,oriccisToriccis
},
With[{i1= indices[[1]],
		i2= indices[[2]],
	i3= indices[[3]],
	i4= indices[[4]],
	imet=GiveSymbol[Inv,metric],
	iomet=Inv[originalmetric],
	chrismet=GiveSymbol[Christoffel,covdmet],
	chrisomet=GiveSymbol[Christoffel,covdomet],
	riemmet=GiveSymbol[Riemann,covdmet],
	riemomet=GiveSymbol[Riemann,covdomet],
	riccimet=GiveSymbol[Ricci,covdmet],
	ricciomet=GiveSymbol[Ricci,covdomet],
	ricciscalarmet=GiveSymbol[RicciScalar,covdmet],
	ricciscalaromet=GiveSymbol[RicciScalar,covdomet],
	curvQmet=CurvatureRelationsQ[covdmet],
	curvQomet=CurvatureRelationsQ[covdomet]
},
If[curvQmet,ClearCurvatureRelations[covdmet]];
If[curvQomet,ClearCurvatureRelations[covdomet]];
ReportSet[$CommuteCovDsOnScalars,True];
(**  Composition for covariant derivative **)
covdomet[a_]@(f_?ScalarFunctionQ[args___]):=xAct`xTensor`Private`multiD[covdomet[a],f[args]];
(**********************************)
metric/:ConformalFactor[metric,originalmetric]=confactor;
metric/:ConformalFactor[originalmetric,metric]=1/confactor;
metToomet=Join[MakeRule[{metric[-i1,-i2],ConformalFactor[metric,originalmetric]*originalmetric[-i1,-i2]},MetricOn->None],
MakeRule[{imet[i1,i2],ConformalFactor[originalmetric,metric]*iomet[i1,i2]},MetricOn->None],{Determinant[metric][]->confactor^DimOfVBundle[VBundleOfMetric[metric]] Determinant[originalmetric][]}];
ometTomet=Join[
If[FirstMetricQ[originalmetric],
Join[MakeRule[{originalmetric[-i1, -i2],metric[-i1, -i2]*ConformalFactor[originalmetric,metric]},MetricOn->None],MakeRule[{iomet[i1, i2],ConformalFactor[metric,originalmetric]*imet[i1, i2]},MetricOn->None]]],{Determinant[originalmetric][]->Determinant[metric][]/confactor^DimOfVBundle[VBundleOfMetric[metric]]}];
christToochrist=SafeMakeRule[{chrismet[i1,-i2,-i3],ChangeCovD[(chrismet[i1,-i2,-i3]//ChristoffelToGradMetric)/.metToomet,PD,covdomet]//SafeCanonical}];
ochristTochrist=SafeMakeRule[{chrisomet[i1,-i2,-i3],ChangeCovD[(chrisomet[i1,-i2,-i3]//ChristoffelToGradMetric)/.ometTomet,PD,covdmet]//SafeCanonical}];
riemTooriem=SafeMakeRule[{riemmet[-i1,-i2,-i3,i4],CollectTensors[ChangeCovD[(ChangeCurvature[riemmet[-i1,-i2,-i3,i4],covdmet,covdomet]//BreakChristoffel)/.ochristTochrist/.ometTomet/.christToochrist/.metToomet,covdmet,covdomet],CollectMethod->Default]}];
oriemToriem=SafeMakeRule[{riemomet[-i1,-i2,-i3,i4],CollectTensors[ChangeCovD[(ChangeCurvature[riemomet[-i1,-i2,-i3,i4],covdomet,covdmet]//BreakChristoffel)/.christToochrist/.metToomet/.ochristTochrist/.ometTomet,covdomet,covdmet],CollectMethod->SafeCanonical]}];
ricciTooricci=SafeMakeRule[{riccimet[-i1,-i2],CollectTensors[riemmet[-i1,-i4,-i2,i4]/.riemTooriem]}];
oricciToricci=SafeMakeRule[{ricciomet[-i1,-i2],CollectTensors[riemomet[-i1,-i4,-i2,i4]/.oriemToriem,CollectMethod->SafeCanonical]}];
riccisTooriccis=SafeMakeRule[{ricciscalarmet[],CollectTensors[imet[i1,i2]riccimet[-i1,-i2]/.metToomet/.ricciTooricci]}];
oriccisToriccis=SafeMakeRule[{ricciscalaromet[],CollectTensors[iomet[i1,i2]*ricciomet[-i1,-i2]/.ometTomet/.oricciToricci,CollectMethod->SafeCanonical]}];
(*** we collect all the rules in ConformalRules ***)
metric/:ConformalRules[metric,originalmetric]=Join[metToomet,christToochrist,riemTooriem,ricciTooricci,riccisTooriccis];
metric/:ConformalRules[originalmetric,metric]=Join[ometTomet,ochristTochrist,oriemToriem,oricciToricci,oriccisToriccis];
If[curvQmet,SetCurvatureRelations[covdmet]];
If[curvQomet,SetCurvatureRelations[covdomet]];
Protect[Evaluate[prot]];
]
]


(* ::Input::Initialization:: *)
SetConformalTo[metric_?MetricQ[-i1_,-i2_],{originalmetric_?MetricQ[-i1_,-i2_],confactor_}]:=SetConformalTo[metric,{originalmetric,confactor}];


(* ::Input::Initialization:: *)
ConformalTransform[exp_,met_?MetricQ,confmet_?MetricQ]:=Module[{covdmet=CovDOfMetric[met],covdconfmet=CovDOfMetric[confmet],TM=VBundleOfMetric[met],res},
(** We modify the canonical slots of Riemann tensor for the first metric **)
If[First[$Metrics]===met,
SlotsOfTensor[Riemann[covdmet]]^:={-TM,-TM,-TM,TM}];
If[First[$Metrics]===confmet,
SlotsOfTensor[Riemann[covdconfmet]]^:={-TM,-TM,-TM,TM}];
If[First[$Metrics]=!=confmet,
Return[CollectTensors[(SeparateMetric[met][FixedPoint[BreakChristoffel,ChangeCovD[exp,covdmet,covdconfmet]]])/.ConformalRules[met,confmet],{CollectMethod->SafeCanonical}],Module],
Return[CollectTensors[(SeparateMetric[met][FixedPoint[BreakChristoffel,ChangeCovD[exp,covdmet,covdconfmet]]])/.ConformalRules[met,confmet]],Module]
]
];


(* ::Input::Initialization:: *)
Unprotect[DefMetric]
Off[RuleDelayed::rhs];
Options[DefMetric]:={
PrintAs->Identity,
FlatMetric->False,
InducedFrom->Null,
ConformalTo->Null,
OtherDependencies->{},
WeightedWithBasis->Null,
epsilonOrientationInBasis:>{AIndex,$epsilonSign},
Master->Null,
ProtectNewSymbol:>$ProtectNewSymbols,
DefInfo->{"",""},
DefMetricPerturbation->True}
DefMetric[signdet_,metric_[-ind1_,-ind2_],covd_,options:OptionsPattern[]]:=Catch@With[{
vbundle=VBundleOfIndex[ind1]},

Module[{covdsymbol,flat,inducedfrom,confto,odeps,wwb,eoib,pns,info,flatPD,inducedQ,dim,integerdimQ,frozenQ,firstQ,invertQ,firstmetric,supermetric,vector,LCmetric,test},
(* Options and checks *)
{covdsymbol,flat,inducedfrom,confto,odeps,wwb,eoib,pns,info}=OptionValue[{DefMetric,DefCovD},{options},{SymbolOfCovD,FlatMetric,InducedFrom,ConformalTo,OtherDependencies,WeightedWithBasis,epsilonOrientationInBasis,ProtectNewSymbol,DefInfo}];

xAct`xTensor`Private`DefMetricCheck[signdet,metric[-ind1,-ind2],covd,covdsymbol,flat,inducedfrom,confto,odeps,wwb,eoib];
(* Explore *)
flatPD=flat&&(covd===PD);
dim=DimOfVBundle[vbundle];
integerdimQ=IntegerQ[dim];
(* One and only one of firstQ, inducedQ, frozenQ is True, and the other two are False *)
firstQ=MetricsOfVBundle[vbundle]==={};
inducedQ=And[!firstQ,inducedfrom=!=Null];
frozenQ=And[!firstQ,!inducedQ];
If[inducedQ,{supermetric,vector}=inducedfrom];
If[frozenQ,firstmetric=First[MetricsOfVBundle[vbundle]]];
With[{
manifold=BaseOfVBundle[vbundle],
deps=Union[{BaseOfVBundle[vbundle]},odeps],
vbQ=xAct`xTensor`Private`VBundleIndexQ[vbundle],
vbpmQ=xAct`xTensor`Private`VBundleIndexPMQ[vbundle],
invmetric=If[frozenQ,GiveSymbol[Inv,metric],metric]},

(* Avoid messages from options of DefMetric not accepted in DefTensor or DefCovD *)
Off[OptionValue::nodef];

(* Define metric tensor. Do not protect symbol. Do not use ProjectedWith. It is always symmetric *)
DefTensor[metric[-ind1,-ind2],deps,Symmetric[{1,2}],
ProtectNewSymbol->False,
OrthogonalTo:>If[inducedQ,{vector[ind1]},{}],
DefInfo:>If[info===False,False,{"symmetric metric tensor",""}],
options];

MakexTensions[DefMetric,"Beginning",signdet,metric[-ind1,-ind2],covd,options];

(* Register structure *)
AppendToUnevaluated[$Metrics,metric];
MetricQ[metric]^=True;
CovDOfMetric[metric]^=covd;
VBundleOfMetric[metric]^=vbundle;
xUpAppendTo[MetricsOfVBundle[vbundle],metric];
FlatMetricQ[metric]^=flat;
InducedFrom[metric]^=inducedfrom;

(* Signature *)
If[Head[signdet]===List &&Length[signdet]===3,
SignatureOfMetric[metric]^=signdet;
SignDetOfMetric[metric]^=If[signdet[[3]]===0,(-1)^signdet[[2]],0],
SignDetOfMetric[metric]^=signdet;
];
(* Invertibility *)
invertQ=SignDetOfMetric[metric]=!=0;
(* Define inverse metric. TODO: Orthogonal and Projected? *)
If[invertQ,
If[frozenQ ,
DefTensor[invmetric[ind1,ind2],deps,Symmetric[{1,2}],
ProtectNewSymbol->False,
Master->metric,
DefInfo:>If[info===False,False,{"inverse metric tensor","Metric is frozen!"}],
TensorID->{InvMetric,metric},
PrintAs:>GiveOutputString[Inv,metric],
options]
],
Print["** DefMetric: non-invertible metric being defined! Dangerous!"]
];

(* Directional indices are not allowed in metrics. Why only for first metrics? *)
If[firstQ,
metric[Dir[expr_],b_]:=ReplaceIndex[expr,xAct`xTensor`Private`UltraindexOf[expr]->b];
metric[a_,Dir[expr_]]:=ReplaceIndex[expr,xAct`xTensor`Private`UltraindexOf[expr]->a];
];

(* Define epsilon tensor, with covariant indices. Do not protect symbol *)
metric/:epsilonOrientation[metric,eoib[[1]]]=eoib[[2]];
With[{epsilonname=GiveSymbol[epsilon,metric],
inds=GetIndicesOfVBundle[vbundle,If[integerdimQ,If[inducedQ,dim-1,dim],2]]},
DefTensor[epsilonname@@(ChangeIndex/@inds),deps,Antisymmetric@Range@Length@inds,
PrintAs:>GiveOutputString[epsilon,metric],
ProtectNewSymbol->False,
Master->metric,
OrthogonalTo:>If[inducedQ,{vector[First[inds]]},{}],
ProjectedWith:>If[inducedQ,{metric[-DummyIn[vbundle],First[inds]]},{}],
DefInfo:>If[info===False,False,{"antisymmetric tensor",""}],
TensorID->{epsilon,metric}];
If[Not@integerdimQ && Not@inducedQ,
TagSetDelayed[epsilonname,SymmetryGroupOfTensor[epsilonname[inds1__]],Antisymmetric[Range@Length@{inds1}]];
TagUnset[epsilonname,SymmetryGroupOfTensor[epsilonname]];
TagSetDelayed[epsilonname,SymmetryGroupOfTensor[epsilonname],Antisymmetric[Range@DimOfVBundle@vbundle]]
];

(* Products of two epsilons. In the induced and frozen cases expansions give metric and not delta *)
If[inducedQ ||frozenQ,
epsilonname/:epsilonname[inds1__]epsilonname[inds2__]:=SignDetOfMetric[metric]expandGdelta[metric][inds1,inds2],
epsilonname/:epsilonname[inds1__]epsilonname[inds2__]:=SignDetOfMetric[metric]ExpandGdelta[Gdelta[inds1,inds2]]
];

(* Derivatives of epsilon. Note that we have not yet defined covd (!?) *)
If[frozenQ,
covd[a_][epsilonname[(-b_?vbQ)..]]^=0,
covd[a_][epsilonname[b__?vbpmQ]]^=0
];
TensorDerivative[epsilonname,covd,___]:=Zero;
If[!inducedQ,
If[!frozenQ,
epsilonname/:LieD[v_][epsilonname[inds1__?UpIndexQ]]:=Module[{dummy=DummyIn[vbundle]},-covd[-dummy][ReplaceIndex[v,{UltraindexOf[v]->dummy}]epsilonname[inds1]]]
];
epsilonname/:LieD[v_][epsilonname[inds1__?DownIndexQ]]:=Module[{dummy=DummyIn[vbundle]},covd[-dummy][ReplaceIndex[v,{UltraindexOf[v]->dummy}]epsilonname[inds1]]];
epsilonname/:TensorDerivative[epsilonname,LieD[vhead_?xTensorQ[_]]]:=With[{dummy=DummyIn[vbundle]},MultiplyHead[TensorDerivative[vhead,covd][dummy,-dummy],epsilonname]];
];

(* Special relation in 2d, valid for all types of indices *)
If[dim===2&&firstQ,
epsilonname[a_,b_]epsilonname[c_,d_]^=SignDetOfMetric[metric] (metric[a,c]metric[b,d]-metric[a,d]metric[b,c]);
];

(* Define Tetra, only in dimension 4. This is an algebraic construction, hence valid for frozen metrics *) 
If[dim==4,
With[{TetraName=GiveSymbol[Tetra,metric]},
Module[{i1,i2,i3,i4},
{i1,i2,i3,i4}=GetIndicesOfVBundle[vbundle,4];
DefTensor[TetraName[-i1,-i2,-i3,-i4],deps,GenSet[xAct`xPerm`Cycles[{1,2},{3,4}],xAct`xPerm`Cycles[{1,3},{2,4}]],
Dagger->Complex,
PrintAs:>GiveOutputString[Tetra,metric],
Master->metric,
ProtectNewSymbol->False,
DefInfo:>If[info===False,False,{"tetrametric",""}]
];
TetraRule[metric]^:=MakeRule[{TetraName[i1,i2,i3,i4],I/2epsilonOrientation[metric,AIndex]epsilonname[i1,i2,i3,i4]+metric[i1,i4]metric[i2,i3]/2-metric[i1,i3]metric[i2,i4]/2+metric[i1,i2]metric[i3,i4]/2},Evaluate->True];
With[{TetraNamedag=Dagger[TetraName]},
TetraNamedag[i1_,i2_,i3_,i4_]:=TetraName[i1,i4,i3,i2]
]
];
If[$ProtectNewSymbols,Protect[TetraName,Evaluate[Dagger@TetraName]]]
]
];

If[$ProtectNewSymbols,Protect[epsilonname]]
];

(* Self-contractions. Transformation to delta or metric for A-indices contraction of two metrics (this could be generalized). Projectors not automatically converted into delta *)
If[frozenQ,
(*********************************************************************************************************************************************)
(****** xBrauer MODIFICATION : If metric is frozen metric with mixed indices is also passed to delta *****)
(**********************************************************************************************************************************************)
metric/:metric[a_?UpIndexQ,b_?DownIndexQ]:=delta[b,a];
metric/:metric[a_?DownIndexQ,b_?UpIndexQ]:=delta[a,b];
invmetric/:invmetric[a_?UpIndexQ,-b_Symbol]:=delta[-b,a];
invmetric/:invmetric[-a_Symbol,b_?UpIndexQ]:=delta[-a,b];
invmetric/:metric[a_,-b_?vbQ]invmetric[b_?EIndexQ,c_]:=metric[a,c];
invmetric/:metric[-b_?vbQ,a_]invmetric[b_?EIndexQ,c_]:=metric[a,c];
invmetric/:metric[a_,-b_?vbQ]invmetric[c_,b_?EIndexQ]:=metric[a,c];
invmetric/:metric[-b_?vbQ,a_]invmetric[c_,b_?EIndexQ]:=metric[a,c];
invmetric/:metric[a_,b_?vbQ]invmetric[-b_?EIndexQ,c_]:=metric[a,c];
invmetric/:metric[b_?vbQ,a_]invmetric[-b_?EIndexQ,c_]:=metric[a,c];
invmetric/:metric[a_,b_?vbQ]invmetric[c_,-b_?EIndexQ]:=metric[a,c];
invmetric/:metric[b_?vbQ,a_]invmetric[c_,-b_?EIndexQ]:=metric[a,c],
Inv[metric]^=metric;
If[inducedQ,
metric[a_?vbQ,-a_?EIndexQ]:=dim-1;
metric[-a_?vbQ,a_?EIndexQ]:=dim-1
];
If[firstQ,
metric[a_?UpIndexQ,b_?DownIndexQ]:=delta[b,a];
metric[a_?DownIndexQ,b_?UpIndexQ]:=delta[a,b]
];
HoldPattern[metric[a_,b_?vbQ]metric[-b_?EIndexQ,c_]]^:=metric[a,c];
HoldPattern[metric[a_,b_?vbQ]metric[c_,-b_?EIndexQ]]^:=metric[a,c];
HoldPattern[metric[b_?vbQ,a_]metric[-b_?EIndexQ,c_]]^:=metric[a,c];
HoldPattern[metric[b_?vbQ,a_]metric[c_,-b_?EIndexQ]]^:=metric[a,c];
];

(* Define covariant derivative(s). Do not protect symbol *)
If[flatPD,
(* Flat metric with PD. Derivative already defined *)
Print["** DefMetric: Associating fiducial flat derivative PD to metric."];
Unprotect[PD];
MetricOfCovD[PD]^=metric;
PD[c_][metric[a_?vbpmQ,b_?vbpmQ]]^=0;
metric/:TensorDerivative[metric,PD]:=Zero;
If[!frozenQ,
(* Place rule for this metric second, after the general rule for lower indices *)
AppendTo[$SortPDsRules,PD[b_?vbpmQ][PD[a_?vbpmQ][expr1_]]:>PD[a][PD[b][expr1]]/;DisorderedPairQ[a,b]]
],
(* Other cases. Define derivative. For a frozen metric the associated tensors are wrong! TODO *)
If[frozenQ,
DefCovDFrozen[covd[-ind1],covdsymbol,
FromMetric->metric,
Curvature:>Not[flat],
OtherDependencies->odeps,
OrthogonalTo:>If[inducedQ,{vector[ind1]},{}],
ProjectedWith:>If[inducedQ,{metric[ind1,-ind2]},{}],
Master->metric,
ProtectNewSymbol->False,
DeleteCases[{options},_[PrintAs,_]]
],
DefCovD[covd[-ind1],covdsymbol,
FromMetric->metric,
Curvature:>Not[flat],
OtherDependencies->odeps,
OrthogonalTo:>If[inducedQ,{vector[ind1]},{}],
ProjectedWith:>If[inducedQ,{metric[ind1,-ind2]},{}],
Master->metric,
ProtectNewSymbol->False,
DeleteCases[{options},_[PrintAs,_]]
]
]];
InducedCovDQ[covd]=inducedQ;
(* Torsion. TODO: modify the covdsymbol in the LCmetric *)
LCmetric=If[TorsionQ[covd],LC[metric],covd];
If[!CovDQ[LCmetric],
DefCovD[LCmetric[-ind1],covdsymbol,
FromMetric->metric,
Torsion->False,
Curvature->True,
OtherDependencies->odeps,
OrthogonalTo:>If[inducedQ,{vector[ind1]},{}],
ProjectedWith:>If[inducedQ,{metric[ind1,-ind2]},{}],
Master->metric,
ProtectNewSymbol->False,
DeleteCases[{options},_[PrintAs,_]]
]
];
metric/:CovDOfMetric[metric,Torsion[covd]]=covd;
metric/:CovDOfMetric[metric,Torsion[LCmetric]]=LCmetric;
metric/:CovDOfMetric[metric,Zero]=LCmetric;
metric/:LC[metric]=LCmetric;

If[flatPD,Protect[PD]];
If[$ProtectNewSymbols,Protect[covd]];

(* Derivatives of the metric are defined in DefCovD *)
(* Other covariant derivatives on the metric with upstairs abstract indices *)
If[!inducedQ,
invmetric/:HoldPattern[der_?FirstDerQ[invmetric[b_?vbQ,c_?vbQ]]]:=Module[{b1=DummyIn[vbundle],c1=DummyIn[vbundle]},-invmetric[b,b1]invmetric[c,c1]der[metric[-b1,-c1]]]];
(* There is no simple generalization for induced metrics.
QUESTION: Is there an equivalent rule for the epsilon tensor?*)

(* Determinant in the basis AIndex. Has to be defined after the covd and the invmetric *)
If[info===False,
Block[{$DefInfoQ=False},Determinant[metric,AIndex][]],
Determinant[metric,AIndex][]
];

(* Define induced metric *)
If[inducedQ,xAct`xTensor`Private`DefInducedMetric[metric[-ind1,-ind2],{manifold},covd,{vector,supermetric,CovDOfMetric[supermetric]},flat]];

(* Store conformal relations *)
If[confto=!=Null,
SetConformalTo[metric[-ind1,-ind2],confto]
(*SetConformalToNew[metric,{Head[confto[[1]]],confto[[2]]}]*)
];
(* 
(** xTras extension using xPert to automatically define metric perturbations : not needed because we load xTras **)
If[TrueQ@And[DefMetricPerturbation/.CheckOptions[options]/.Options[DefMetric],!(FlatMetric/.CheckOptions[options]/.Options[DefMetric])],DefMetricPerturbation[metric,GiveSymbol[Perturbation,metric],GiveSymbol[PerturbationParameter,metric]];
PrintAs[Evaluate@GiveSymbol[Perturbation,metric]]^=StringJoin[PrintAs[Evaluate@Perturbation],PrintAs[Evaluate@metric]]];*)

MakexTensions[DefMetric,"End",signdet,metric[-ind1,-ind2],covd,options];

On[OptionValue::nodef];

If[pns,Protect[metric]];
]
]
];
DefMetric[_,metric_,_,OptionsPattern[]]:=Message[DefMetric::invalid,metric,"metric"];
SetNumberOfArguments[DefMetric,{3,Infinity}];
Protect[DefMetric];
On[RuleDelayed::rhs];


(* ::Input::Initialization:: *)
DefCovDFrozen[covd_[ind_],symbol:{_String,_String},options___]:=DefCovDFrozen[covd[ind],VBundleOfIndex[ind],SymbolOfCovD->symbol,options];
DefCovDFrozen[covd_[ind_],vbundles_,symbol:{_String,_String},options___]:=DefCovDFrozen[covd[ind],vbundles,SymbolOfCovD->symbol,options];
DefCovDFrozen[covd_[ind_],options___?OptionQ]:=DefCovDFrozen[covd[ind],VBundleOfIndex[ind],options];


(* ::Input::Initialization:: *)
Options[DefCovDFrozen]={
SymbolOfCovD->{";","\[EmptyDownTriangle]"},
Torsion->False,
Curvature->True,
FromMetric->Null,
CurvatureRelations->True,
ExtendedFrom->Null,
OtherDependencies->{},
OrthogonalTo->{},
ProjectedWith->{},
WeightedWithBasis->Null,
ProtectNewSymbol:>$ProtectNewSymbols,
Master->Null,
DefInfo->{"covariant derivative",""}};
DefCovDFrozen[covd_[ind_],vbundles_,options:OptionsPattern[]]:=
Catch@(If[Not[AIndexQ[ind]&&DownIndexQ[ind]],Throw[Message[DefCovD::invalid,"covariant abstract-index",ind]]];
With[{tbundle=VBundleOfIndex[ind],manifold=BaseOfVBundle@VBundleOfIndex[ind]},
Module[{allbundles,symbol,torsion,curvature,metric,curvrels,ef,odeps,wwb,pns,master,info,ot,pw,curvedbundles},

(* Options *)
{symbol,torsion,curvature,metric,curvrels,ot,pw,ef,odeps,wwb,pns,master,info}=OptionValue[{SymbolOfCovD,Torsion,Curvature,FromMetric,CurvatureRelations,OrthogonalTo,ProjectedWith,ExtendedFrom,OtherDependencies,WeightedWithBasis,ProtectNewSymbol,Master,DefInfo}];
ot=Flatten[{ot},1];
pw=Flatten[{pw},1];

(* Checks *)
allbundles=DeleteDuplicates@Flatten[{tbundle,vbundles,Dagger/@{vbundles}}];
curvedbundles=xAct`xTensor`Private`DefCovDCheck[covd,manifold,allbundles,symbol,{torsion,curvature,metric,curvrels,ef,odeps,wwb}];

(* Register *)
xAct`xTensor`Private`MakeDefInfo[DefCovD,covd[ind],info];
CovDQ[covd]^=True;
AppendToUnevaluated[$CovDs,covd];
SymbolOfCovD[covd]^=symbol;
ManifoldOfCovD[covd]^=manifold;
VBundlesOfCovD[covd]^=allbundles;
DependenciesOfCovD[covd]^=xAct`xTensor`Private`SortDependencies@Join[{manifold},odeps];
TorsionQ[covd]^=torsion;
TagSet[covd,CurvatureQ[covd,#],True]&/@curvedbundles;
TagSet[covd,CurvatureQ[covd,#],False]&/@Complement[allbundles,curvedbundles];
MetricOfCovD[covd]^=metric;
WeightedWithBasis[covd]^=wwb;
MasterOf[covd]^=metric;
xAct`xTensor`Private`SymbolRelations[covd,master,If[ef===Null,{manifold},{manifold,ef}]];
DefInfo[covd]^=info;

(**** Define derivative operator ****)
xAct`xTensor`Private`MakeLinearDerivative[covd,ot==={}];
xAct`xTensor`Private`MakeTensorialDerivative[covd];
If[ot=!={},xAct`xTensor`Private`MakeOrthogonalDerivative[covd,First[pw],First[ot]]];
If[pw=!={},xAct`xTensor`Private`MakeProjectedDerivative[covd,First[pw],First[ot]]];

(* Define curvature tensors and other properties *)
If[info=!=False,info=$DefInfoQ];
defcovdTangentFrozen[covd,tbundle,{torsion,CurvatureQ[covd,tbundle],metric,curvrels},{ot,pw,info}];

If[pns,Protect[covd]];
]
]);


(* ::Input::Initialization:: *)
defcovdTangentFrozen[covd_,tbundle_,{torQ_,curvQ_,metric_,curvrels_},{ov_,pw_,info_}]:=With[
(* Reinterpretation of input *)
{indexlist=GetIndicesOfVBundle[tbundle,9],
dim=If[pw==={},DimOfVBundle[tbundle],DimOfVBundle[tbundle]-1],
metricQ=(metric=!=Null),
orthogonalQ=(ov=!={}),
projectedQ=(pw=!={}),
endowedQ=MetricEndowedQ[tbundle],
frozenQ=If[metric=!=Null,FrozenMetricQ[metric],False]},
With[
(* Secondary definitions *)
{tbQ=xAct`xTensor`Private`VBundleIndexQ[tbundle],
tbpmQ=xAct`xTensor`Private`VBundleIndexPMQ[tbundle],
invmetric=If[metricQ,If[frozenQ,GiveSymbol[Inv,metric],metric],False],
TorsionName=GiveSymbol[Torsion,covd],
ChristoffelName=GiveSymbol[Christoffel,covd],
RiemannName=GiveSymbol[Riemann,covd],
RiemannDownName=If[metricQ,GiveSymbol[If[frozenQ,RiemannDown,Riemann],covd],$Failed],
RicciName=GiveSymbol[Ricci,covd],
WeylName=If[metricQ,GiveSymbol[Weyl,covd]],
TFRicciName=If[metricQ,GiveSymbol[TFRicci,covd]],
EinsteinName=If[metricQ,GiveSymbol[Einstein,covd]],
RicciScalarName=If[metricQ,GiveSymbol[RicciScalar,covd]],
KretschmannName=If[metricQ,GiveSymbol[Kretschmann,covd]],
i1=indexlist[[1]],
i2=indexlist[[2]],
i3=indexlist[[3]],
i4=indexlist[[4]],
i5=indexlist[[5]],
i1d=indexlist[[6]],
i2d=indexlist[[7]],
i3d=indexlist[[8]],
i4d=indexlist[[9]],
integerdimQ=IntegerQ[dim]},
Module[{prot,vector,projector,tmp,vanishQ},
(* 0. Check orthogonality and projections *)
If[!endowedQ&&(projectedQ||orthogonalQ),Throw@Message[DefCovD::error,"xTensor cannot yet project in a vector bundle without metric."]];

If[orthogonalQ,vector=ov[[1,0]]];
If[projectedQ,projector=pw[[1,0]]];
(* 1. Define torsion tensor *)
vanishQ=!torQ;
DefTensor[TorsionName[i1,-i2,-i3],DependenciesOfCovD[covd],Antisymmetric[{2,3}],
PrintAs:>GiveOutputString[Torsion,covd],
VanishingQ->vanishQ,
Master->covd,
OrthogonalTo:>If[orthogonalQ,{vector[-i1],vector[i2],vector[i3]},{}],
ProjectedWith:>If[projectedQ,{projector[-i1,i1d],projector[i2,-i2d],projector[i3,-i3d]},{}],
DefInfo:>If[info,{"torsion tensor",""},False],
TensorID->{Torsion,covd}];

(* 2. Define Christoffel tensor relating covd to PD. Always nonzero *)
DefTensor[ChristoffelName[i1,-i2,-i3],DependenciesOfCovD[covd],If[torQ,StrongGenSet[{},GenSet[]],Symmetric[{2,3}]],
PrintAs:>GiveOutputString[Christoffel,covd],
Master->covd,
OrthogonalTo:>If[orthogonalQ,{vector[-i1],vector[i2],vector[i3]},{}],
ProjectedWith:>If[projectedQ,{projector[-i1,i1d],projector[i2,-i2d],projector[i3,-i3d]},{}],
DefInfo:>If[info,{If[torQ,"non-symmetric ","symmetric "]<>"Christoffel tensor",""},False],
TensorID->{Christoffel,covd,PD}];
AppendTo[xAct`xTensor`Private`$Christoffels,{ChristoffelName,{Christoffel,covd,PD},{tbundle}}];

(* 3. Automatic commutativity of scalars, even if there is torsion. Only for covariant derivatives with abstract indices *)
(* CovDTODO *)
covd[-b_?tbQ][covd[-a_?tbQ][scalar_?xTensorQ[]]]:=covd[-a][covd[-b][scalar[]]]+$TorsionSign Module[{dummy=DummyIn[tbundle]},TorsionName[dummy,-a,-b]covd[-dummy][scalar[]]]/;$CommuteCovDsOnScalars&&DisorderedPairQ[a,b];
(** 3.b : Composition **)
covd[a_]@(f_?ScalarFunctionQ[args___]):=xAct`xTensor`Private`multiD[covd[a],f[args]];

(* 4. Metric compatibility *)
(* CovDTODO *)
If[metricQ,
If[frozenQ,
covd[a_][invmetric[b_Symbol?tbQ,c_Symbol?tbQ]]:=0;
covd[a_][metric[-b_Symbol?tbQ,-c_Symbol?tbQ]]:=0;
covd[a_][metric[b_Symbol?tbQ,c_Symbol?tbQ]]:=0;
covd/:TensorDerivative[invmetric,covd,___]:=Zero;
covd/:TensorDerivative[metric,covd,___]:=Zero,
covd[a_][metric[b_?tbpmQ,c_?tbpmQ]]:=0;
covd/:TensorDerivative[metric,covd,___]:=Zero
]
];

(* 5. Only if there is a metric and no torsion the RiemannDown tensor has its full symmetries : Why do we need to define RiemannDown ??? *)
vanishQ=!curvQ||If[integerdimQ,dim<2,False];
If[metricQ,
DefTensor[RiemannDownName[-i1,-i2,-i3,-i4],DependenciesOfCovD[covd],If[torQ,JoinSGS[Antisymmetric[{1,2}],Antisymmetric[{3,4}]],RiemannSymmetric[{1,2,3,4}]],
PrintAs:>GiveOutputString[If[frozenQ,RiemannDown,Riemann],covd],
VanishingQ->vanishQ,
Master->covd,
OrthogonalTo:>If[orthogonalQ,{vector[i1],vector[i2],vector[i3],vector[i4]},{}],
ProjectedWith:>If[projectedQ,{projector[i1,-i1d],projector[i2,-i2d],projector[i3,-i3d],projector[i4,-i4d]},{}],
DefInfo:>If[info,{"Riemann tensor",If[torQ,"Antisymmetric pairs cannot be exchanged.",""]},False],
TensorID->{Riemann,covd}]];
If[metricQ&&frozenQ,
DefTensor[RiemannName[-i1,-i2,-i3,i4],DependenciesOfCovD[covd],If[torQ,JoinSGS[Antisymmetric[{1,2}],Antisymmetric[{3,4}]],RiemannSymmetric[{1,2,3,4}]],ForceSymmetries->True,
PrintAs:>GiveOutputString[Riemann,covd],
VanishingQ->vanishQ,
Master->covd,
OrthogonalTo:>If[orthogonalQ,{vector[i1],vector[i2],vector[i3],vector[-i4]},{}],
ProjectedWith:>If[projectedQ,{projector[i1,-i1d],projector[i2,-i2d],projector[i3,-i3d],projector[-i4,i4d]},{}],
DefInfo:>If[info,{"Riemann tensor",If[curvQ,"Antisymmetric only in the first pair.",""]},False],
TensorID->{Riemann,covd}];
RiemannName/:RiemannName[i1_,i2_,-i3_,i3_]:=0;
RiemannName/:RiemannName[i1_,i2_,i3_,-i3_]:=0;
];

(* 6. Only if there is a metric and no torsion the Ricci tensor is symmetric; we use MakeRule without restrictions *)
vanishQ=!curvQ||If[integerdimQ,dim<2,False];
DefTensor[RicciName[-i1,-i2],DependenciesOfCovD[covd],If[metricQ&&!torQ,Symmetric[{1,2}],StrongGenSet[{},GenSet[]]],
PrintAs:>GiveOutputString[Ricci,covd],
VanishingQ->vanishQ,
Master->covd,
OrthogonalTo:>If[orthogonalQ,{vector[i1],vector[i2]},{}],
ProjectedWith:>If[projectedQ,{projector[i1,-i1d],projector[i2,-i2d]},{}],
DefInfo:>If[info,{If[vanishQ,"",If[metricQ&&!torQ,"symmetric ","non-symmetric "]]<>"Ricci tensor",""},False],
TensorID->{Ricci,covd}];
If[!vanishQ,
covd/:CurvatureRelations[covd,Riemann]=MakeRule[{RiemannName[-i1,-i2,-i3,i2],$RicciSign RicciName[-i1,-i3]},MetricOn->All,UseSymmetries->True,ContractMetrics->True];
If[curvrels,
If[info,Print["** DefCovD:  Contractions of Riemann automatically replaced by Ricci."]];
prot=Unprotect[RiemannName];
AutomaticRules[RiemannName,CurvatureRelations[covd,Riemann],Verbose->False];
Protect[Evaluate[prot]];
]
];

(* 7. The Ricci scalar ; we use MakeRule without restrictions  *)
If[metricQ,
vanishQ=!curvQ||If[integerdimQ,dim<2,False];
DefTensor[RicciScalarName[],DependenciesOfCovD[covd],
PrintAs:>GiveOutputString[Ricci,covd],
VanishingQ->vanishQ,
Master->covd,
DefInfo:>If[info,{"Ricci scalar",""},False],
TensorID->{RicciScalar,covd}];
If[!vanishQ,
covd/:CurvatureRelations[covd,Ricci]=Join[MakeRule[{invmetric[i1,i2]RicciName[-i1,-i2],RicciScalarName[]}],MakeRule[{RicciName[-i1,i1],RicciScalarName[]}]];
If[curvrels,
If[info,Print["** DefCovD:  Contractions of Ricci automatically replaced by RicciScalar."]];
prot=Unprotect[RicciName];
AutomaticRules[RicciName,CurvatureRelations[covd,Ricci],Verbose->False];
Protect[Evaluate[prot]];
]
]
];
(* 8. The Einstein tensor ; we use MakeRule without restrictions   *)
If[metricQ,
vanishQ=!curvQ||If[integerdimQ,dim<3,False];
DefTensor[EinsteinName[-i1,-i2],DependenciesOfCovD[covd],If[torQ,StrongGenSet[{},GenSet[]],Symmetric[{1,2}]],
PrintAs:>GiveOutputString[Einstein,covd],
VanishingQ->vanishQ,
Master->covd,
OrthogonalTo:>If[orthogonalQ,{vector[i1],vector[i2]},{}],
ProjectedWith:>If[projectedQ,{projector[i1,-i1d],projector[i2,-i2d]},{}],
DefInfo:>If[info,{If[vanishQ,"",If[torQ,"non-symmetric ","symmetric "]]<>"Einstein tensor",""},False],
TensorID->{Einstein,covd}];
If[!vanishQ,
prot=Unprotect[invmetric];
AutomaticRules[invmetric,MakeRule[{invmetric[i2,i3]covd[-i3][EinsteinName[-i1,-i2]],$TorsionSign invmetric[i2,i3]RicciName[-i4,-i2]TorsionName[i4,-i1,-i3]-$TorsionSign $RicciSign/2 invmetric[i2,i3]RiemannName[-i1,-i4,-i2,i5]TorsionName[i4,-i3,-i5]}],Verbose->False];
Protect[Evaluate[prot]];
]
];
(* 9. We define the Weyl tensor : here the Weyl tensor is defined with the last index up *)
If[metricQ,
(* Weyl *)
vanishQ=!curvQ||If[integerdimQ,dim<4,False];
DefTensor[WeylName[-i1,-i2,-i3,i4],DependenciesOfCovD[covd],If[torQ,JoinSGS[Antisymmetric[{1,2}],Antisymmetric[{3,4}]],RiemannSymmetric[{1,2,3,4}]],ForceSymmetries->True,TraceFree->{-i1,-i2,-i3,i4},
PrintAs:>GiveOutputString[Weyl,covd],
VanishingQ->vanishQ,
Master->covd,
OrthogonalTo:>If[orthogonalQ,{vector[i1],vector[i2],vector[i3],vector[-i4]},{}],
ProjectedWith:>If[projectedQ,{projector[i1,-i1d],projector[i2,-i2d],projector[i3,-i3d],projector[-i4,i4d]},{}],
DefInfo:>If[info,{"Weyl tensor",If[torQ,"Antisymmetric pairs cannot be exchanged.",""]},False],
TensorID->{Weyl,covd}]
];
(* 10. TFRicci for metric connections, even with torsion *)
If[metricQ,
vanishQ=!curvQ||If[integerdimQ,dim<3,False];
DefTensor[TFRicciName[-i1,-i2],DependenciesOfCovD[covd],If[torQ,StrongGenSet[{},GenSet[]],Symmetric[{1,2}]],TraceFree->{-i1,-i2},
PrintAs:>GiveOutputString[TFRicci,covd],
VanishingQ->vanishQ,
Master->covd,
OrthogonalTo:>If[orthogonalQ,{vector[i1],vector[i2]},{}],
ProjectedWith:>If[projectedQ,{projector[i1,-i1d],projector[i2,-i2d]},{}],
DefInfo:>If[info,{If[vanishQ,"",If[torQ,"non-symmetric ","symmetric "]]<>"TFRicci tensor",""},False],
TensorID->{TFRicci,covd}];
];
(* 10b. Kretschmann for metric connections, even with torsion *)
If[metricQ,
vanishQ=!curvQ;
DefTensor[KretschmannName[],DependenciesOfCovD[covd],
PrintAs:>GiveOutputString[Kretschmann,covd],
VanishingQ->vanishQ,
Master->covd,
DefInfo:>If[info,{"Kretschmann scalar",""},False],
TensorID->{Kretschmann,covd}];
];

(* 11. Riemann versus Weyl ( we use xBrauer functions TracelessProject and TraceProject : problem with $RicciSign ? ) *)
 xAct`xTensor`Private`RiemannToWeylRules[covd]=If[curvQ&&metricQ&&If[integerdimQ,dim>1,True],If[info,Print["** DefCovD:  Computing RiemannToWeylRules for dim ",dim]];
Which[
dim===2,
SafeMakeRule[{RiemannName[-i1,-i2,-i3,i4],$RicciSign RicciScalarName[](metric[-i1,-i3]delta[-i2,i4]-delta[-i1,i4]metric[-i2,-i3])/2}],
dim===3,SafeMakeRule[{RiemannName[-i1,-i2,-i3,i4],$RicciSign (metric[-i1,-i3]invmetric[i4,i5]RicciName[-i2,-i5]+delta[-i2,i4]RicciName[-i1,-i3]-delta[-i1,i4]RicciName[-i2,-i3]-metric[-i2,-i3]invmetric[i4,i5]RicciName[-i1,-i5])/(dim-2)-$RicciSign RicciScalarName[](metric[-i1,-i3]delta[-i2,i4]-delta[-i1,i4]metric[-i2,-i3])/(dim-1)/(dim-2)}],
True,
SafeToRule[RiemannName[-i1,-i2,-i3,i4]==Collect[WeylName[-i1,-i2,-i3,i4]+
										TracelessProject[RiemannName[-i1,-i2,-i3,i4],2,metric]+TraceProject[RiemannName[-i1,-i2,-i3,i4],metric],{_metric,_invmetric,_delta,_WeylName,_RicciName,_ RicciScalarName},Factor]]
],
{}];
 xAct`xTensor`Private`WeylToRiemannRules[covd]=If[If[integerdimQ,dim>=4,True]&&metricQ&&curvQ,SafeToRule[WeylName[-i1,-i2,-i3,i4]==Collect[TracelessProject[RiemannName[-i1,-i2,-i3,i4],1,metric],{_metric,_invmetric,_delta,_RiemannName,_RicciName,_RicciScalarName},Factor]],
{}];
(** We leave these Rules but i don't know what are there purposes **)
 xAct`xTensor`Private`RiemannToRiemannDownRules[covd]=If[metricQ&&frozenQ&&curvQ,MakeRule[{RiemannName[i1,i2,i3,i4],RiemannDownName[i1,i2,i3,-i1d]invmetric[i1d,i4]},MetricOn->All,TestIndices->False,ContractMetrics->True],
{}];
 xAct`xTensor`Private`RiemannDownToRiemannRules[covd]=If[metricQ&&curvQ,MakeRule[{RiemannDownName[i1,i2,i3,i4],RiemannName[i1,i2,i3,i1d]metric[-i1d,i4]},MetricOn->All,TestIndices->False,ContractMetrics->True],
{}];
(* 12. Ricci versus TFRicci. QUESTION: Are dimensions right when orthogonalQ or projectedQ? *)
 xAct`xTensor`Private`RicciToTFRicciRules[covd]=If[curvQ&&metricQ&&If[integerdimQ,dim>1,True],If[info,Print["** DefCovD:  Computing RicciToTFRicci for dim ",dim]];
Which[
dim===2,
SafeMakeRule[{RicciName[-i1,-i2],RicciScalarName[]metric[-i1,-i2]/2}],True,
SafeToRule[RicciName[-i1,-i2]==(TFRicciName[-i1,-i2]+TraceProject[RicciName[-i1,-i2],metric])]
],
{}];
 xAct`xTensor`Private`TFRicciToRicciRules[covd]=If[If[integerdimQ,dim>=3,True]&&metricQ&&curvQ,
SafeToRule[TFRicciName[-i1,-i2]==(TracelessProject[TFRicciName[-i1,-i2],1,metric])],
{}];

(* 13. Ricci versus Einstein *)
xAct`xTensor`Private`RicciToEinsteinRules[covd]=
If[curvQ&&metricQ&&If[integerdimQ,dim>1,True],
If[info,Print["** DefCovD:  Computing RicciToEinsteinRules for dim ",dim]];
Which[
dim===2,
SafeMakeRule[{RicciName[-i1,-i2],metric[-i1,-i2]/2RicciScalarName[]},MetricOn->All,TestIndices->False,ContractMetrics->True],
True,
SafeMakeRule[{RicciName[-i1,-i2],EinsteinName[-i1,-i2]+metric[-i1,-i2]/2RicciScalarName[]},MetricOn->All,TestIndices->False,ContractMetrics->True]
],
{}];
xAct`xTensor`Private`EinsteinToRicciRules[covd]=If[If[integerdimQ,dim>=3,True]&&metricQ&&curvQ,SafeMakeRule[{EinsteinName[-i1,-i2],RicciName[-i1,-i2]-metric[-i1,-i2]/2*RicciScalarName[]}],{}];
]
]
]


(* ::Input::Initialization:: *)
Bimetric::nomet="There is no metric associated to `1`.";


(* ::Input::Initialization:: *)
InducedMetricQ[metric_?MetricQ]:=If[InducedFrom[metric]===Null,False,True];


(* ::Input::Initialization:: *)
(*** Correction of a small bug when we separate metric of an expression with covariant derivative and frozen metric : need to delete duplicate indices ***)
SeparateMetric[metric_,basis_][expr_,list_IndexList]:=Fold[SeparateMetric[metric,basis],expr,DeleteDuplicates[DeleteCases[list,_LI|-_LI]]];

(***************************************)
(*** Modification of SeparateMetric1 ***)
(***************************************)

(*** For induced metric ****)
xAct`xTensor`Private`SeparateMetric1[basis_,metric_,metric1_][expr_,index_]=.;
xAct`xTensor`Private`SeparateMetric1[basis_,metric_?InducedMetricQ,metric1_][expr_,index_]:=xAct`xTensor`Private`SeparateMetric2[basis,metric][expr,index]/;VBundleOfMetric[metric]===VBundleOfIndex[index];
(*** We add the definition for frozen metric which has recently been removed from xTensor ***)
xAct`xTensor`Private`SeparateMetric1[basis_,frozen_?FrozenMetricQ,metric1_][expr_,index_]:=xAct`xTensor`Private`SeparateMetric2[basis,frozen][expr,index]/;VBundleOfMetric[frozen]===VBundleOfMetric[metric1];

(***************************************)
(*** Modification of SeparateMetric2 ***)
(***************************************)
xAct`xTensor`Private`SeparateMetric2[basis_,metric_][expr_,index_]:=expr/.{tensor_?xTensorQ[i1___,index,i2___]:>With[{dummy=DummyAs[index,basis]},If[(MetricOfTensor[tensor]===metric||(MetricOfTensor[tensor]===Null&&FirstMetricQ[metric])),If[UpIndexQ[index],metric[index,dummy],metric[dummy,index]]tensor[i1,ChangeIndex[dummy],i2],tensor[i1,index,i2]]],covd_?CovDQ[i1___,index,i2___][expr1_]:>With[{dummy=DummyAs[index,basis]},If[MasterOf[covd]===metric,If[UpIndexQ[index],metric[index,dummy],metric[dummy,index]]covd[i1,ChangeIndex[dummy],i2][expr1],covd[i1,index,i2][expr1]]]};

(*** New definition for frozen metric ***)
xAct`xTensor`Private`SeparateMetric2[AIndex,metric_?FrozenMetricQ][metric_?FrozenMetricQ[-i1_Symbol,-i2_Symbol],index_]:=metric[-i1,-i2];
xAct`xTensor`Private`SeparateMetric2[AIndex,metric_?FrozenMetricQ][metric_?FrozenMetricQ[i1_Symbol,i2_Symbol],index_]:=With[{a=DummyAs[i1],b=DummyAs[i2]},
Inv[metric][a,i1]Inv[metric][b,i2]metric[-a,-b]];
xAct`xTensor`Private`SeparateMetric2[AIndex,metric_?FrozenMetricQ][metric_?FrozenMetricQ[-i1_Symbol,-i2_Symbol],index_]:=metric[-i1,-i2];

xAct`xTensor`Private`SeparateMetric2[basis_,metric_?xAct`xTensor`Private`FrozenMetricQ][expr_,index_]:=With[{imetric=Inv[metric]},expr/.{tensor_?xTensorQ[i1___,index,i2___]:>With[{dummy=DummyAs[index,basis]},If[MetricOfTensor[tensor]===metric,If[UpIndexQ[index],imetric[index,dummy],metric[dummy,index]]tensor[i1,ChangeIndex[dummy],i2],tensor[i1,index,i2]]],
covd_?CovDQ[i1___,index,i2___][expr1_]:>With[{dummy=DummyAs[index,basis]},If[MasterOf[covd]===metric,If[UpIndexQ[index],imetric[index,dummy],metric[dummy,index]]covd[i1,ChangeIndex[dummy],i2][expr1],covd[i1,index,i2][expr1]]]}]

(*** Separate Metric with Lie Derivative ***)
SeparateMetric[metric_?MetricQ][LieD[nvec_?xTensorQ[ind_]][tensor_?xTensorQ[inds___]]]:=Module[{septens,tensor1,metriclist},
septens=SeparateMetric[metric][tensor[inds]];
If[septens===tensor[inds],Return[LieD[nvec[ind]][tensor[inds]],Module]];
metriclist=FindAllOfType[septens,Metric];
tensor1=Complement[FindAllOfType[septens,Tensor],metriclist][[1]];
Times@@metriclist*LieD[nvec[ind]][SeparateMetric[metric][tensor1]]+LieD[nvec[ind]][Times@@metriclist]*tensor1];
(*** SeparateMetric driver with option ***)
SeparateMetric[][exp_]:=Fold[SeparateMetric[#2][#1]&,exp,$Metrics];
SeparateMetric[exp_?(!MetricQ[#]&)]:=SeparateMetric[][exp];


(* ::Input::Initialization:: *)
ContractMetric::frozen="Cannot contract frozen metric `1`.";
xAct`xTensor`Private`NormalVectorOf[metric_]:=Which[
InducedFrom[metric]===Null,Null,
InducedFrom[metric]=!=Null,VectorOfInducedMetric[metric]];


(* ::Input::Initialization:: *)
Unprotect[ContractMetric];
ContractMetric[expr_,options___?OptionQ]:=ContractMetric[expr,$Metrics,options];
Protect[ContractMetric];


(* ::Input::Initialization:: *)
(* Contractions inside first-derivatives with inverse metric *)
(CM:xAct`xTensor`Private`ContractMetric1[{od_,aud_},{metric_,nv_}])[rest_. der_?FirstDerQ[expr_]met:invmetric_[b_,c_]]:=
Module[{dm=der[met],result},
If[(od||dm===0)&&xAct`xTensor`Private`differentexpressionsQ[result=CM[expr met],{expr,met}],
CM[rest der[result]]-CM[rest dm expr],
CM[rest met]der[expr]]
]/;(MemberQ[FindFreeIndices[expr],ChangeIndex[c]|ChangeIndex[b]]&&Head[expr]=!=metric&&invmetric===Inv[metric]);


(* ::Input::Initialization:: *)
(* Contraction metric*der[metric] is left untouched to avoid infinite recursion *)
(CM:xAct`xTensor`Private`ContractMetric1[{od_,aud_},{metric_,nv_}])[rest_. der_?FirstDerQ[metric_[a_,b_]]metric_[c_,d_]]=.
(CM:xAct`xTensor`Private`ContractMetric1[{od_,aud_},{metric_,nv_}])[rest_. der_?FirstDerQ[metric_[a_,b_]]metric_[c_,d_]]:=CM[rest metric[c,d]]der[metric[a,b]]/;(PairQ[a,d]||PairQ[b,d]||PairQ[a,c]||PairQ[b,c]);


(* ::Input::Initialization:: *)
(* Contraction of projector on an spatial tensor *)
xAct`xTensor`Private`PRJ[nv_,tensor_?xTensorQ,indumetric_]:=If[MetricOfTensor[tensor]===indumetric,True,OrthogonalToVectorQ[nv][tensor]];
(* Contraction of projector through its Levi-Civita connection *)
xAct`xTensor`Private`PRJ[nv_,covd_?CovDQ,indumetric_]:=If[MasterOf[covd]===indumetric,True,CovDOfMetric[indumetric]===covd];


(* ::Input::Initialization:: *)
(***************************************************************************************************************)	
(************************ We overwrite ContractMetric1 private function of xTensor *****************************)
(***************************************************************************************************************)	
										
(CM:xAct`xTensor`Private`ContractMetric1[{od_,aud_},{metric_,nv_}])[rest_. tensor_?xTensorQ[i1___,a_,i2___]metric_[b_,c_]]=.;
(CM:xAct`xTensor`Private`ContractMetric1[{od_,aud_},{metric_,nv_}])[rest_. covd_?CovDQ[i1___,a_,i2___][expr_]metric_[b_,c_]]=.;
(CM:xAct`xTensor`Private`ContractMetric1[{od_,aud_},{metric_,nv_}])[rest_. prod_?ProductQ[left___,tensor_?xTensorQ[i1___,a_,i2___],right___]metric_[b_,c_]]=.;	

(*** Copy paste from xtensor the code for induced metric ***)

(*** New code for metric and frozen metric ***)

(* Second index of metric *)
(CM:xAct`xTensor`Private`ContractMetric1[{od_,aud_},{metric_,nv_}])[rest_. tensor_?xTensorQ[i1___,a_,i2___]metric_[b_,c_]]:=xAct`xTensor`Private`SMP[metric,c,a]CM[rest tensor[i1,b,i2]]/;PairQ[c,a]&&xAct`xTensor`Private`PRJ[nv,tensor,metric]&&(MetricOfTensor[tensor]===metric||(MetricOfTensor[tensor]===Null&&FirstMetricQ[metric]));

(CM:xAct`xTensor`Private`ContractMetric1[{od_,aud_},{metric_,nv_}])[rest_. covd_?CovDQ[i1___,a_,i2___][expr_]metric_[b_,c_]]:=xAct`xTensor`Private`SMP[metric,c,a]CM[rest covd[i1,b,i2][expr]]/;PairQ[c,a]&&(aud||DownIndexQ[b])&&xAct`xTensor`Private`PRJ[nv,covd,metric]&&(MasterOf[covd]===metric||(MasterOf[covd]===Null&&FirstMetricQ[metric]));

(CM:xAct`xTensor`Private`ContractMetric1[{od_,aud_},{metric_,nv_}])[rest_. prod_?ProductQ[left___,tensor_?xTensorQ[i1___,a_,i2___],right___]metric_[b_,c_]]:=xAct`xTensor`Private`SMP[metric,c,a]CM[rest prod[left,tensor[i1,b,i2],right]]/;PairQ[c,a]&&xAct`xTensor`Private`PRJ[nv,tensor,metric] &&ScalarsOfProduct[prod][metric[b,c]]&&(MetricOfTensor[tensor]===metric||(MetricOfTensor[tensor]===Null&&FirstMetricQ[metric]));

(* First index of metric *)
(CM:xAct`xTensor`Private`ContractMetric1[{od_,aud_},{metric_,nv_}])[rest_. tensor_?xTensorQ[i1___,a_,i2___]metric_[b_,c_]]:=xAct`xTensor`Private`SMP[metric,a,b]CM[rest tensor[i1,c,i2]]/;PairQ[a,b]&&xAct`xTensor`Private`PRJ[nv,tensor,metric]&&(MetricOfTensor[tensor]===metric||(MetricOfTensor[tensor]===Null&&FirstMetricQ[metric]));

(CM:xAct`xTensor`Private`ContractMetric1[{od_,aud_},{metric_,nv_}])[rest_. covd_?CovDQ[i1___,a_,i2___][expr_]metric_[b_,c_]]:=xAct`xTensor`Private`SMP[metric,a,b]CM[rest covd[i1,c,i2][expr]]/;PairQ[a,b]&&(aud||DownIndexQ[c])&&xAct`xTensor`Private`PRJ[nv,covd,metric]&&(MasterOf[covd]===metric||(MasterOf[covd]===Null&&FirstMetricQ[metric]));

(CM:xAct`xTensor`Private`ContractMetric1[{od_,aud_},{metric_,nv_}])[rest_. prod_?ProductQ[left___,tensor_?xTensorQ[i1___,a_,i2___],right___]metric_[b_,c_]]:=xAct`xTensor`Private`SMP[metric,a,b]CM[rest prod[left,tensor[i1,c,i2],right]]/;PairQ[a,b]&&xAct`xTensor`Private`PRJ[nv,tensor,metric] &&ScalarsOfProduct[prod][metric[b,c]&&(MetricOfTensor[tensor]===metric||(MetricOfTensor[tensor]===Null&&FirstMetricQ[metric]))];

(*** Inverse Metric ***)

(* Second index of metric *)
(CM:xAct`xTensor`Private`ContractMetric1[{od_,aud_},{metric_,nv_}])[rest_. tensor_?xTensorQ[i1___,a_,i2___]invmetric_[b_,c_]]:=xAct`xTensor`Private`SMP[invmetric,c,a]CM[rest tensor[i1,b,i2]]/;PairQ[c,a]&&xAct`xTensor`Private`PRJ[nv,tensor,metric]&&invmetric===Inv[metric]&&(MetricOfTensor[tensor]===metric||(MetricOfTensor[tensor]===Null&&FirstMetricQ[metric]));

(CM:xAct`xTensor`Private`ContractMetric1[{od_,aud_},{metric_,nv_}])[rest_. covd_?CovDQ[i1___,a_,i2___][expr_]invmetric_[b_,c_]]:=xAct`xTensor`Private`SMP[invmetric,c,a]CM[rest covd[i1,b,i2][expr]]/;PairQ[c,a]&&(aud||DownIndexQ[b])&&xAct`xTensor`Private`PRJ[nv,covd,metric]&&invmetric===Inv[metric]&&(MasterOf[covd]===metric||(MasterOf[covd]===Null&&FirstMetricQ[metric]));

(CM:xAct`xTensor`Private`ContractMetric1[{od_,aud_},{metric_,nv_}])[rest_. prod_?ProductQ[left___,tensor_?xTensorQ[i1___,a_,i2___],right___]invmetric_[b_,c_]]:=xAct`xTensor`Private`SMP[invmetric,c,a]CM[rest prod[left,tensor[i1,b,i2],right]]/;PairQ[c,a]&&xAct`xTensor`Private`PRJ[nv,tensor,metric] &&ScalarsOfProduct[prod][metric[b,c]]&&invmetric===Inv[metric]&&(MetricOfTensor[tensor]===metric||(MetricOfTensor[tensor]===Null&&FirstMetricQ[metric]));

(* First index of metric *)
(CM:xAct`xTensor`Private`ContractMetric1[{od_,aud_},{metric_,nv_}])[rest_. tensor_?xTensorQ[i1___,a_,i2___]invmetric_[b_,c_]]:=xAct`xTensor`Private`SMP[invmetric,a,b]CM[rest tensor[i1,c,i2]]/;PairQ[a,b]&&xAct`xTensor`Private`PRJ[nv,tensor,metric]&&invmetric===Inv[metric]&&(MetricOfTensor[tensor]===metric||(MetricOfTensor[tensor]===Null&&FirstMetricQ[metric]));

(CM:xAct`xTensor`Private`ContractMetric1[{od_,aud_},{metric_,nv_}])[rest_. covd_?CovDQ[i1___,a_,i2___][expr_]invmetric_[b_,c_]]:=xAct`xTensor`Private`SMP[invmetric,a,b]CM[rest covd[i1,c,i2][expr]]/;PairQ[a,b]&&(aud||DownIndexQ[c])&&invmetric===Inv[metric]&&xAct`xTensor`Private`PRJ[nv,covd,metric]&&(MasterOf[covd]===metric||(MasterOf[covd]===Null&&FirstMetricQ[metric]));

(CM:xAct`xTensor`Private`ContractMetric1[{od_,aud_},{metric_,nv_}])[rest_. prod_?ProductQ[left___,tensor_?xTensorQ[i1___,a_,i2___],right___]invmetric_[b_,c_]]:=xAct`xTensor`Private`SMP[invmetric,a,b]CM[rest prod[left,tensor[i1,c,i2],right]]/;PairQ[a,b]&&xAct`xTensor`Private`PRJ[nv,tensor,metric] &&ScalarsOfProduct[prod][metric[b,c]]&&invmetric===Inv[metric]&&(MetricOfTensor[tensor]===metric||(MetricOfTensor[tensor]===Null&&FirstMetricQ[metric]));


(* ::Input::Initialization:: *)
(****** Ricci Scalar *******)
changeRicciScalar[covd1_,covd2_,metricofcovd1_][]:=Module[{a=DummyIn[TangentBundleOfCovD[covd1]],b=DummyIn[TangentBundleOfCovD[covd1]]},Scalar[Inv[metricofcovd1][a,b]changeRicci[covd1,covd2,HELLO][-a,-b]]];
makeChangeRicciScalarRule[covd2_,Null][covd1_]:={};
makeChangeRicciScalarRule[covd2_,metricofcovd1_][covd1_]:=With[{ricciscalar=RicciScalar[covd1]},HoldPattern[ricciscalar[]]:>changeRicciScalar[covd1,covd2,metricofcovd1][]];


(* ::Input::Initialization:: *)
xAct`xTensor`Private`makeChangeCurvatureRules[covd2_,metrics_][covd1_]:=With[{vbundles=VBundlesOfCovD[covd1]},
Join[
If[CurvatureQ[covd1,First[vbundles]],
Flatten[{
xAct`xTensor`Private`makeChangeRiemannRule[covd2,metrics,Riemann][covd1],
xAct`xTensor`Private`makeChangeRicciRule[covd2,delta][covd1],
xAct`xTensor`Private`makeChangeRicciScalarRule[covd2,MasterOf[covd1]][covd1]}
],{}],
If[Length[vbundles]>1&&CurvatureQ[covd1,Last[vbundles]],Flatten[{xAct`xTensor`Private`makeChangeRiemannRule[covd2,metrics,FRiemann][covd1]}],{}]]]


(* ::Input::Initialization:: *)
Unprotect[ChangeCurvature];
ChangeCurvature[expr_,covd1_Symbol?CurvatureQ,covd2_:PD]:=If[xAct`xTensor`Private`CompatibleCovDsQ[covd1,covd2],ContractMetric[(SeparateMetric[expr])/.xAct`xTensor`Private`makeChangeCurvatureRules[covd2,xAct`xTensor`Private`metricsof[covd1]][covd1]],expr];
Protect[ChangeCurvature];


(* ::Input::Initialization:: *)
xAct`xTensor`Private`changeRuleforfreepmQ[HoldPattern[LHS_Hold->RHS_Hold],index_]:=ReplaceIndex[LHS,index->UpIndex[index]]->With[{dummy=DummyAs[index]},xAct`xTensor`Private`putmetric[ReplaceIndex[RHS,index->dummy],metricOf[Sequence@@LHS],{UpIndex[index],-dummy}]];


(* ::Input::Initialization:: *)
Unprotect[SetProjected]
SetProjected[tensor_?xTensorQ[inds__],projector_?xTensorQ]=.;
SetProjected[tensor_?xTensorQ[inds__],projector_?xTensorQ[i1_,i2_]]=.;
Proctect[SetProjected]


(* ::Input::Initialization:: *)
xTension["xBrauer`xTensor`",DefTensor,"End"]:=xBrauerxTensorDefTensor;


(* ::Input::Initialization:: *)
xBrauerxTensorDefTensor[head_[indices___],dependencies_,sym_,options___]:=With[{pw=ProjectedWith/. CheckOptions[options] /. Options[DefTensor],
	ov=OrthogonalTo/. CheckOptions[options] /. Options[DefTensor]},
If[pw=!={}&&Equal@@(Head/@pw)&&MasterOf[head]===Null,MasterOf[head]^:=Evaluate[Head[pw[[1]]]]]
If[SymplecticFormQ[MasterOf[head]],
head/:head[i___ ,i1_Symbol,j___,-i1_Symbol,k___]:=-head[i ,-i1,j,i1,k]
]
];


(* ::Input::Initialization:: *)
xTension["xBrauer`xPert`",DefMetricPerturbation,"End"]:=xBrauerxPertDefMetricPerturbation;


(* ::Input::Initialization:: *)
xBrauerxPertDefMetricPerturbation[metric_,pert_,param_,options___?OptionQ]:=If[InducedMetricQ[metric],MasterOf[pert]^=metric;OrthogonalToVectorQ[InducedFrom[metric][[2]]][pert]^=True,MasterOf[pert]^=metric];


(* ::Input::Initialization:: *)
xAct`xTras`Private`DefMetricVariation[metric_?MetricQ,per_,param_]:=Module[{var,M,vb,a,b,c,d,normalvector},
vb=VBundleOfMetric@metric;
M=BaseOfVBundle@vb;
{a,b,c,d}=GetIndicesOfVBundle[vb,4];
If[Perturbation[metric[-a,-b]]=!=per[LI[1],-a,-b],Throw@Message[DefMetricPerturbation::error,"Metric perturbation does not match or is not defined."]];
Block[{$DefInfoQ=False},
If[InducedMetricQ[metric],
normalvector=InducedFrom[metric][[2]];
(****** We set Perturbation of Projected tensors as projected quantities : dangerous ??? ***)
OrthogonalToVectorQ[normalvector][Perturbation[tensor_?(OrthogonalToVectorQ[normalvector][#]&)[inds___]]]^=True;
DefTensor[var[-a,-b],M,Symmetric[{-a,-b}],OrthogonalTo->{normalvector[a],normalvector[b]},ProjectedWith->{metric[a,-c],metric[b,-d]},Master->metric],
DefTensor[var[-a,-b],M,Symmetric[{-a,-b}],Master->metric]]
];
With[{cd=CovDOfMetric[metric],sqrt=Sqrt[SignDetOfMetric[metric] *Determinant[metric][]]},
(*We can now define a total variation (w.r.t.to metric) as follows.Note that we're only varying the metric and hence set variations of any other tensors to zero.*)VarDt[metric,expr_]:=Module[{mod},mod=MapIfPlus[ContractMetric,Expand@Perturbation[expr]];
ExpandPerturbation@SameDummies@mod/.{per[LI[1],inds__]:>var[inds],p:(tensor_[LI[1],___])/;(xTensorQ[tensor]&&tensor=!=per&&PerturbationOrder[p]===1)->0}];
(*The functional derivation is then defined as...*)
VarD[metric[-i1_Symbol,-i2_Symbol],cd][expr_]:=Module[{mod,withvar,novar},mod=Expand@VarDt[metric,expr];
novar=mod/.var[__]->0;
withvar=mod-novar;
ContractMetric[VarD[var[-i1,-i2],cd][withvar]]];
VarD[metric[+i1_Symbol,+i2_Symbol],cd][expr_]:=Module[{mod,withvar,novar},mod=Expand@VarDt[metric,expr];
novar=mod/.var[__]->0;
withvar=mod-novar;
-VarD[var[i1,i2],cd][withvar]];
(*And finally one handy function that varies Lagrangians,and thus takes care of the square root of the determinant.*)VarL[metric[inds__]][L_]:=VarL[metric[inds],cd][L];
VarL[metric[inds__],cd][L_]:=VarD[metric[inds],cd][L]+ReplaceDummies[L] VarD[metric[inds],cd][sqrt]/sqrt
]
];


(* ::Input::Initialization:: *)
VarD[tensor_[inds1___],der_][tensor_?xTensorQ[inds2___],rest_]=.


(* ::Input::Initialization:: *)
(*** One need to be careful with induced metric : it may need to be improved ***)
VarD[tensor_[inds1___],der_][tensor_?xTensorQ[inds2___],rest_]:=With[{clist=ChangeIndex/@IndexList[inds1],metric=MetricOfTensor[tensor]},
ToCanonical[ImposeSymmetry[Inner[metric,clist,IndexList[inds2],Times],clist,SymmetryGroupOfTensor[tensor[inds1]]]rest,UseMetricOnVBundle->None]];


(* ::Input::Initialization:: *)
End[];
Protect@@Names["xAct`xBrauer`*"]
Unprotect[$SymplecticForms]
EndPackage[];
