(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
xAct`SymmetricFunctions`$Version={"1.0.0",{2023,24,02}}


(* ::Input::Initialization:: *)
(* SymmetricFunctions : The Brauer algebra; Traces and permutations *)

(* Copyright (C) 2020 T. Helpin *)

(* This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License,or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

*)


(* ::Input::Initialization:: *)
(* :Title: SymmetricFunctions *)

(* :Author: Thomas Helpin *)

(* :Summary: SymmetricFunctions; *)

(* :Brief Discussion:  *)
  
(* :Context: SymmetricFunctions` *)

(* :Package Version: 0.1.0 *)

(* :Copyright: T.Helpin (2020) *)

(* :History: TODO *)

(* :Keywords: TODO *)

(* :Source: SymmetricFunctions.nb *)

(* :Warning:  *)

(* :Mathematica Version: 8.0 and later *)

(* :Limitations: *)
	
(* :Acknowledgements: *)


(* ::Input::Initialization:: *)
Off[General::nostdvar]
Off[General::nostdopt]
BeginPackage["xAct`SymmetricFunctions`"]


(* ::Input::Initialization:: *)
Print["------------------------------------------------------------"];
Print["xAct`SymmetricFunctions  version ",$Version[[1]],", ",$Version[[2]]];
Print["Copyright (C) 2020-2022, Thomas Helpin, under the General Public License."];


(* ::Input::Initialization:: *)
Off[General::shdw]
SymmetricFunctions`Disclaimer[]:=Print["These are points 11 and 12 of the General Public License:\n\nBECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM `AS IS\.b4 WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\nIN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES."]
On[General::shdw]


(* ::Input::Initialization:: *)
(*Print["These packages come with ABSOLUTELY NO WARRANTY; for details type Disclaimer[]. This is free software, and you are welcome to redistribute it under certain conditions. See the General Public License for details."];*)


BrauerDOIToString[text_,doi_]:="\!\(\*ButtonBox[StyleBox[\""<>text<>"\", \"SR\"],Active->True,BaseStyle->\"Link\",ButtonData->\"http://dx.doi.org/"<>doi<>"\"]\)";
BrauerDocumentationReplacements:= {"<v>" -> "\!\(\*StyleBox[\"" , "</v>" -> "\", \"TI\"]\)", "<f>"->"\!\(\*StyleBox[\"", "</f>" -> "\", \"Input\"]\)"} 
BrauerciteJanusz66=BrauerDOIToString["[Janusz 1966]","10.2307/2035203"];
BrauerciteSamra79=BrauerDOIToString["[Samra&King 1979]","10.1088/0305-4470/12/12/010"];
BrauerciteRobinson61=BrauerDOIToString["[Robinson 1961]","10.1017/CBO9781107340732"];
BrauerciteMacDonald95=BrauerDOIToString["[MacDonald 1995]","10.1112/blms/13.2.180"];
BrauerciteFulton96=BrauerDOIToString["[Fulton 1996]","10.1017/CBO9780511626241"];
BrauercitePuchala17=BrauerDOIToString["[Puchala&Miszczak 2017]","10.48550/arXiv.1109.4244"];


(* ::Input::Initialization:: *)
(*** VERSIONS ***)
$Version::usage="$Version is a global variable giving the version of the package SymmetricFunctions in use.";


(***********************************************************************************************)
(*********************************** Basic functions *******************************************)
(***********************************************************************************************)

(*** Basic symmetric functions ***)
$SymmetricFunctions::usage="$SymmetricFunctions is a global variable which lists the symmetric functions implemented in this package.";
SymmetricFunctionQ::usage="SymmetricFunctionQ[f] returns True if f is a symmetric function.";
ElementarySymmetricFunction::usage="ElementarySymmetricFunction[\[Lambda]] is the elementary symmetric function associated with the partition \[Lambda]. 
ElementarySymmetricFunction[\[Lambda]][\!\(\*SubscriptBox[\(x\), \(1\)]\),...,\!\(\*SubscriptBox[\(x\), \(n\)]\)] returns the corresponding polynomial in the variables \!\(\*SubscriptBox[\(x\), \(1\)]\),...,\!\(\*SubscriptBox[\(x\), \(n\)]\).";
CompleteSymmetricFunction::usage="CompleteSymmetricFunction[\[Lambda]] is the elementary symmetric function associated with the partition \[Lambda]. 
CompleteSymmetricFunction[\[Lambda]][\!\(\*SubscriptBox[\(x\), \(1\)]\),...,\!\(\*SubscriptBox[\(x\), \(n\)]\)] returns the corresponding polynomial in the variables \!\(\*SubscriptBox[\(x\), \(1\)]\),...,\!\(\*SubscriptBox[\(x\), \(n\)]\).";
PowerSymmetricFunction::usage="PowerSymmetricFunction[\[Lambda]] is the elementary symmetric function associated with the partition \[Lambda]. 
PowerSymmetricFunction[\[Lambda]][\!\(\*SubscriptBox[\(x\), \(1\)]\),...,\!\(\*SubscriptBox[\(x\), \(n\)]\)] returns the corresponding polynomial in the variables \!\(\*SubscriptBox[\(x\), \(1\)]\),...,\!\(\*SubscriptBox[\(x\), \(n\)]\).";
MonomialSymmetricFunction::usage="MonomialSymmetricFunction[\[Lambda]] is the elementary symmetric function associated with the partition \[Lambda]. 
MonomialSymmetricFunction[\[Lambda]][\!\(\*SubscriptBox[\(x\), \(1\)]\),...,\!\(\*SubscriptBox[\(x\), \(n\)]\)] returns the corresponding polynomial in the variables \!\(\*SubscriptBox[\(x\), \(1\)]\),...,\!\(\*SubscriptBox[\(x\), \(n\)]\).";
SchurFunction::usage="SchurFunction[\[Lambda]] is the elementary symmetric function associated with the partition \[Lambda]. 
SchurFunction[\[Lambda]][\!\(\*SubscriptBox[\(x\), \(1\)]\),...,\!\(\*SubscriptBox[\(x\), \(n\)]\)] returns the corresponding polynomial in the variables \!\(\*SubscriptBox[\(x\), \(1\)]\),...,\!\(\*SubscriptBox[\(x\), \(n\)]\).";
(*SchurFunctionExpand::usage="To do";
MonomialSymmetricFunctionExpand::usage="To do";*)
SymmetricFunctionExpand::usage="SymmetricFunctionExpand[exp] expand the products of the monomial symmetric functions and Schur functions appearing in exp. 
The product expansion of the elementary, complete and power symmetric functions is automatic.";

(*** Basic symmetric polynomial ***)
ElementarySymmetricPolynomial::usage="ElementarySymmetricPolynomial[\[Lambda],{\!\(\*SubscriptBox[\(x\), \(1\)]\),...,\!\(\*SubscriptBox[\(x\), \(n\)]\)}] returns the elementary symmetric polynomial associated with the partition \[Lambda] 
in the variables \!\(\*SubscriptBox[\(x\), \(1\)]\),...,\!\(\*SubscriptBox[\(x\), \(n\)]\).";
CompleteSymmetricPolynomial::usage="CompleteSymmetricPolynomial[\[Lambda],{\!\(\*SubscriptBox[\(x\), \(1\)]\),...,\!\(\*SubscriptBox[\(x\), \(n\)]\)}] returns the complete homogeneous symmetric polynomial associated with the partition \[Lambda] 
in the variables \!\(\*SubscriptBox[\(x\), \(1\)]\),...,\!\(\*SubscriptBox[\(x\), \(n\)]\).";
PowerSymmetricPolynomial::usage="PowerSymmetricPolynomial[\[Lambda],{\!\(\*SubscriptBox[\(x\), \(1\)]\),...,\!\(\*SubscriptBox[\(x\), \(n\)]\)}] returns the power sum symmetric polynomial associated with the partition \[Lambda] 
in the variables \!\(\*SubscriptBox[\(x\), \(1\)]\),...,\!\(\*SubscriptBox[\(x\), \(n\)]\).";
MonomialSymmetricPolynomial::usage="MonomialSymmetricPolynomial[\[Lambda],{\!\(\*SubscriptBox[\(x\), \(1\)]\),...,\!\(\*SubscriptBox[\(x\), \(n\)]\)}] returns the monomial symmetric polynomial associated with the partition \[Lambda] 
in the variables \!\(\*SubscriptBox[\(x\), \(1\)]\),...,\!\(\*SubscriptBox[\(x\), \(n\)]\).";
SchurPolynomial::usage="SchurPolynomial[\[Lambda],{\!\(\*SubscriptBox[\(x\), \(1\)]\),...,\!\(\*SubscriptBox[\(x\), \(n\)]\)}] returns the Schur symmetric polynomial associated with the partition \[Lambda] 
in the variables \!\(\*SubscriptBox[\(x\), \(1\)]\),...,\!\(\*SubscriptBox[\(x\), \(n\)]\).";
(*** To polynomial ***)
ToPolynomial::usage="ToPolynomial[exp,{\!\(\*SubscriptBox[\(x\), \(1\)]\),...,\!\(\*SubscriptBox[\(x\), \(n\)]\)}] returns the polynomial in the variables \!\(\*SubscriptBox[\(x\), \(1\)]\),...,\!\(\*SubscriptBox[\(x\), \(n\)]\) associated with exp, where exp is a linear combination 
of symmetric functions.";

(*** Change of basis ***)
ChangeSymmetricBasis::usage="ChangeSymmetricBasis[expr,basis] converts of all symmetric functions appearing ";
(*** Plethysm ***)
SymmetricFunctionBasis::usage="SymmetricFunctionBasis is an option for Plethysm. It can take the value Automatic, ElementarySymmetricFunction, MonomialSymmetricFunction, 
CompleteSymmetricFunction, PowerSymmetricFunction, SchurFunction. The default value is Automatic.";
Plethysm::usage="Plethysm[f[\[Lambda]],h[\[Mu]]] returns the plethysm \!\(\*SubscriptBox[\(f\), \(\[Lambda]\)]\)[\!\(\*SubscriptBox[\(h\), \(\[Mu]\)]\)], where f and h are symmetric functions.";


(***************************************************************************************************)
(*********************************** Combinatorial stuff *******************************************)
(***************************************************************************************************)
TransposePartition::usage="TransposePartition[\[Mu]] returns the transpose partition of \[Mu].";
PartitionJoin::usage="PartitionJoin[a,b] returns a new partition whose parts are the union of a and b.";
IncludedPartitionQ::usage="IncludedPartitionQ[\[Lambda],\[Mu]] returns true if \[Mu] is included in \[Lambda]. Than \!\(\*SubscriptBox[\(\[Mu]\), \(i\)]\) <= \!\(\*SubscriptBox[\(\[Lambda]\), \(i\)]\) for all 1<=i<=l where l is the lenght of \[Mu].";
PartitionMultiplicities::usage="PartitionMultiplicities[\[Lambda]] returns (m1,m2,...) so that mi is then number of parts of size i in \[Lambda].";
ZCoefficient::usage="ZCoefficient[\[Lambda]] returns the Z-coefficient of \[Lambda], as p. 299, Enumerative Combinatorics II, Stanley";
PartitionDominatesQ::usage="PartitionDomanitesQ[\[Lambda],\[Mu]] returns True if \[Lambda] is greater or equal to \[Mu] in dominance order.";

KostkaCoefficient::usage="KostkaCoefficient[\[Lambda],\[Mu]] returns the Kostka coefficient \!\(\*SubscriptBox[\(K\), \(\[Lambda]\[Mu]\)]\) corresponding to the number of SSYT of shape \[Lambda] and weight (content) \[Mu]. This coefficient appears for 
example in the change of basis from Schur basis to Monomial basis : \!\(\*SubscriptBox[\(s\), \(\[Lambda]\)]\)=\!\(\*SubscriptBox[\(\[CapitalSigma]K\), \(\[Lambda]\[Mu]\)]\) \!\(\*SubscriptBox[\(m\), \(\[Mu]\)]\)";
InverseKostkaCoefficient::usage="InverseKostkaCoefficient[\[Lambda],\[Mu]] returns the inverse Kostka coefficient (\!\(\*SuperscriptBox[\(K\), \(-1\)]\)\!\(\*SubscriptBox[\()\), \(\[Lambda]\[Mu]\)]\) .";

CharacterSymmetricGroup::usage=StringReplace["CharacterSymmetricGroup[\[Lambda],\[Mu]] gives the character of the symmetric group \!\(\*SuperscriptBox[\(\[Chi]\), \((\[Lambda])\)]\) evaluated at \[Mu].
CharacterSymmetricGroup[\[Lambda]] returns the character of the symmetric group \!\(\*SuperscriptBox[\(\[Chi]\), \((\[Lambda])\)]\) evaluated at the identity. 
This function is borrowed from the package IntU developed by Z. Puchala and J. Miszczak "<>BrauercitePuchala17<>".",BrauerDocumentationReplacements];

SemiStandardTableaux::usage="SemiStandardTableaux[{\[Lambda],\[Mu]},\[Rho]] returns a list of all SSYT with the skew shape \[Lambda]/\[Mu] and weight \[Rho].
SemiStandardTableaux[\[Lambda],\[Rho]] returns a list of all SSYT with the skew shape \[Lambda] and weight \[Rho].";
StandardTableaux::usage="StandardTableaux[\[Lambda]] return a list of all standard Young tableaux with shape \[Lambda]. 
StandardTableaux[n] returns a list of all standard Young tableaux associated with the partitions of n";


LittlewoodRichardsonRule::usage=StringReplace["LittlewoodRichardsonRule[\[Mu],\[Lambda]] returns a list of the partitions (with multiplicities)
 corresponding to irreducible representations of GL appearing in the tensor product of the irreducible representations \[Mu] and \[Lambda]."<>BrauerciteFulton96<>"",BrauerDocumentationReplacements]
InverseLittlewoodRichardsonRule::usage="InverseLittlewoodRichardsonRule[\[Mu],\[Nu]] returns the list of the partitions \[Lambda] such that \[Mu] \[Element] LittlewoodRichardsonRule[\[Nu],\[Lambda]]. This also correspond to the weigths of
the skew-shape tableaux in LRTableaux[\[Mu],\[Nu]].";
LittlewoodRichardsonCoefficient::usage="LittlewoodRichardsonCoefficient[\[Mu],\[Nu],\[Lambda]] returns the Littlewood-Richardson coefficient \!\(\*SubscriptBox[SuperscriptBox[\(C\), \(\[Mu]\)], \(\[Nu]\[Lambda]\)]\) : \[Nu]\[TensorProduct]\[Lambda]=\!\(\*SubscriptBox[SuperscriptBox[\(\[CapitalSigma]C\), \(\[Mu]\)], \(\[Nu]\[Lambda]\)]\) \[Mu], where \[Nu],\[Lambda] and \[Mu] 
are irreducible representations of GL. These are also the coefficient in the product expandsion of Schur functions \!\(\*SubscriptBox[\(s\), \(\[Nu]\)]\)\!\(\*SubscriptBox[\(s\), \(\[Lambda]\)]\)=\!\(\*SubscriptBox[SuperscriptBox[\(\[CapitalSigma]C\), \(\[Mu]\)], \(\[Nu]\[Lambda]\)]\) \!\(\*SubscriptBox[\(s\), \(\[Mu]\)]\). 
LittlewoodRichardsonCoefficient[\[Mu],\[Nu]] enumerates the partitions \[Lambda] with its non vanishing LittlewoodRichardsonCoefficient \!\(\*SubscriptBox[SuperscriptBox[\(C\), \(\[Mu]\)], \(\[Nu]\[Lambda]\)]\).
LittlewoodRichardsonCoefficient[\[Mu]] enumerates the pairs of partitions (\[Lambda],\[Nu]) with its non vanishing LittlewoodRichardsonCoefficient \!\(\*SubscriptBox[SuperscriptBox[\(C\), \(\[Mu]\)], \(\[Nu]\[Lambda]\)]\).";
LittlewoodRichardsonTableaux::usage=StringReplace["LittlewoodRichardsonTableaux[\[Mu],\[Lambda]] returns a list of semi-standard skew shape \[Mu]/\[Lambda] with row word a lattice permutation. 
LittlewoodRichardsonTableaux[\[Mu],\[Lambda],\[Nu]] returns a list of semi-standard skew shape \[Mu]/\[Lambda] with weight \[Nu] and row word a lattice permutation."<>BrauerciteMacDonald95<>"
This function is borrowed from the package SchurFs developed by K. Ohmori.",BrauerDocumentationReplacements];
NewellLittlewoodCoefficient::usage="NewellLittlewoodCoefficient[\[Mu],\[Nu],\[Lambda]] returns the Newell-Littlewood coefficient \!\(\*SubscriptBox[SuperscriptBox[\(N\), \(\[Mu]\)], \(\[Nu]\[Lambda]\)]\) : \[Nu]\[TensorProduct]\[Lambda]=\!\(\*SubscriptBox[SuperscriptBox[\(\[CapitalSigma]N\), \(\[Mu]\)], \(\[Nu]\[Lambda]\)]\) \[Mu], where \[Nu],\[Lambda] and \[Mu] 
are irreducible representations of SO, O, or Sp.";
NewellLittlewoodRule::usage="NewellLittlewoodRule[\[Mu],\[Lambda]] returns a list of the partitions (with multiplicities)
 corresponding to irreducible representations of the orthogonal group appearing in the tensor product of the irreducible representations \[Mu] and \[Lambda].";
BratteliPathSn::usage="BratteliPathSn[tab] returns the path in the Bratteli diagram of \!\(\*SubscriptBox[\(S\), \(n\)]\) associated with the standard tableau tab.";
BratteliDiagramSn::usage="BrattelidiagramSn[n] returns the Bratteli diagram of \!\(\*SubscriptBox[\(S\), \(n\)]\) (Young's lattice) that is formed by all integer partitions from 1 to n.";
DimOfIrrepSn::usage="DimOfIrrepSn[\[Mu]] returns the dimension of the irreducible representation of the symmetric group associated with the partition \[Mu].";
TableauForm::usage="Transform a list into a young tableau format.";
Output::usage="In the package SymmetricFunctions Output is an option for BratteliDiagramSn. It can take the value List or Graph. The default value is List. ";
(********** Dimension of Irreducible representation of classical Lie groups *******)
GeneralLinearGroup::usage="GeneralLinearGroup is a parameter for DimOfIrrep and for BranchingRule.";
OrthogonalGroup::usage="OrthogonalGroup is a parameter for DimOfIrrep and for BranchingRule.";
SymplecticGroup::usage="SymplecticGroup is a parameter for DimOfIrrep and for BranchingRule.";
DimOfIrrep::usage=StringReplace["DimOfIrrep[\[Mu],group[N]] returns the dimension of the irrep of the Lie group group[N] associated with the partition \[Mu] where N is either an integer 
or a symbol. The parameter group can take the value GeneralLinearGroup, OrthogonalGroup or SymplecticGroup. 
See for example p 60 of "<>BrauerciteRobinson61<>" and "<>BrauerciteSamra79<>".",BrauerDocumentationReplacements];

BranchingRule::usage="Experimental : BranchingRule[\[Mu],SymmetricGroup[n1],SymmetricGroup[n2]] ... BranchingRule[\[Mu],GeneralLinearGroup[N],OrthogonalGroup[N]]... 
BranchingRule[\[Mu],GeneralLinearGroup[N],SymplecticGroup[N]].";

$LieGroups::usage="$LieGroups is a global variable which lists the Lie groups which can enter as a parameter for certain functions of the package.";
(*DimOfIrrepGL::usage=StringReplace["DimOfIrrepGL[\[Mu],N] returns the dimension of the irrep of the general linear group GL[N] associated with the partition \[Mu] where N is either an integer  or a symbol.
DimOfIrrepGL[\[Mu]] returns the dimension of the irrep of the general linear linear group GL[Subscript[\[Delta], d]] associated with the partition \[Mu] (Implicititly Subscript[\[Delta], d] is to be understood as an integer here).
See for example p 60 of "<>BrauerciteRobinson61<>".",BrauerDocumentationReplacements];
DimOfIrrepO::usage=StringReplace["DimOfIrrepO[\[Mu],N] returns the dimension of the irrep of the orthogonal group O[N] associated with the partition \[Mu] where N is either an integer  or a symbol.
DimOfIrrepO[\[Mu]] returns the dimension of the orthogonal group O[Subscript[\[Delta], d]] irrep associated with the partition \[Mu] (Implicititly Subscript[\[Delta], d] is to be understood as an integer here).
We use the formula presented in "<>BrauerciteSamra79<>".",BrauerDocumentationReplacements];
DimOfIrrepSp::usage=StringReplace["DimOfIrrepSp[\[Mu],N] returns the dimension of the irrep of the symplectic group Sp[N] associated with the partition \[Mu] where N is either an integer  or a symbol.
DimOfIrrepSp[\[Mu]] returns the dimension of the irrep of the symplectic group Sp[Subscript[\[Delta], d]] associated with the partition \[Mu] (Implicititly Subscript[\[Delta], d] is to be understood as an integer here).
We use the formula presented in "<>BrauerciteSamra79<>".",BrauerDocumentationReplacements];*)

(******************** We delete the citation and related function **************************)
Remove["BrauerDOIToString","BrauerDocumentationReplacements","BrauerciteJanusz66","BrauerciteSamra79","BrauerciteRobinson61",
"BrauerciteMacDonald95","doi","text","BrauerciteFulton96","BrauercitePuchala17"]


(* ::Input::Initialization:: *)
Begin["`Private`"]


(* ::Input::Initialization:: *)
(****** This function is borrowed to xCore Package : Jos\[EAcute] M. Mart\[IAcute]n-Garc\[IAcute]a
jose@xact.es
(c) 2007-2020,under GPL ****)
CheckOptions[]:={};
CheckOptions[opts__]:=If[OptionQ[{opts}]&&MemberQ[{1,2},ArrayDepth[{opts}]],
Flatten[{opts},1],
Throw[Message[CheckOptions::invalid,opts,"option or list of options"]]];
Protect[CheckOptions];


(* ::Input::Initialization:: *)
mycomplementSmall[list1_,list2_]:=Fold[DeleteCases[##,1,1]&,list1,list2] (*** For small lists ***)


(* ::Input::Initialization:: *)
$SymmetricFunctions:={ElementarySymmetricFunction,MonomialSymmetricFunction,CompleteSymmetricFunction,PowerSymmetricFunction,SchurFunction}
$LieGroups:={GeneralLinearGroup,OrthogonalGroup,SymplecticGroup}
SymmetricFunctionQ[x_]:=MemberQ[$SymmetricFunctions,Head[x]]


(* ::Input::Initialization:: *)
ElementarySymmetricFunction/:MakeBoxes[ElementarySymmetricFunction[i_Integer|i_List],StandardForm]:=SubscriptBox[OverscriptBox["e","_"],MakeBoxes[i,StandardForm]];
MakeExpression[SubscriptBox[OverscriptBox["e","_"],i_],StandardForm]:=MakeExpression[RowBox[{"ElementarySymmetricFunction","[",i,"]"}],StandardForm];
ElementarySymmetricFunction/:ElementarySymmetricFunction[{0}]:=1


(* ::Input::Initialization:: *)
ElementarySymmetricFunction[i_Integer|i_List][vars__]:=ElementarySymmetricPolynomial[i,{vars}]


(* ::Input::Initialization:: *)
ExpandSymmetricFunction0[f:ElementarySymmetricFunction[\[Mu]_List]]:=Times@@(ElementarySymmetricFunction[#]&/@\[Mu]);


(* ::Input::Initialization:: *)
CompleteSymmetricFunction/:MakeBoxes[CompleteSymmetricFunction[i_Integer|i_List],StandardForm]:=SubscriptBox[OverscriptBox["h","_"],MakeBoxes[i,StandardForm]];
MakeExpression[SubscriptBox[OverscriptBox["h","_"],i_],StandardForm]:=MakeExpression[RowBox[{"CompleteSymmetricFunction","[",i,"]"}],StandardForm];
CompleteSymmetricFunction/:CompleteSymmetricFunction[{0}]:=1


(* ::Input::Initialization:: *)
CompleteSymmetricFunction[i_Integer|i_List][vars__]:=CompleteSymmetricPolynomial[i,{vars}]


(* ::Input::Initialization:: *)
ExpandSymmetricFunction0[f:CompleteSymmetricFunction[\[Mu]_List]]:=Times@@(CompleteSymmetricFunction[#]&/@\[Mu]);


(* ::Input::Initialization:: *)
PowerSymmetricFunction/:MakeBoxes[PowerSymmetricFunction[i_Integer|i_List],StandardForm]:=SubscriptBox[OverscriptBox["p","_"],MakeBoxes[i,StandardForm]];
MakeExpression[SubscriptBox[OverscriptBox["p","_"],i_],StandardForm]:=MakeExpression[RowBox[{"PowerSymmetricFunction","[",i,"]"}],StandardForm];
PowerSymmetricFunction[i_Integer|i_List][variables__]:=PowerSymmetricPolynomial[i,List[variables]]
PowerSymmetricFunction/:PowerSymmetricFunction[{0}]:=1


(* ::Input::Initialization:: *)
ExpandSymmetricFunction0[f:PowerSymmetricFunction[\[Mu]_List]]:=Times@@(PowerSymmetricFunction[#]&/@\[Mu]);


(* ::Input::Initialization:: *)
MonomialSymmetricFunction/:MakeBoxes[MonomialSymmetricFunction[i_List],StandardForm]:=SubscriptBox[OverscriptBox["m","_"],MakeBoxes[i,StandardForm]];
MakeExpression[SubscriptBox[OverscriptBox["m","_"],i_],StandardForm]:=MakeExpression[RowBox[{"MonomialSymmetricFunction","[",i,"]"}],StandardForm];
MonomialSymmetricFunction/:MonomialSymmetricFunction[{0}]:=1


(* ::Input::Initialization:: *)
MonomialSymmetricFunction[\[Mu]_List][vars__]:=MonomialSymmetricPolynomial[\[Mu],{vars}]


(* ::Input::Initialization:: *)
SchurFunction/:MakeBoxes[SchurFunction[i_List],StandardForm]:=SubscriptBox[OverscriptBox["s","_"],MakeBoxes[i,StandardForm]];
MakeExpression[SubscriptBox[OverscriptBox["s","_"],i_],StandardForm]:=MakeExpression[RowBox[{"SchurFunction","[",i,"]"}],StandardForm];
SchurFunction/:SchurFunction[{0}]:=1


(* ::Input::Initialization:: *)
SchurFunction[\[Mu]_List][variables__]:=SchurPolynomial[\[Mu],List[variables]]


(* ::Input::Initialization:: *)
ToPolynomial[exp_,variables_List]:=Expand[exp/.f:(ElementarySymmetricFunction[i_]|CompleteSymmetricFunction[i_]|MonomialSymmetricFunction[i_]|PowerSymmetricFunction[i_]|SchurFunction[i_]):>ToPolynomial0[f,variables]]


(* ::Input::Initialization:: *)
ElementarySymmetricPolynomial[i_Integer,variables_List]:=SymmetricPolynomial[i,variables]
ElementarySymmetricPolynomial[\[Mu]_List,variables_List]:=Expand[Product[SymmetricPolynomial[\[Mu][[k]],variables],{k,1,Length[\[Mu]]}]]


(* ::Input::Initialization:: *)
ToPolynomial0[f:ElementarySymmetricFunction[i_Integer|i_List],variables_List]:=ElementarySymmetricPolynomial[i,variables]


(* ::Input::Initialization:: *)
CompleteSymmetricPolynomial[0,vars_List]:=1;
CompleteSymmetricPolynomial[i_Integer,vars_List]:=Total@Union@Tuples[Times@@vars,{i}];
CompleteSymmetricPolynomial[\[Mu]_List,variables_List]:=Expand[Product[CompleteSymmetricPolynomial[\[Mu][[k]],variables],{k,1,Length[\[Mu]]}]]


(* ::Input::Initialization:: *)
ToPolynomial0[f:CompleteSymmetricFunction[i_Integer|i_List],variables_List]:=CompleteSymmetricPolynomial[i,variables]


(* ::Input::Initialization:: *)
(******* Maybe a bug with PowerSymmetricPolynomial but I were forced to do this to overload the function PowerSymmetricPolynomial of Mathematica ****)
Unprotect[PowerSymmetricPolynomial];
Off[SetDelayed::write]
PowerSymmetricPolynomial[\[Mu]_List,variables_List]:=Expand[Product[Total[Power[variables,\[Mu][[k]]]],{k,1,Length[\[Mu]]}]];
Unprotect[PowerSymmetricPolynomial];
PowerSymmetricPolynomial[\[Mu]_List,variables_List]:=Expand[Product[Total[Power[variables,\[Mu][[k]]]],{k,1,Length[\[Mu]]}]];
On[SetDelayed::write]
ClearAttributes[PowerSymmetricPolynomial,Attributes[PowerSymmetricPolynomial]];
SetAttributes[PowerSymmetricPolynomial,{Protected,ReadProtected}];


(* ::Input::Initialization:: *)
ToPolynomial0[f:PowerSymmetricFunction[i_Integer|i_List],variables_List]:=PowerSymmetricPolynomial[i,variables];


(* ::Input::Initialization:: *)
MonomialSymmetricPolynomial[\[Mu]_List,vars_List]/;Length[\[Mu]]>Length[vars]:=0
MonomialSymmetricPolynomial[\[Mu]_List,vars_List]:=Plus@@Map[Times@@Thread[Power[vars,#]]&,Permutations[PadRight[\[Mu],Length[vars]]]]


(* ::Input::Initialization:: *)
ToPolynomial0[f:MonomialSymmetricFunction[i_List],variables_List]:=MonomialSymmetricPolynomial[i,variables]


(* ::Input::Initialization:: *)
SchurPolynomial[\[Lambda]_,vars_List]:=Expand[Total[Map[KostkaCoefficient[\[Lambda],#]*MonomialSymmetricPolynomial[#,vars]&,Select[IntegerPartitions[Plus@@\[Lambda],{Length[\[Lambda]],Length[vars]}],PartitionDominatesQ[\[Lambda],#]&]]]]


(* ::Input::Initialization:: *)
ToPolynomial0[f:SchurFunction[i_List],variables_List]:=SchurPolynomial[i,variables];


(* ::Input::Initialization:: *)
ChangeSymmetricBasis0[f:CompleteSymmetricFunction[\[Mu]:{i_}],ElementarySymmetricFunction]:=Total[Map[(-1)^(i-Length[#])*Length[#]!/Times@@Factorial[PartitionMultiplicities[#]]ElementarySymmetricFunction[#]&,IntegerPartitions[i]]]
ChangeSymmetricBasis0[f:CompleteSymmetricFunction[\[Mu]:{i_,k__}],ElementarySymmetricFunction]:=Fold[Expand[Times[#1,#2]]&,Map[ChangeSymmetricBasis0[CompleteSymmetricFunction[{#}],ElementarySymmetricFunction]&,\[Mu]]]

ChangeSymmetricBasis0[f:PowerSymmetricFunction[\[Mu]:{i_}],ElementarySymmetricFunction]:=Total[Map[(-1)^(Length[#]+i)*i*(Length[#]-1)!/Times@@Factorial[PartitionMultiplicities[#]]ElementarySymmetricFunction[#]&,IntegerPartitions[i]]]

ChangeSymmetricBasis0[f:PowerSymmetricFunction[\[Mu]:{i_,k__}],ElementarySymmetricFunction]:=Fold[Expand[Times[#1,#2]]&,Map[ChangeSymmetricBasis0[PowerSymmetricFunction[{#}],ElementarySymmetricFunction]&,\[Mu]]]

ChangeSymmetricBasis0[f:MonomialSymmetricFunction[\[Mu]_],ElementarySymmetricFunction]:=ChangeSymmetricBasis[ChangeSymmetricBasis0[f,SchurFunction],ElementarySymmetricFunction]

ChangeSymmetricBasis0[f:SchurFunction[\[Lambda]_],ElementarySymmetricFunction]:=With[{t\[Lambda]=TransposePartition[\[Lambda]]},Total[Map[InverseKostkaCoefficient[#,t\[Lambda]]*ElementarySymmetricFunction[#]&,IntegerPartitions[Tr[\[Lambda]]]]]]


(* ::Input::Initialization:: *)
ChangeSymmetricBasis[exp_,ElementarySymmetricFunction]:=Expand[exp/.f:(MonomialSymmetricFunction[i_]|SchurFunction[i_]|CompleteSymmetricFunction[i_]|PowerSymmetricFunction[i_]):>ChangeSymmetricBasis0[f,ElementarySymmetricFunction]]


(* ::Input::Initialization:: *)
(*** Ref : Mike Zabrocki lectures ***)
ChangeSymmetricBasis0[f:ElementarySymmetricFunction[\[Mu]:{i_}],CompleteSymmetricFunction]:=Total[Map[(-1)^(i-Length[#])*Length[#]!/Times@@Factorial[PartitionMultiplicities[#]]CompleteSymmetricFunction[#]&,IntegerPartitions[i]]]
ChangeSymmetricBasis0[f:ElementarySymmetricFunction[\[Mu]:{i_,k__}],CompleteSymmetricFunction]:=Fold[Expand[Times[#1,#2]]&,Map[ChangeSymmetricBasis0[ElementarySymmetricFunction[{#}],CompleteSymmetricFunction]&,\[Mu]]]

ChangeSymmetricBasis0[f:PowerSymmetricFunction[\[Mu]:{i_}],CompleteSymmetricFunction]:=Total[Map[(-1)^(Length[#]-1)*i*(Length[#]-1)!/Times@@Factorial[PartitionMultiplicities[#]]CompleteSymmetricFunction[#]&,IntegerPartitions[i]]]
ChangeSymmetricBasis0[f:PowerSymmetricFunction[\[Mu]:{i_,k__}],CompleteSymmetricFunction]:=Fold[Expand[Times[#1,#2]]&,Map[ChangeSymmetricBasis0[PowerSymmetricFunction[{#}],CompleteSymmetricFunction]&,\[Mu]]]

ChangeSymmetricBasis0[f:MonomialSymmetricFunction[\[Mu]_],CompleteSymmetricFunction]:=ChangeSymmetricBasis[ChangeSymmetricBasis0[f,SchurFunction],CompleteSymmetricFunction]

ChangeSymmetricBasis0[f:SchurFunction[\[Lambda]_],CompleteSymmetricFunction]:=Total[Map[InverseKostkaCoefficient[#,\[Lambda]]*CompleteSymmetricFunction[#]&,IntegerPartitions[Total[\[Lambda]]]]]


(* ::Input::Initialization:: *)
ChangeSymmetricBasis[exp_,CompleteSymmetricFunction]:=Expand[exp/.f:(ElementarySymmetricFunction[i_]|SchurFunction[i_]|PowerSymmetricFunction[i_]|MonomialSymmetricFunction[i_]):>ChangeSymmetricBasis0[f,CompleteSymmetricFunction]]


(* ::Input::Initialization:: *)
ExponentialBellPolynomials[n_,vars_List]:=Sum[BellY[n,k,Drop[vars,-(k-1)]],{k,1,n}]


(* ::Input::Initialization:: *)
ChangeSymmetricBasis0[f:ElementarySymmetricFunction[{i_}],PowerSymmetricFunction]:=(-1)^i/i!*ExponentialBellPolynomials[i,Map[-(#-1)!*PowerSymmetricFunction[#]&,Range[i]]]

ChangeSymmetricBasis0[f:ElementarySymmetricFunction[\[Mu]:{i_,k__}],PowerSymmetricFunction]:=Fold[Expand[Times[#1,#2]]&,Map[ChangeSymmetricBasis0[ElementarySymmetricFunction[{#}],PowerSymmetricFunction]&,\[Mu]]]

ChangeSymmetricBasis0[f:CompleteSymmetricFunction[{i_}],PowerSymmetricFunction]:=Expand[1/i!*ExponentialBellPolynomials[i,Map[(#-1)!*PowerSymmetricFunction[#]&,Range[i]]]]

ChangeSymmetricBasis0[f:CompleteSymmetricFunction[\[Mu]:{i_,k__}],PowerSymmetricFunction]:=Expand[Fold[Times[#1,#2]&,Map[ChangeSymmetricBasis0[CompleteSymmetricFunction[{#}],PowerSymmetricFunction]&,\[Mu]]]]

ChangeSymmetricBasis0[f:SchurFunction[\[Mu]_List],PowerSymmetricFunction]:=With[{n=Plus@@\[Mu]},
Plus@@Map[CharacterSymmetricGroup[\[Mu],#]/ZCoefficient[#]*PowerSymmetricFunction[#]&,IntegerPartitions[n]]
]

(*ChangeSymmetricBasis0[f:MonomialSymmetricFunction[\[Lambda]_],PowerSymmetricFunction]:=Total[Map[mTop[\[Lambda],#]*PowerSymmetricFunction[#]&,IntegerPartitions[Total[\[Lambda]]]]]*)
ChangeSymmetricBasis0[f:MonomialSymmetricFunction[\[Lambda]_],PowerSymmetricFunction]:=Sum[mTop[\[Lambda],p]PowerSymmetricFunction[p],{p,IntegerPartitions[Tr[\[Lambda]]]}]

ChangeSymmetricBasis[exp_,PowerSymmetricFunction]:=Expand[exp/.f:(ElementarySymmetricFunction[i_]|CompleteSymmetricFunction[i_]|SchurFunction[i_]|MonomialSymmetricFunction[i_]):>ChangeSymmetricBasis0[f,PowerSymmetricFunction]]


(* Thm. 5.1 in https://arxiv.org/pdf/1712.08023.pdf *)
(* Util for expressing monomial in power-sum *)
(* This is not used --- computing transition matrices is quicker using characters. *)
mTop[lam_, mu_] := 0 /; (!PartitionDominatesQ[mu,lam]);
mTop[lam_, lam_] := 1/(Times @@ (PartitionMultiplicities[lam]!));
mTop[lam_, mu_] := With[{n=Tr@lam},
	augMinPHelper[
		PadRight[PartitionMultiplicities@lam, n],
		PadRight[PartitionMultiplicities@mu, n], n]]/(Times @@ (PartitionMultiplicities[lam]!));
		(* This is based on Corollary 3, of  10.1186/s40064-015-1506-5, 
	Mircea Merca - Augmented monomials in terms of power sums.
	This is not used.
*)
augMinPHelper[{}, {}, 0] := 1;
augMinPHelper[muPC_List, muPC_List, n_Integer] := 1;
augMinPHelper[lamPC_List, muPC_List, n_Integer] := 
	augMinPHelper[lamPC, muPC, n] = With[{j = FirstPosition[lamPC, i_ /; i > 0][[1]]},
		With[{lamPCi = Function[{i}, Table[
				lamPC[[r]] + Which[r == i || r == j, -1 - KroneckerDelta[i, j],r == i + j, 1,True, 0], {r, n}]]},
			If[Length[muPC] >= j && muPC[[j]] != 0,
			augMinPHelper[MapAt[# - 1 &, lamPC, j][[1 ;; n - j]],MapAt[# - 1 &, muPC, j][[1 ;; n - j]], n - j],0]
			-
			Sum[With[{coeff = (lamPC[[i]] - KroneckerDelta[i, j])},If[coeff != 0, coeff *augMinPHelper[lamPCi[i], muPC, n], 0]], {i, n}]
]];


(* ::Input::Initialization:: *)
(*** Main need optimization **)
ChangeSymmetricBasis0[f:ElementarySymmetricFunction[\[Mu]:{i_}],MonomialSymmetricFunction]:=MonomialSymmetricFunction[ConstantArray[1,i]]
ChangeSymmetricBasis0[f:ElementarySymmetricFunction[\[Mu]:{i_,k__}],MonomialSymmetricFunction]:=Fold[Expand[Times[#1,#2]]&,Map[MonomialSymmetricFunction[ConstantArray[1,#]]&,\[Mu]]]

ChangeSymmetricBasis0[f:CompleteSymmetricFunction[\[Mu]:{i_}],MonomialSymmetricFunction]:=Plus@@Map[MonomialSymmetricFunction[#]&,IntegerPartitions[i]];
ChangeSymmetricBasis0[f:CompleteSymmetricFunction[\[Mu]_],MonomialSymmetricFunction]:=With[{partitions\[Lambda]=IntegerPartitions[Tr[\[Mu]]],partitions\[Rho]=Select[IntegerPartitions[Tr[\[Mu]]],PartitionDominatesQ[#,\[Mu]]&]},
Sum[KostkaCoefficient[partitions\[Rho][[j]],partitions\[Lambda][[i]]]KostkaCoefficient[partitions\[Rho][[j]],\[Mu]]MonomialSymmetricFunction[partitions\[Lambda][[i]]],{j,1,Length[partitions\[Rho]]},{i,1,Length[partitions\[Lambda]]}]
]
(*****************************)

ChangeSymmetricBasis0[f:PowerSymmetricFunction[\[Mu]:{i_}],MonomialSymmetricFunction]:=MonomialSymmetricFunction[{i}]
(*ChangeSymmetricBasis0[f:PowerSymmetricFunction[\[Mu]:{i_,k__}],MonomialSymmetricFunction]:=Fold[Expand[Times[#1,#2]]&,Map[MonomialSymmetricFunction[{#}]&,\[Mu]]]*)
ChangeSymmetricBasis0[f:PowerSymmetricFunction[\[Mu]:{i_,k__}],MonomialSymmetricFunction]:=With[{tallys=Sort[Tally[\[Mu]],#1[[2]]>=#2[[2]]&]},Fold[Expand[#1*#2]&,Join[{Power[MonomialSymmetricFunction[{First[tallys][[1]]}],First[tallys][[2]]]},Map[MonomialSymmetricFunction[{#}]&,Flatten[ConstantArray@@@Rest[tallys]]]]]]

ChangeSymmetricBasis0[f:SchurFunction[\[Lambda]_],MonomialSymmetricFunction]:=Total[Map[KostkaCoefficient[\[Lambda],#]MonomialSymmetricFunction[#]&,IntegerPartitions[Total[\[Lambda]]]]]


(* ::Input::Initialization:: *)
ChangeSymmetricBasis[exp_,MonomialSymmetricFunction]:=Expand[exp/.f:(ElementarySymmetricFunction[i_]|CompleteSymmetricFunction[i_]|PowerSymmetricFunction[i_]|SchurFunction[i_]):>ChangeSymmetricBasis0[f,MonomialSymmetricFunction]]


(* ::Input::Initialization:: *)
ChangeSymmetricBasis0[f:ElementarySymmetricFunction[\[Lambda]_],SchurFunction]:=
Total[Map[KostkaCoefficient[TransposePartition[#],\[Lambda]]*SchurFunction[#]&,IntegerPartitions[Total[\[Lambda]]]]]

(*ChangeSymmetricBasis0[f:ElementarySymmetricFunction[{i_}],SchurFunction]:=SchurFunction[ConstantArray[1,i]]
ChangeSymmetricBasis0[f:ElementarySymmetricFunction[\[Mu]:{i_,k__}],SchurFunction]:=Fold[SchurFunctionExpand[#1*#2]&,Map[SchurFunction[ConstantArray[1,#]]&,\[Mu]]]*)

ChangeSymmetricBasis0[f:CompleteSymmetricFunction[\[Lambda]_],SchurFunction]:=
Plus@@Map[KostkaCoefficient[#,\[Lambda]]*SchurFunction[#]&,IntegerPartitions[Total[\[Lambda]]]]

(*ChangeSymmetricBasis0[f:CompleteSymmetricFunction[{i_}],SchurFunction]:=SchurFunction[{i}]
ChangeSymmetricBasis0[f:CompleteSymmetricFunction[\[Mu]:{i_,k__}],SchurFunction]:=Fold[SchurFunctionExpand[#1*#2]&,Map[SchurFunction[{#}]&,\[Mu]]]*)

ChangeSymmetricBasis0[f:PowerSymmetricFunction[\[Lambda]_],SchurFunction]:=With[{n=Plus@@\[Lambda]},
Plus@@Map[CharacterSymmetricGroup[#,\[Lambda]]*SchurFunction[#]&,IntegerPartitions[n]]
]

(*ChangeSymmetricBasis0[f:MonomialSymmetricFunction[\[Lambda]_List],SchurFunction]:=ChangeSymmetricBasis0[f,SchurFunction]=
Total[Map[InverseKostkaCoefficient[\[Lambda],#]SchurFunction[#]&,IntegerPartitions[Total[\[Lambda]]]]]*)

ChangeSymmetricBasis0[f:MonomialSymmetricFunction[\[Lambda]_List],SchurFunction]:=
Total[Map[InverseKostkaCoefficient[\[Lambda],#]SchurFunction[#]&,IntegerPartitions[Total[\[Lambda]]]]]



(* ::Input::Initialization:: *)
ChangeSymmetricBasis[exp_,SchurFunction]:=Expand[exp/.f:(ElementarySymmetricFunction[\[Mu]_List]|CompleteSymmetricFunction[\[Mu]_List]|PowerSymmetricFunction[\[Mu]_List]|MonomialSymmetricFunction[\[Mu]_List]):>ChangeSymmetricBasis0[f,SchurFunction]]


(* ::Input::Initialization:: *)
(********* Schur functions expansion ***)
SchurFunctionExpand0[Times[i___Integer,x_SchurFunction,y__SchurFunction]]:=Plus@@Map[i*#[[2]]*SchurFunction[#[[1]]]&,Tally[LittlewoodRichardsonRule[Sequence@@x,Sequence@@Map[Sequence@@#&,List[y]]]]]
SchurFunctionExpand0[Power[x_SchurFunction,2]]:=Plus@@Map[#[[2]]*SchurFunction[#[[1]]]&,Tally[LittlewoodRichardsonRule[Sequence@@ConstantArray[Sequence@@x,2]]]]
SchurFunctionExpand0[Power[x_SchurFunction,n_]]/;n>2:=Fold[SchurFunctionExpand0/@Expand[Times[#1,#2]]&,Join[{SchurFunctionExpand0[Power[x,2]]},ConstantArray[x,n-2]]]
SchurFunctionExpand[exp_]:=FixedPoint[Expand[#]/.z:Times[i___Integer,x_SchurFunction,y__SchurFunction]|Power[x_SchurFunction,n_]:>SchurFunctionExpand0[z]&,exp]

(********* Monomial symmetric functions expansion ***)

MonomialSymmetricFunctionExpand0[Times[i___Integer,x_MonomialSymmetricFunction,y__MonomialSymmetricFunction]]:=Plus@@Map[i*#[[2]]*MonomialSymmetricFunction[#[[1]]]&,Tally[MonomialProductRule[Sequence@@x,Sequence@@Map[Sequence@@#&,List[y]]]]]
MonomialSymmetricFunctionExpand0[Power[x_MonomialSymmetricFunction,2]]:=Plus@@Map[#[[2]]*MonomialSymmetricFunction[#[[1]]]&,Tally[MonomialProductRule[Sequence@@ConstantArray[Sequence@@x,2]]]]
MonomialSymmetricFunctionExpand0[Power[x_MonomialSymmetricFunction,n_]]/;n>2:=Fold[MonomialSymmetricFunctionExpand0/@Expand[Times[#1,#2]]&,Join[{MonomialSymmetricFunctionExpand0[Power[x,2]]},ConstantArray[x,n-2]]]
MonomialSymmetricFunctionExpand[exp_]:=FixedPoint[Expand[#]/.z:Times[i___Integer,x_MonomialSymmetricFunction,y__MonomialSymmetricFunction]|Power[x_MonomialSymmetricFunction,n_]:>MonomialSymmetricFunctionExpand0[z]&,exp]


(* ::Input::Initialization:: *)
(******** Automatic multiplication of Elementary, complete, and power sum symmetric functions **)
ElementarySymmetricFunction/:ElementarySymmetricFunction[i_Integer]:=ElementarySymmetricFunction[{i}]
CompleteSymmetricFunction/:CompleteSymmetricFunction[i_Integer]:=CompleteSymmetricFunction[{i}]
PowerSymmetricFunction/:PowerSymmetricFunction[i_Integer]:=PowerSymmetricFunction[{i}]

ElementarySymmetricFunction/:Times[ElementarySymmetricFunction[i_],ElementarySymmetricFunction[j_]]:=ElementarySymmetricFunction[PartitionJoin[j,i]]
CompleteSymmetricFunction/:Times[CompleteSymmetricFunction[i_],CompleteSymmetricFunction[j_]]:=CompleteSymmetricFunction[PartitionJoin[j,i]]
PowerSymmetricFunction/:Times[PowerSymmetricFunction[i_],PowerSymmetricFunction[j_]]:=PowerSymmetricFunction[PartitionJoin[j,i]]

ElementarySymmetricFunction/:Power[ElementarySymmetricFunction[i_],n_]:=ElementarySymmetricFunction[ReverseSort[Flatten[ConstantArray[i,n]]]]
CompleteSymmetricFunction/:Power[CompleteSymmetricFunction[i_],n_]:=CompleteSymmetricFunction[ReverseSort[Flatten[ConstantArray[i,n]]]]
PowerSymmetricFunction/:Power[PowerSymmetricFunction[i_],n_]:=PowerSymmetricFunction[ReverseSort[Flatten[ConstantArray[i,n]]]]


(* ::Input::Initialization:: *)
(*SymmetricFunctionExpand0[x_]:=x
(*SymmetricFunctionExpand0[z:Times[x_ElementarySymmetricFunction,y__ElementarySymmetricFunction]]:=ElementarySymmetricFunctionExpand[z]
SymmetricFunctionExpand0[z:Times[x_CompleteSymmetricFunction,y__CompleteSymmetricFunction]]:=CompleteSymmetricFunctionExpand[z]
SymmetricFunctionExpand0[z:Times[x_PowerSymmetricFunction,y__PowerSymmetricFunction]]:=PowerSymmetricFunctionExpand[z]*)
SymmetricFunctionExpand0[z:Times[i___Integer,x_MonomialSymmetricFunction,y__MonomialSymmetricFunction]]:=i*MonomialSymmetricFunctionExpand[Times[x,y]]
SymmetricFunctionExpand0[z:Times[i___Integer,x_SchurFunction,y__SchurFunction]]:=i*SchurFunctionExpand[Times[x,y]]

(*SymmetricFunctionExpand0[z:Power[x_ElementarySymmetricFunction,n_]]:=ElementarySymmetricFunctionExpand[z]
SymmetricFunctionExpand0[z:Power[x_CompleteSymmetricFunction,n_]]:=CompleteSymmetricFunctionExpand[z]
SymmetricFunctionExpand0[z:Power[x_PowerSymmetricFunction,n_]]:=PowerSymmetricFunctionExpand[z]*)
SymmetricFunctionExpand0[z:Power[x_MonomialSymmetricFunction,n_]]:=MonomialSymmetricFunctionExpand[z]
SymmetricFunctionExpand0[z:Power[x_SchurFunction,n_]]:=SchurFunctionExpand[z]*)


(* ::Input::Initialization:: *)
(****** The main driver  ***********)
SymmetricFunctionExpand[exp_]:=SchurFunctionExpand[MonomialSymmetricFunctionExpand[exp]]


(* ::Input::Initialization:: *)
(*** Implementation by Per Alexandersson : not use anymore ***)

(*(* This is a private helper function, for utilizing memoization. *)
(* TODO-MAKE IT KEEP TRACK OF DUPLICATES AUTOMATICALLY, and reuse? *)
monomialProductsRule[lam_List, {}] := {lam};
monomialProductsRule[lam_List, mut_List] := monomialProductsRule[lam, mut] = Module[{addToPartition, done, lamp, new},
	addToPartition[gam_List, {k_, m_Integer}] := With[{ll = Length@gam},
				Table[{k + gam[[ii]], gam[[Complement[Range@ll, ii]]]}, {ii, Subsets[Range[ll], {m}]}]];
	Join @@ Table[{done, lamp} = new; Join[done, #]& /@ monomialProductsRule[lamp, Rest@mut], {new, addToPartition[lam, First@mut]}]
];
dim[p_List,n_] := Times @@ (Last[#]! & /@ Tally[PadRight[p, n]]);
monomialProductRule[\[Lambda]_,\[Mu]_,n_Integer]:=Module[{p\[Lambda]=PadRight[\[Lambda], n],p\[Mu]= PadRight[\[Mu], n],products,dimCoeff },
	(* Here, decide which partition has fewest permutations? *)
	If[(Multinomial@@(Last /@ Tally[p\[Lambda]])) > (Multinomial@@(Last /@ Tally[\[Mu]])),
		dimCoeff = dim[\[Lambda],n],
		{p\[Lambda],p\[Mu]} = {p\[Mu],p\[Lambda]};
		dimCoeff = dim[\[Mu],n]];
(*Print[DeleteCases[Tally[p\[Mu]],0]];*)
products = monomialProductsRule[p\[Lambda],Tally[DeleteCases[p\[Mu],0]]];
Flatten[Table[ReverseSort[DeleteCases[#1,0]],(dim[#1,n]/dimCoeff)*#2] & @@@ (Tally@products),1]
]
monomialProductRule[\[Lambda]_,\[Mu]_]:=monomialProductRule[\[Lambda],\[Mu],Length[\[Lambda]]+Length[\[Mu]]]
monomialProductRuleMap[list1_,list2_]:=Flatten[Map[monomialProductRule[#,list2]&,list1],1]
monomialProductRule[\[Lambda]_,\[Mu]_,\[Nu]s__]:=Fold[monomialProductRuleMap,monomialProductRule[\[Lambda],\[Mu]],{\[Nu]s}];*)

StabilizerSize[\[Mu]_,n_] :=(n-Length[\[Mu]])!* Times@@Map[Length[#]!&,Split[\[Mu]]];
MonomialProductRule[\[Lambda]_,\[Mu]_,n_Integer]:=With[{p\[Lambda]=PadRight[\[Lambda], n],p\[Mu]= PadRight[\[Mu], n],stabCoeff\[Lambda]=StabilizerSize[\[Lambda],n],stabCoeff\[Mu]=StabilizerSize[\[Mu],n]},
	(* Here, decide which partition has fewest permutations? *)
	If[stabCoeff\[Mu]>=stabCoeff\[Lambda],
Flatten[ConstantArray[DeleteCases[#1,0],(StabilizerSize[#1,n]*#2/stabCoeff\[Lambda])]&@@@Tally@Map[ReverseSort[p\[Lambda]+#]&,Permutations[p\[Mu]]],1],
Flatten[ConstantArray[DeleteCases[#1,0],(StabilizerSize[#1,n]*#2/stabCoeff\[Mu])]&@@@Tally@Map[ReverseSort[p\[Mu]+#]&,Permutations[p\[Lambda]]],1]]
]
MonomialProductRule[\[Lambda]_,\[Mu]_]:=MonomialProductRule[\[Lambda],\[Mu],Length[\[Lambda]]+Length[\[Mu]]]
MonomialProductRuleMap[list1_,list2_]:=Flatten[Map[ConstantArray[MonomialProductRule[#[[1]],list2],#[[2]]]&,Tally[list1]],2]
MonomialProductRule[\[Lambda]_,\[Mu]_,\[Nu]s__]:=Fold[MonomialProductRuleMap,MonomialProductRule[\[Lambda],\[Mu]],{\[Nu]s}];


(* ::Input::Initialization:: *)
(****** Automatic multiplication of m(k)*m\[Mu] and m(1^k)m\[Mu] needed for a fast change of basis e->m and p->m *****)
MonomialSymmetricFunction/:Times[MonomialSymmetricFunction[{i_}],MonomialSymmetricFunction[{j_}]]/;i!=j:=MonomialSymmetricFunction[{i+j}]+MonomialSymmetricFunction[ReverseSort[{i,j}]];
MonomialSymmetricFunction/:Times[MonomialSymmetricFunction[{i_}],MonomialSymmetricFunction[{i_}]]:=MonomialSymmetricFunction[{2*i}]+2MonomialSymmetricFunction[{i,i}];
MonomialSymmetricFunction/:Power[MonomialSymmetricFunction[{i_}],n_]:=Total[Map[Multinomial[Sequence@@#]*MonomialSymmetricFunction[i*#]&,IntegerPartitions[n]]]
MonomialSymmetricFunction/:Times[MonomialSymmetricFunction[{i_}],MonomialSymmetricFunction[\[Mu]:{j_,k__}]]:=With[{partitions=DeleteDuplicates[Map[ReverseSort[MapAt[#1+i&,\[Mu],#]]&,Range[Length[\[Mu]]]]]},
Total[Map[Count[#,Sequence@@mycomplementSmall[#,\[Mu]]]*MonomialSymmetricFunction[#]&,partitions]]+(1+Count[\[Mu],i])MonomialSymmetricFunction[ReverseSort[Join[{i},\[Mu]]]]
]
MonomialSymmetricFunction/:Times[MonomialSymmetricFunction[\[Mu]:{1,i__:1}],MonomialSymmetricFunction[\[Nu]_List]]:=Module[{n=Length[\[Mu]]+Length[\[Nu]],p\[Mu],p\[Nu],partitions,sym\[Nu]=Times@@(Tally[\[Nu]][[All,2]]),StabCoeff\[Nu]},
StabCoeff\[Nu]=StabilizerSize[\[Nu],n];
p\[Mu]=PadRight[\[Mu],n];
p\[Nu]=PadRight[\[Nu],n];
partitions=Tally@Map[ReverseSort[p\[Nu]+#]&,Permutations[p\[Mu]]];
Total[(StabilizerSize[#1,n]*#2/StabCoeff\[Nu])*MonomialSymmetricFunction[DeleteCases[#1,0]]&@@@partitions]
]


(* ::Input::Initialization:: *)
LittlewoodRichardsonRule[{},\[Lambda]_]:={\[Lambda]}
LittlewoodRichardsonRule[\[Lambda]_,{}]:={\[Lambda]}
LittlewoodRichardsonRule[list1_,list2_]/;list1[[1]]==1||Length[list1]==1:=PieriRule[list1,list2];
LittlewoodRichardsonRule[list1_,list2_]/;list2[[1]]==1||Length[list2]==1:=PieriRule[list2,list1];


(* ::Input::Initialization:: *)
PieriRule[\[Mu]:{1,i___},\[Mu]_]:=With[{l\[Mu]=Length[\[Mu]]},IntegerPartitions[2*l\[Mu],{l\[Mu],2*l\[Mu]},{1,2}]];
PieriRule[\[Mu]:{1,i___},\[Lambda]:{1,j___}]:=With[{n=Length[\[Mu]]+Length[\[Lambda]]},IntegerPartitions[n,{Max[Length[\[Mu]],Length[\[Lambda]]],n},{1,2}]];
PieriRule[\[Mu]:{1,k___},\[Lambda]_]:=Module[{l\[Lambda]=Length[\[Lambda]],l\[Mu]=Length[\[Mu]],p\[Lambda]},
p\[Lambda]=PadRight[\[Lambda],l\[Lambda]+l\[Mu]];
If[l\[Lambda]<=l\[Mu],
DeleteDuplicates[Flatten[Map[With[{listperm=Permutations[Join[ConstantArray[1,#],ConstantArray[0,l\[Lambda]-#]]],n1=#},(*Print[listperm];*)Map[Drop[ReverseSort[p\[Lambda]+Join[#,Join[ConstantArray[1,l\[Mu]-n1],ConstantArray[0,n1]]]],-n1]&,listperm]]&,Range[0,l\[Lambda]]],1]],
DeleteDuplicates[Flatten[Map[With[{listperm=Permutations[Join[ConstantArray[1,#],ConstantArray[0,l\[Lambda]-#]]],n1=#},(*Print[listperm];*)Map[Drop[ReverseSort[p\[Lambda]+Join[#,Join[ConstantArray[1,l\[Mu]-n1],ConstantArray[0,n1]]]],-n1]&,listperm]]&,Range[0,l\[Mu]]],1]]
]
];
PieriRule[\[Mu]:{i_},\[Lambda]_]:=TransposePartition/@PieriRule[TransposePartition[\[Mu]],TransposePartition[\[Lambda]]]

(*SchurExpand[Times[SchurFunction[\[Mu]:{1,k___}],SchurFunction[\[Lambda]_]]]:=Total[SchurFunction/@PartitionsPieri[\[Mu],\[Lambda]]]
SchurExpand[Times[SchurFunction[\[Mu]:{i_}],SchurFunction[\[Lambda]:{j_,k___}]]]:=Total[SchurFunction/@TransposePartitionsPieri[TransposePartition[\[Mu]],TransposePartition[\[Lambda]]]];
SchurExpand[Power[SchurFunction[{i_}],2]]:=Total[SchurFunction/@IntegerPartitions[2*i,{1,2}]];
SchurExpand[Power[SchurFunction[{i_}],n_]]/;n>2:=Fold[SchurExpand[Times[#1,#2]]&,Join[{SchurExpand[Power[SchurFunction[{i}],2]]},Table[SchurFunction[{i}],n-2]]]
SchurExpand[Power[SchurFunction[\[Mu]:{1,k___}],2]]:=With[{l\[Mu]=Length[\[Mu]]},Total[SchurFunction/@IntegerPartitions[2*l\[Mu],{l\[Mu],2*l\[Mu]},{1,2}]]]
SchurExpand[Power[SchurFunction[\[Mu]:{1,k___}],n_]]/;n>2:=Fold[SchurExpand[Times[#1,#2]]&,Join[{SchurExpand[Power[SchurFunction[{1,k}],2]]},Table[SchurFunction[{1,k}],n-2]]]*)
(*SchurFunction/:Times[SchurFunction[\[Mu]:{1,k___}],SchurFunction[\[Lambda]_]]:=Total[SchurFunction/@PartitionsPieri[\[Mu],\[Lambda]]]
SchurFunction/:Times[SchurFunction[\[Mu]:{i_}],SchurFunction[\[Lambda]:{j_,k___}]]:=Total[SchurFunction/@TransposePartitionsPieri[TransposePartition[\[Mu]],TransposePartition[\[Lambda]]]];
SchurFunction/:Power[SchurFunction[{i_}],2]:=Total[SchurFunction/@IntegerPartitions[2*i,{1,2}] ]
SchurFunction/:Power[SchurFunction[{i_}],n_]/;n>2:=Fold[Expand[Times[#1,#2]]&,Join[{Power[SchurFunction[{i}],2]},Table[SchurFunction[{i}],n-2]]]
SchurFunction/:Power[SchurFunction[\[Mu]:{1,k___}],2]:=With[{l\[Mu]=Length[\[Mu]]},Total[SchurFunction/@IntegerPartitions[2*l\[Mu],{l\[Mu],2*l\[Mu]},{1,2}]]]
SchurFunction/:Power[SchurFunction[\[Mu]:{1,k___}],n_]/;n>2:=Fold[Expand[Times[#1,#2]]&,Join[{Power[SchurFunction[{1,k}],2]},Table[SchurFunction[{1,k}],n-2]]]*)


(* ::Input::Initialization:: *)
SymmetricFunctionBasis::usage = "SymmetricFunctionBasis is an option for Plethysm.";
Options[Plethysm]:={SymmetricFunctionBasis->Automatic}
Plethysm[k_?NumericQ,g_?SymmetricFunctionQ,basis:(Alternatives@@$SymmetricFunctions)]:=k;
Plethysm[i_?NumericQ*f_,g_,basis:(Alternatives@@$SymmetricFunctions)]:=Expand[i*Plethysm[f,g,basis]]
Plethysm[f_?SymmetricFunctionQ*g_?SymmetricFunctionQ,h_?SymmetricFunctionQ,basis:(Alternatives@@$SymmetricFunctions)]:=Plethysm[f,h,basis]*Plethysm[g,h,basis]
Plethysm[exp_Plus,f_,basis:(Alternatives@@$SymmetricFunctions)]:=Map[Plethysm[#,f,basis]&,exp]


(* ::Input::Initialization:: *)
SymmetricFunctionExpressionQ[exp_]:=MemberQ[Map[FreeQ[exp,#]&,$SymmetricFunctions],False]
SymmetricFunctionOfExpression[exp_]:=Pick[$SymmetricFunctions,Map[!FreeQ[exp,#]&,$SymmetricFunctions]]


(* ::Input::Initialization:: *)
Plethysm[g:PowerSymmetricFunction[\[Mu]_],k_?NumericQ,PowerSymmetricFunction]:=k^Length[\[Mu]]
Plethysm[g:PowerSymmetricFunction[{i_}],exp_Plus,PowerSymmetricFunction]:=Map[Plethysm[g,#,PowerSymmetricFunction]&,exp]
Plethysm[g:PowerSymmetricFunction[{i_}],exp_Times,PowerSymmetricFunction]:=Map[Plethysm[g,#,PowerSymmetricFunction]&,exp]
Plethysm[PowerSymmetricFunction[\[Mu]_],PowerSymmetricFunction[{i_}],PowerSymmetricFunction]:=PowerSymmetricFunction[i*\[Mu]]
Plethysm[PowerSymmetricFunction[{i_}],PowerSymmetricFunction[\[Lambda]_],PowerSymmetricFunction]:=PowerSymmetricFunction[i*\[Lambda]]
Plethysm[PowerSymmetricFunction[\[Mu]_],exp_Plus,PowerSymmetricFunction]:=Expand[Product[Plethysm[PowerSymmetricFunction[{\[Mu][[i]]}],exp,PowerSymmetricFunction],{i,1,Length[\[Mu]]}]]
Plethysm[PowerSymmetricFunction[\[Mu]_],PowerSymmetricFunction[\[Lambda]_],PowerSymmetricFunction]:=PowerSymmetricFunction[ReverseSort[Flatten[Map[#*\[Mu]&,\[Lambda]],1]]]
Plethysm[PowerSymmetricFunction[\[Mu]_],k_?NumericQ*f_PowerSymmetricFunction,PowerSymmetricFunction]:=k^Length[\[Mu]]*Plethysm[PowerSymmetricFunction[\[Mu]],f,PowerSymmetricFunction];


(* ::Input::Initialization:: *)
(******* Main function *****)
Plethysm[f_,g_,options:OptionsPattern[]]:=Module[{pf=ChangeSymmetricBasis[f,PowerSymmetricFunction],pg=ChangeSymmetricBasis[g,PowerSymmetricFunction],basis,basisf},
{basis}=OptionValue[{Plethysm},{options},{SymmetricFunctionBasis}];
If[basis===Automatic,
basisf=First@SymmetricFunctionOfExpression[f];
ChangeSymmetricBasis[Plethysm[pf,pg,PowerSymmetricFunction],basisf],
ChangeSymmetricBasis[Plethysm[pf,pg,PowerSymmetricFunction],basis]
]
]


(* ::Input::Initialization:: *)
(******* multiplicity form of a partition ******)
PartitionMultiplicities[{}]:={};
PartitionMultiplicities[\[Mu]_]:=Count[\[Mu],#]&/@Range[Max[\[Mu]]]


(***** Symmetry factor - Stability index ****)
ZCoefficient[{}]:=1;
ZCoefficient[\[Mu]_List] := Times@@Map[#[[1]]^Length[#]*Length[#]!&,Split[\[Mu]]];


(* ::Input::Initialization:: *)
(** Conjugate partition ie transposed partition **)
TransposePartition[{}]={};
TransposePartition[\[Mu]_]:=Length/@Flatten[Range/@\[Mu],{2}]


(* ::Input::Initialization:: *)
(********* Order functions for partitions **********)
IncludedPartitionQ[\[Lambda]_,\[Mu]_]/;Length[\[Mu]]>Length[\[Lambda]]:=False
IncludedPartitionQ[\[Lambda]_,\[Mu]_]:=Min[\[Lambda]-PadRight[\[Mu],Length[\[Lambda]]]]>=0
PartitionDominatesQ[\[Lambda]_,\[Mu]_]:=With[{l=Min[Length[\[Lambda]],Length[\[Mu]]]},And@@Thread[GreaterEqual[FoldList[Plus,\[Lambda][[;;l]]],FoldList[Plus,\[Mu][[;;l]]]]]]


(* ::Input::Initialization:: *)
(******* Needed for computation of the Kostka numbers *******)
PartitionN[\[Mu]_] := Sum[(i-1)*\[Mu][[i]], {i, Length[\[Mu]]}];


(******* Joining to partitions *******)
PartitionJoin[a_] := a
PartitionJoin[a_, b_] := ReverseSort[Flatten[{a, b}]];
PartitionJoin[a_, b_,c__] := ReverseSort[Flatten[{a, b,c}]];


(* ::Input::Initialization:: *)
KostkaCoefficient[\[Lambda]_,\[Lambda]_]:=1
KostkaCoefficient[\[Lambda]_,\[Mu]_]/;!PartitionDominatesQ[\[Lambda],\[Mu]]:=0
(****************** Number of Young tableau of shape \[Lambda] and weight \[Mu] : not used anymore ******************)

(*KostkaCoefficient[\[Lambda]_, w_] := Module[{isEdgeQ,
	partitionLevels, directedEdges, mid,mu,wAcc=Accumulate@w,ssytPaths,graph},
	mu = PadRight[{},Length@\[Lambda]];
	mid = Table[IntegerPartitions[Tr[mu] + wi, {Length@\[Lambda]}, Range[0, Max@\[Lambda]]],{wi,Most@wAcc}];
	partitionLevels = Join[{{mu}}, mid, {{\[Lambda]}}];
	
	(* If partitions interlace, with p above q in GT-pattern *)
	isEdgeQ[p_List,q_List]:=And[Min[p-q]>=0 && Min[ q[[;;-2]] - p[[2;;]] ]>=0];
	(* We add lvl to partition also, to allow for weight being 0 *)
directedEdges = Join@@Table[Join@@Outer[If[isEdgeQ[#2,#1], DirectedEdge[{#1,lvl-1}, {#2,lvl}],Nothing]&,partitionLevels[[lvl-1]], partitionLevels[[lvl]], 1]
	,{lvl,2,Length[partitionLevels]}];
	graph=Graph[directedEdges];
	Length@FindPath[graph, {mu,1}, {\[Lambda],Length[w]+1}, Infinity, All]
];*)

(* This is based on Macdonald, p.327, and is extremely fast. Note that we use memoization *)
KostkaCoefficient[\[Lambda]_, \[Mu]_] := KostkaCoefficient[\[Lambda], \[Mu]]=Together[With[
	{n = Length@\[Mu],ee = Function[{ll},PartitionN[TransposePartition[ll]] - PartitionN[ll]]},
	1/(ee[\[Lambda]]-ee[\[Mu]])*Sum[
		With[{mu2 =Sort[DeleteCases[ReplacePart[\[Mu], {i -> \[Mu][[i]] + r, j ->\[Mu][[j]] - r}], 0],Greater]},
			(\[Mu][[i]] -\[Mu][[j]] + 2 r) KostkaCoefficient[\[Lambda], mu2]], {i, n},{j, i + 1, n},{r,\[Mu][[j]]}]
]];

(*KostkaCoefficient[lam_List, mu_List] :=Together[With[
	{n = Length@mu,ee = Function[{ll},PartitionN[TransposePartition[ll]] - PartitionN[ll]]},
	1/(ee[lam]-ee[mu])*Sum[
		With[{mu2 =Sort[DeleteCases[ReplacePart[mu, {i -> mu[[i]] + r, j -> mu[[j]] - r}], 0],Greater]},
			(mu[[i]] - mu[[j]] + 2 r) KostkaCoefficient[lam, mu2]], {i, n},{j, i + 1, n},{r, mu[[j]]}]
]];*)


(* This code is comparably very fast. *)
InverseKostkaCoefficient[\[Mu]_, \[Mu]_]:=1;
InverseKostkaCoefficient[\[Lambda]_, \[Mu]_]:= (0 /; PartitionDominatesQ[\[Mu],\[Lambda]]);
InverseKostkaCoefficient[\[Lambda]_, \[Mu]_]:= inverseKostkaHelper[
Reverse[\[Lambda]], Reverse[\[Mu]]];
(* The convention in https://doi.org/10.1080/03081089008817966
uses partitions with parts ordered increasingly, which makes notation easier.*)
inverseKostkaHelper[\[Mu]_, \[Mu]_] := 1;
inverseKostkaHelper[\[Lambda]_, {i_}] := Boole[\[Lambda]==={i}];
inverseKostkaHelper[\[Lambda]_, \[Mu]_] := inverseKostkaHelper[\[Lambda], \[Mu]] = If[Max[\[Mu]]==1, 
(* Special case if mu=11...1 *)
With[{n=Tr[\[Lambda]]}, (-1)^(n - Length[\[Lambda]]) Multinomial @@ (PartitionMultiplicities@\[Lambda])],
	Sum[With[{pos = Position[\[Lambda], \[Mu][[j]] + j - 1, 1, 1]},If[pos == {}, 0
				, (-1)^(j-1)*inverseKostkaHelper[(* Remove a part equal to p *)ReplacePart[\[Lambda], pos -> Nothing]
					,(* Subtract 1 from the first j-1 entries, and drop jth entry *)
						MapAt[If[#==1,Nothing,#-1]&, Drop[\[Mu], {j}], List/@Range[j-1]]]]
		], {j, Length[\[Mu]]}]
];



(* Special case for hook shapes. *)
CharacterSymmetricGroup[\[Lambda]_, {k_}] := Which[\[Lambda] == {k}, 1, \[Lambda][[2]] > 1, 0,True, (-1)^(k - \[Lambda][[1]])];
(* Special case when all parts of mu=1, has closed form. *)
CharacterSymmetricGroup[\[Lambda]_, \[Mu]:{1,j__}]:= DimOfIrrepSn[\[Lambda]];
CharacterSymmetricGroup[\[Lambda]_]:= DimOfIrrepSn[\[Lambda]];
(* Branching thm, James-Kerber *)
CharacterSymmetricGroup[\[Lambda]_, {\[Mu]s__, 1}] := CharacterSymmetricGroup[\[Lambda], {\[Mu]s, 1}]= With[{\[Mu] = {\[Mu]s},l\[Lambda]=Length[\[Lambda]]},
	Sum[If[i == l\[Lambda] || \[Lambda][[i]] > \[Lambda][[i + 1]],CharacterSymmetricGroup[If[\[Lambda][[i]]==1,Drop[\[Lambda],{i}],MapAt[(# - 1)&, \[Lambda], i]], \[Mu]], 0], {i, l\[Lambda]}]
];

(* https://arxiv.org/pdf/1712.08023.pdf *)
CharacterSymmetricGroup[\[Lambda]_List, {\[Mu]s___, m_Integer}] := CharacterSymmetricGroup[\[Lambda], {\[Mu]s, m}] =
With[{\[Mu] = {\[Mu]s},l\[Lambda]=Length[\[Lambda]]},
	1/(m - 1)*(
		Sum[If[i == l\[Lambda]|| \[Lambda][[i]] > \[Lambda][[i + 1]],Times[(\[Lambda][[i]] - i),
					CharacterSymmetricGroup[If[\[Lambda][[i]]==1,Drop[\[Lambda],{i}],MapAt[(# - 1)&, \[Lambda], i]],Append[\[Mu], m - 1]]], 0], {i, l\[Lambda]}]
		-
		Sum[If[ j == 1 || \[Mu][[j - 1]] > \[Mu][[j]],Times[Count[Append[\[Mu],m-1],  \[Mu][[j]]],\[Mu][[j]],
		CharacterSymmetricGroup[\[Lambda],Append[MapAt[# + 1 &, \[Mu], j], m - 1]]], 0],{j, Length[\[Mu]]}])
];


(* ::Input::Initialization:: *)
(*Binary representation of a given partition*)
BinaryPartition[partition_]:=Block[{l={}},Flatten[Map[Append[l,Flatten[{ConstantArray[1,#],0}]]&,Differences[Prepend[Reverse[partition],0]]]]];


(* ::Input::Initialization:: *)
(*Returns a conjugate partition*)
ConjugatePartition[part_]:=Block[{CountPositive,conj,f},CountPositive[x_]:=Length[Select[x,#>0&]];
conj={};
f=(AppendTo[conj,CountPositive[#]];#-1)&;
Nest[f,part,part[[1]]];
(*return*)conj];


(* ::Input::Initialization:: *)
(*Character of symmetric group at identity permutation,see\cite[page 57]{james1981representation} Implementation of hook-length formula*)CharacterAtId[partition_]:=Block[{conjPart},conjPart=ConjugatePartition[partition];
(*return*)Total[partition]!/Product[partition[[i]]-j+conjPart[[j]]-i+1,{i,1,Length[partition]},{j,1,partition[[i]]}]];
(*Implementation of determinant version:(Total[partition])!Det[Table[1/(partition[[i]]+j-i)!,{i,1,Length[partition]},{j,1,Length[partition]}]]*)

(*Murnaghan-Nakayama algorithm for computing a character of symmetric group Subscript[S,n],algorithm MNInner from\cite{bernstein2004computational}*)
MurnaghanNakayama[Rr_,mm_,tt_:1]:=MurnaghanNakayama[Rr,mm,tt]=Block[{BP,i,j,R=Rr,m=mm,t=tt,c=0,s=1,temp},If[t>Length[m],c=1,(*else*)c=0;s=1;
For[j=1,j<Min[m[[t]],Length[R]],j++,If[R[[j]]==0,s=-s];];
For[i=1,i<Length[R]-m[[t]]+1,i++,If[R[[i]]!=R[[i+m[[t]]-1]],s=-s];
If[i+m[[t]]<=Length[R],If[R[[i]]==1&&R[[i+m[[t]]]]==0,temp=R[[i]];
R[[i]]=R[[i+m[[t]]]];
R[[i+m[[t]]]]=temp;
c=c+s*MurnaghanNakayama[R,m,t+1];
temp=R[[i]];
R[[i]]=R[[i+m[[t]]]];
R[[i+m[[t]]]]=temp;];];];];
(*return*)c];
CharacterSymmetricGroup2[partition_,type_:"id"]:=If[type==="id",CharacterAtId[partition],(*else*)MurnaghanNakayama[BinaryPartition[partition],type]];


(* ::Input::Initialization:: *)
PartitionTruncate[p_]:=DeleteCases[p,0];
PartitionTruncate[p_]:=If[p=={}||p[[-1]]!=0,p,PartitionTruncate[Take[p,Length[p]-1]]];
PartitionLength[p_]:=Length[PartitionTruncate[p]]


(* ::Input::Initialization:: *)
PartitionEval[p_,i_]:=If[i<=Length[p],p[[i]],0]
PartitionValidate[p_]:=If[p=={}||And@@Table[p[[i]]>=p[[i+1]],{i,1,Length[p]-1}],True,Print["Partition values must descend"];False]


(* ::Input::Initialization:: *)
LRWord[t_]:=Join@@Table[Join@@Table[Table[j-1,{PartitionEval[t[[j]],i]-PartitionEval[t[[j-1]],i]}],{j,Length[t],2,-1}],{i,1,Length[t[[-1]]]}]


(* ::Input::Initialization:: *)
(*TestWord[LRWord[t]] returns true if the tableau t is a lattice partition in Macdonald's sense*)TestWord[w_]:=And@@Table[If[w[[i]]>1,Length[Select[Take[w,i],#==w[[i]]-1&]]>=Length[Select[Take[w,i],#==w[[i]]&]],True],{i,1,Length[w]}]


(* ::Input::Initialization:: *)
(*PartitionCompare[p_,q_]:=(PartitionLength[p]<=PartitionLength[q]&&(And@@Table[p[[i]]<=q[[i]],{i,1,PartitionLength[p]}]))*)


(* ::Input::Initialization:: *)
PartitionStrictlyCompare[p_,q_]:=(IncludedPartitionQ[q,p]&&PartitionLength[q]<=PartitionLength[p]+1&&(And@@Table[p[[i]]==q[[i]]||q[[i+1]]<p[[i]]+1,{i,1,PartitionLength[q]-1}]))


(* ::Input::Initialization:: *)
SubstractPartitions[p_,q_]:=With[{lp=Length[p],lq=Length[q]},If[lp==lq,p-q,If[lp>lq,p-PadRight[q,lp],PadRight[p,lq]-q]]]
PartitionOrder[p_,q_]:=If[PartitionTruncate[p]==PartitionTruncate[q],0,If[First[Select[SubstractPartitions[p,q],#!=0&]]>0,1,-1]];


(* ::Input::Initialization:: *)
AppendStrictTableau[t_,n_]:=(Append[t,#]&/@Select[IntegerPartitions[(Plus@@t[[-1]])+n],PartitionStrictlyCompare[t[[-1]],#]&])
AppendStrictTableauList[l_,n_]:=Join@@(AppendStrictTableau[#,n]&/@l)


(* ::Input::Initialization:: *)
(*LRCandidates generates all tableaux of the form {p_0,p_1,p_2,...,p_k},where p_0=p and Length[p_i]-Length[p_{i-1}]=q_i.*)
LRCandidates[p_,q_]:=Fold[AppendStrictTableauList,{{p}},q];
(*LRSequence generates the sequence of tableaux appearing during the process of the Littlewood-Richardson rule.*)
LRSequence[p_,q_]:=Select[LRCandidates[PartitionTruncate[p],PartitionTruncate[q]],TestWord[LRWord[#]]&](**)


(* ::Input::Initialization:: *)
(* LittlewoodRichardsonRule returns a list of partitions resulting from the multiplication of partitions p and q. Some partitions may appear more than once in the list.Each occurs with its correct multiplicity.The list is in reverse lexicographic order. *)


(* ::Input::Initialization:: *)
LittlewoodRichardsonRule[p_,q_]:=If[Length[p]>Length[q],Sort[Last/@LRSequence[p,q],PartitionOrder[#1,#2]>=0&],Sort[Last/@LRSequence[q,p],PartitionOrder[#1,#2]>=0&]]

LittlewoodRichardsonRuleMap[list1_,list2_]:=Flatten[Map[ConstantArray[LittlewoodRichardsonRule[#[[1]],list2],#[[2]]]&,Tally[list1]],2]
LittlewoodRichardsonRule[list1_,list2_,list3__]:=Sort[Fold[LittlewoodRichardsonRuleMap,LittlewoodRichardsonRule[list1,list2],{list3}]]


(* ::Input::Initialization:: *)
LittlewoodRichardsonCoefficient0[\[Mu]_,\[Lambda]_,\[Nu]_]:=Count[LittlewoodRichardsonRule[\[Lambda],\[Nu]],\[Mu]]


(* ::Input::Initialization:: *)
AppendStrictTableauConstraint[t_,n_,ncolumn_,nrow_]:=(Append[t,#]&/@Select[IntegerPartitions[(Plus@@t[[-1]])+n,nrow,Range[ncolumn]],PartitionStrictlyCompare[t[[-1]],#]&])
AppendStrictTableauListConstraint[l_,n_,ncolumn_,nrow_]:=Join@@(AppendStrictTableauConstraint[#,n,ncolumn,nrow]&/@l)


(* ::Input::Initialization:: *)
LRCandidatesConstraint[\[Mu]_,\[Nu]_,ncolumn_,nrow_]:=Fold[AppendStrictTableauListConstraint[#1,#2,ncolumn,nrow]&,{{\[Mu]}},\[Nu]];
LRSequenceConstraint[\[Mu]_,\[Nu]_,ncolumn_,nrow_]:=Select[LRCandidatesConstraint[PartitionTruncate[\[Mu]],PartitionTruncate[\[Nu]],ncolumn,nrow],TestWord[LRWord[#]]&]


(* ::Input::Initialization:: *)
LittlewoodRichardsonRuleConstraint[\[Mu]_,\[Nu]_,ncolumn_,nrow_]:=Last/@LRSequenceConstraint[\[Mu],\[Nu],ncolumn,nrow]


(* ::Input::Initialization:: *)
InverseLittlewoodRichardsonRule[\[Mu]_,\[Nu]_]:=Module[{n=Length[\[Mu]],mu1=\[Mu][[1]],mubar=Reverse[\[Mu][[1]]-\[Mu]],lr},
lr=LittlewoodRichardsonRuleConstraint[mubar,\[Nu],mu1,n];
Map[Reverse[DeleteCases[#,0]]&,(mu1-PadRight[#,n]&/@lr)]
]
(*************** This function is actually faster than the new equivalent function (see section below) that would be Map[WordToWeight,Values@LRTableaux[\[Mu],\[Nu]]] for n<12 so we keep it this way for the moment  ****)


(* ::Input::Initialization:: *)
WeightToWord[\[Nu]_]:=Flatten[Map[ConstantArray[#,\[Nu][[#]]]&,Range[Length[\[Nu]]]]];


(* ::Input::Initialization:: *)
(****************  Delete elements from a list which appear in another list ****)
mycomplementSmall[list1_,list2_]:=Fold[DeleteCases[##,1,1]&,list1,list2] (*** For small lists ***)
(*** For big lists : Mr. Wizard solution  https://mathematica.stackexchange.com/questions/18100/removing-elements-from-a-list-which-appear-in-another-list ***)
mycomplementBig[a_,b_]:=Module[{c,o,x},c=Join[b,a];
o=Ordering[c];
x=1-2 UnitStep[-1-Length[b]+o];
x=FoldList[Max[#,0]+#2&,x];
x[[o]]=x;
Pick[c,x,-1]];


(* ::Input::Initialization:: *)
(*{i,j} sits in ith row and jth column *) 
boxlist[\[Mu]_]:=Flatten[#,1]&@Table[{b,a},{b,1,Length[\[Mu]]},{a,1,\[Mu][[b]]}]
boxlist[\[Mu]_,\[Lambda]_]:=Complement[boxlist[\[Mu]],boxlist[\[Lambda]]]
RLTBSort[list_]:=Sort[list,First[#1]<First[#2]||(First[#1]== First[#2]&&Last[#1]>Last[#2])&]
(*Given a word, put that in the skew diagram \[Lambda]-\[Nu] from right to left (NOT left to right), top to bottom. Boxes which do not have numbers are not listed. Return as an association*)
(*Functions with arguments \[Mu],\[Nu] are for computations with fixed \[Mu],\[Nu], Functions with \[Mu] are computations with fixed \[Mu], varying \[Nu].*)
PutWordInShape[\[Mu]_,\[Lambda]_,word_]:=AssociationThread[Take[#,Length[word]]&@(RLTBSort@boxlist[\[Mu],\[Lambda]])-> word]
PutWordInShape[\[Mu]_,word_]:=AssociationThread[Take[#,Length[word]]&@(RLTBSort@boxlist[\[Mu]])-> word]


(* ::Input::Initialization:: *)
(* Given a lattice word, returns the possible next numbers which keeps lattice-ness *)
PossibleNextLatticeNumbers[list_]:=If[list==={},{1},#]&@With[{listminusdiff=Join[{1},-1*Differences[Last/@Tally[list]],{1}]},
First/@Select[Thread[List[Range[Length[listminusdiff]],listminusdiff]],Last[#]>0&]
];

(*** list2 is the composition of a certain partition \[Nu] see : LRTableauWords *****)
PossibleNextLatticeNumbers[word_,list2_]:=If[word==={},{1},#]&@With[{listminusdiff=Join[{1},-1*Differences[Last/@Tally[word]],{1}]},
First/@Select[Thread[List[Range[Length[listminusdiff]],listminusdiff]],Last[#]>0&&MemberQ[list2,First[#]]&]
];


(* ::Input::Initialization:: *)
(*Given a word, the number in the above and right box of the first top-right empty box (read the skew-shape for right to left top to bottom )*)
NumberAboveRightNextBox[\[Mu]_,word_]:=Module[{boxnumassoc=PutWordInShape[\[Mu],word],nextbox=(RLTBSort@boxlist[\[Mu]])[[Length[word]+1]],tryA0,tryL0,tryA,tryL},
tryA0=boxnumassoc[[Key[(nextbox+{-1,0})]]];
tryL0=boxnumassoc[[Key[(nextbox+{0,1})]]];
tryA=If[MissingQ[tryA0],0,tryA0];
tryL=If[MissingQ[tryL0],Infinity,tryL0];
{tryA,tryL}
]
NumberAboveRightNextBox[\[Mu]_,\[Lambda]_,word_]:=Module[{boxnumassoc=PutWordInShape[\[Mu],\[Lambda],word],nextbox=(RLTBSort@boxlist[\[Mu],\[Lambda]])[[Length[word]+1]],tryA0,tryL0,tryA,tryL},
tryA0=boxnumassoc[[Key[(nextbox+{-1,0})]]];
tryL0=boxnumassoc[[Key[(nextbox+{0,1})]]];
tryA=If[MissingQ[tryA0],0,tryA0];
tryL=If[MissingQ[tryL0],Infinity,tryL0];
{tryA,tryL}
]


(* ::Input::Initialization:: *)
(* (To vary \[Nu],) the next number should be 0 if the present box have 0 and not leftmost, 
can be zero if the box above the present box has 0, or the box is in the upmost row. (0 means the box is skewed away.)
Non zero numbers are inserted so that the obtained tableau is a LR tableu.*)
PossibleNextNumbers[\[Mu]_,word_]:=Module[{NARNB=NumberAboveRightNextBox[\[Mu],word],PNLN=PossibleNextLatticeNumbers[Select[word,#!= 0&]]},
If[NARNB[[2]]==0,{0},#]&@If[NARNB[[1]]==0,{0}~Join~#,#]&@
Select[PNLN,NARNB[[1]]<#<= NARNB[[2]]&]]

PossibleNextNumbers[\[Mu]_,\[Nu]_,word_]:=Module[{NARNB=NumberAboveRightNextBox[\[Mu],\[Nu],word],PNLN=PossibleNextLatticeNumbers[word]},
Select[PNLN,NARNB[[1]]<#<= NARNB[[2]]&]]

PossibleNextNumbers[\[Mu]_,\[Lambda]_,list_,word_]:=Module[{NARNB=NumberAboveRightNextBox[\[Mu],\[Lambda],word],PNLN=PossibleNextLatticeNumbers[word,list]},
Select[PNLN,NARNB[[1]]<#<= NARNB[[2]]&]]


(* ::Input::Initialization:: *)
PossibleNextWordList[\[Mu]_,word_]:=Module[{PNNs=PossibleNextNumbers[\[Mu],word]},
Append[word,#]&/@PNNs]
PossibleNextWordList[\[Mu]_,\[Lambda]_,word_]:=Module[{PNNs=PossibleNextNumbers[\[Mu],\[Lambda],word]},
Append[word,#]&/@PNNs]
(*PossibleNextWordList[\[Mu]_,\[Lambda]_,\[Nu]_,word_]:=Module[{PNNs=PossibleNextNumbers[\[Mu],\[Lambda],\[Nu],word]},
Append[word,#]&/@PNNs]*)
PossibleNextWordList[\[Mu]_,\[Lambda]_,list_,word_]:=Module[{PNNs=PossibleNextNumbers[\[Mu],\[Lambda],list,word]},
Append[word,#]&/@PNNs]


(* ::Input::Initialization:: *)
LRTableauWords[\[Mu]_]:=NestWhile[Flatten[(PossibleNextWordList[\[Mu],#1]&)/@#,1]&,{{}},Length[#[[1]]]<  Total[\[Mu]]&]
LRTableauWords[\[Mu]_,\[Lambda]_]:=NestWhile[Flatten[(PossibleNextWordList[\[Mu],\[Lambda],#1]&)/@#,1]&,{{}},Length[#[[1]]]<Total[\[Mu]]-Total[\[Lambda]]&]
(********** Possible optimization do-able **********)
LRTableauWords[\[Mu]_,\[Lambda]_,\[Nu]_]:=Module[{ctab=WeightToWord[\[Nu]],n=Total[\[Mu]]-Total[\[Lambda]],words={{}}},
While[Length[words[[1]]]<n,
words=Flatten[Map[PossibleNextWordList[\[Mu],\[Lambda],mycomplementSmall[ctab,#1],#1]&,#],1]&@words;
If[words==={},Break[]];
];
words
];


(* ::Input::Initialization:: *)
(**** If \[Lambda] is included in \[Mu] *****)
IncludedQ[\[Mu]_,\[Lambda]_]:=With[{L=Max[Length[\[Mu]],Length[\[Lambda]]]},And@@(Thread[PadRight[\[Mu],L]>= PadRight[\[Lambda],L]])]
(************** LRTableaux[\[Mu],\[Lambda],\[Nu]] returns the semi-standard tableaux of the shape \[Mu]/\[Lambda] and composition (aka content) \[Nu]. ***)
LittlewoodRichardsonTableaux[\[Mu]_,\[Lambda]_,\[Nu]_]:=If[IncludedQ[\[Mu],\[Lambda]]&&IncludedQ[\[Mu],\[Nu]],PutWordInShape[\[Mu],\[Lambda],#]&/@LRTableauWords[\[Mu],\[Lambda],\[Nu]],{}];
LittlewoodRichardsonTableaux[\[Mu]_,\[Lambda]_]:=PutWordInShape[\[Mu],\[Lambda],#]&/@LRTableauWords[\[Mu],\[Lambda]];
LittlewoodRichardsonTableaux[\[Mu]_]:=PutWordInShape[\[Mu],#]&/@LRTableauWords[\[Mu]]
WordToWeight[word_]:=Last/@SortBy[#,First]&@Tally[word];
LittlewoodRichardsonCoefficient[\[Mu]_,\[Lambda]_]/;IncludedQ[\[Mu],\[Lambda]]:=Association@(Tally@(WordToWeight/@LRTableauWords[\[Mu],\[Lambda]])/.{{a_,b_Integer}:>(a-> b)} )
LittlewoodRichardsonCoefficient[\[Mu]_,\[Lambda]_]/;!IncludedQ[\[Mu],\[Lambda]]:=<|{}-> 0|>
SkewedShape[tableauassoc_]:=Last/@(Tally@(First/@Keys@Select[tableauassoc,#== 0&]))
LittlewoodRichardsonCoefficient[\[Mu]_]:=Association@((Tally@({SkewedShape[#],WordToWeight[Values[Select[#,#1!= 0&]]]}&/@LittlewoodRichardsonTableaux[\[Mu]]))/.{{a_,b_Integer}:>(a-> b)} )
LittlewoodRichardsonCoefficient[\[Mu]_,\[Lambda]_,\[Nu]_]:=If[IncludedQ[\[Mu],\[Lambda]]&&IncludedQ[\[Mu],\[Nu]]&&Plus@@\[Lambda]+Plus@@\[Nu]==Plus@@\[Mu],If[Plus@@\[Nu]<Plus@@\[Lambda],Length[LRTableauWords[\[Mu],\[Lambda],\[Nu]]],Length[LRTableauWords[\[Mu],\[Nu],\[Lambda]]]],0]


(****** More than two tensor product of irrep (may need optimization) *****)
LittlewoodRichardsonCoefficient[\[Lambda]_,\[Mu]1_,\[Mu]2_,\[Mu]3_]:=With[{n\[Mu]1=Tr[\[Mu]1],n\[Mu]2=Tr[\[Mu]2]},
Plus@@Map[LittlewoodRichardsonCoefficient[#,\[Mu]1,\[Mu]2]*LittlewoodRichardsonCoefficient[\[Lambda],#,\[Mu]3]&,IntegerPartitions[n\[Mu]1+n\[Mu]2]]
]
LittlewoodRichardsonCoefficient[\[Lambda]_,\[Mu]1_,\[Mu]2_,\[Mu]3_,\[Mu]4_]:=With[{n\[Lambda]=Tr[\[Lambda]],n\[Mu]1=Tr[\[Mu]1],n\[Mu]2=Tr[\[Mu]2],n\[Mu]3=Tr[\[Mu]3]},
Plus@@Map[LittlewoodRichardsonCoefficient[#,\[Mu]1,\[Mu]2,\[Mu]3]*LittlewoodRichardsonCoefficient[\[Lambda],#,\[Mu]4]&,IntegerPartitions[n\[Mu]1+n\[Mu]2+n\[Mu]3]]
]
LittlewoodRichardsonCoefficient[\[Lambda]_,\[Mu]1_,\[Mu]2_,\[Mu]3_,\[Mu]4_,\[Mu]s__]:=Count[LittlewoodRichardsonRule[\[Mu]1,\[Mu]2,\[Mu]3,\[Mu]4,\[Mu]s],\[Lambda]]


(* ::Input::Initialization:: *)
NewellLittlewoodCoefficient[\[Lambda]_,\[Mu]_,\[Nu]_]:=With[{n\[Lambda]=Plus@@\[Lambda],n\[Mu]=Plus@@\[Mu],n\[Nu]=Plus@@\[Nu]},
If[OddQ[n\[Lambda]+n\[Mu]+n\[Nu]],Return[0]];
If[n\[Nu]+n\[Mu]<n\[Lambda]||n\[Lambda]+n\[Mu]<n\[Nu]||n\[Lambda]+n\[Nu]<n\[Mu],Return[0]];
(* Important optimization : remember that NewellLittlewoodCoefficient is invariant under S3 *)
If[n\[Mu]+n\[Nu]==n\[Lambda],Return[LittlewoodRichardsonCoefficient[\[Lambda],\[Mu],\[Nu]]],If[n\[Mu]+n\[Lambda]==n\[Nu],Return[LittlewoodRichardsonCoefficient[\[Nu],\[Lambda],\[Mu]]],If[n\[Nu]+n\[Lambda]==n\[Mu],Return[LittlewoodRichardsonCoefficient[\[Mu],\[Nu],\[Lambda]]]]]];
Module[{\[Tau]s=Flatten[Map[IntegerPartitions[#]&,Range[0,Max[n\[Mu],n\[Nu]]]],1],\[Xi]s=Flatten[Map[IntegerPartitions[#]&,Range[0,Max[n\[Lambda],n\[Mu]]]],1],\[Eta]s=Flatten[Map[IntegerPartitions[#]&,Range[0,Max[n\[Nu],n\[Lambda]]]],1],temp={}},
Do[If[Tr[\[Tau]s[[k]]]+Tr[\[Xi]s[[j]]]==n\[Mu]&&Tr[\[Tau]s[[k]]]+Tr[\[Eta]s[[i]]]==n\[Nu]&&Tr[\[Xi]s[[j]]]+Tr[\[Eta]s[[i]]]==n\[Lambda],AppendTo[temp,LittlewoodRichardsonCoefficient[\[Mu],\[Tau]s[[k]],\[Xi]s[[j]]]*LittlewoodRichardsonCoefficient[\[Nu],\[Tau]s[[k]],\[Eta]s[[i]]]*LittlewoodRichardsonCoefficient[\[Lambda],\[Xi]s[[j]],\[Eta]s[[i]]]]],{i,1,Length[\[Eta]s]},{j,1,Length[\[Xi]s]},{k,1,Length[\[Tau]s]}];
(* result *)
Plus@@temp
]]

NewellLittlewoodRule[\[Mu]_,\[Nu]_]:=Module[{n=Plus@@\[Mu]+Plus@@\[Nu],partitions},
If[OddQ[n],
partitions=Flatten[IntegerPartitions[#]&/@Range[1,Plus@@\[Mu]+Plus@@\[Nu],2],1],
partitions=Flatten[IntegerPartitions[#]&/@Range[0,Plus@@\[Mu]+Plus@@\[Nu],2],1]];
Map[If[NewellLittlewoodCoefficient[#,\[Mu],\[Nu]]==0,Nothing,Sequence@@ConstantArray[#,NewellLittlewoodCoefficient[#,\[Mu],\[Nu]]]]&,partitions]
]

NewellLittlewoodRuleMap[list1_,list2_]:=Flatten[Map[ConstantArray[NewellLittlewoodRule[#[[1]],list2],#[[2]]]&,Tally[list1]],2]
NewellLittlewoodRule[list1_,list2_,list3__]:=SortBy[Fold[NewellLittlewoodRuleMap,NewellLittlewoodRule[list1,list2],{list3}],Tr[#]&]


(* ::Input::Initialization:: *)
PackedQ=Developer`PackedArrayQ;
ToPack=Developer`ToPackedArray;
myInvolutions[list_List]:=Block[{data,A,n,g},n=Length[list];
A=ToPack[UpperTriangularize[{Range[3,n]}[[ConstantArray[1,n-1]]]]];
A[[2;;]]+=ToPack[LowerTriangularize[{Range[2,n-1]}[[ConstantArray[1,n-2]]]]];
g[2,{{}}]=ToPack[{{{1,2}}}];
g[n_,data_]:=With[{m=Length[data]},Join[Transpose[{{ConstantArray[1,{(n-1) m}],Flatten[Table[ConstantArray[i,{m}],{i,2,n}]]}},{2,3,1}],ArrayReshape[A[[1;;(n-1),Flatten[data]]],{(n-1) m,Quotient[n-2,2],2}],2]];
data={{}};
Join@@Join[{{list}},Table[data=g[2 i,data];
getPermutationLists[list,ArrayReshape[Subsets[Range[n],{2 i}][[All,Flatten[data]]],{Binomial[n,2 i] Length[data],Sequence@@Rest[Dimensions[data]]}]],{i,1,Quotient[n,2]}]]];
getPermutationLists=Compile[{{ran,_Integer,1},{idx,_Integer,2}},Block[{a=ran,i,j,k,x},Do[i=Compile`GetElement[idx,k,1];
j=Compile`GetElement[idx,k,2];
x=Compile`GetElement[a,i];
a[[i]]=Compile`GetElement[a,j];
a[[j]]=x,{k,1,Length[idx]}];
a],CompilationTarget->"C",RuntimeAttributes->{Listable},Parallelization->True,RuntimeOptions->"Speed"];


(* ::Input::Initialization:: *)
bsearchMax=Compile[{{list,_Complex,1},{elem,_Real}},Block[{n0=1,n1=Length[list],m=0},While[n0<=n1,m=Floor[(n0+n1)/2];
If[list[[m]]==elem,While[m>=n0&&list[[m]]==elem,m--];Return[m+1]];
If[list[[m]]<elem,n0=m+1,n1=m-1]];
If[list[[m]]>elem,m,m+1]],RuntimeAttributes->{Listable},CompilationTarget->"C"];


(* ::Input::Initialization:: *)
RawInsertIntoTableau[e_Integer,P1_]:=Block[{item=e,row=0,col,P=P1},
If[Length@P==0,Return[{{e}},Block]];
While[row<Length[P],row++;
If[Last[P[[row]]]<=item,AppendTo[P[[row]],item];
Return[P,Block]];
col=bsearchMax[P[[row]],item];
{item,P[[row,col]]}={P[[row,col]],item};];
Append[P,{item}]
];
InvolutionToTableau[perm_List]:=Fold[RawInsertIntoTableau[#2,#1]&,Join[{{}},perm]];
StandardTableaux[1]:={{{1}}};
StandardTableaux[2]:={{{1,2}},{{1},{2}}};
StandardTableaux[n_Integer]:=Sort[InvolutionToTableau/@myInvolutions[Range[n]],Length@First[#1]>Length@First[#2]&];


(* ::Input::Initialization:: *)
StandardTableaux[\[Lambda]_List]:=SemiStandardTableaux[{\[Lambda], {}},ConstantArray[1,Tr[\[Lambda]]]]


(* If only max-box is provided, then produce all with partition weight *)
SemiStandardTableaux[{\[Lambda]_List, \[Mu]_List}, max_Integer]:=With[{weights=IntegerPartitions[Tr[\[Lambda]]-Tr[\[Mu]], max]},
	Join@@Table[SemiStandardTableaux[{\[Lambda],\[Mu]},w],{w,weights}]
];
(* The default max-entry ensures that all SYTs of the shape appears *)
SemiStandardTableaux[{\[Lambda]_List, \[Mu]_List}]:=SemiStandardTableaux[{\[Lambda],\[Mu]},Tr[\[Lambda]]-Tr[\[Mu]]];
(* Weight must match up, otherwise empty set *)
SemiStandardTableaux[{\[Lambda]_List, muIn_List}, w_List]/;(Tr[\[Lambda]]-Tr[muIn]-Tr[w]!=0):={};

pathToSSYT[pathIn_]:=Module[{path,nrows,m,e,r},
	{m,nrows} = Dimensions[pathIn];
	path = Prepend[pathIn,ConstantArray[0,nrows]];
	Table[Join@@Table[ConstantArray[If[e-1==0,"\[Cross]",e-1], path[[e+1,r]] - path[[e,r]]],{e,m}],{r,nrows}]
];

SemiStandardTableaux[{lambdaIn_List, muIn_List}, w_List] := Module[{isEdgeQ,
	partitionLevels, directedEdges, mid,lam=lambdaIn,mu,wAcc=Accumulate@w,ssytPaths,q,graph},
	mu = PadRight[muIn,Length@lam];
	mid = Table[IntegerPartitions[Tr@mu + wi, {Length@lam}, Range[0, Max@lam]],{wi,Most@wAcc}];
	partitionLevels = Join[{{mu}}, mid, {{lam}}];
	
	(* If partitions interlace, with p above q in GT-pattern *)
	isEdgeQ[p_List,q_List]:=And[Min[p-q]>=0 && Min[ q[[;;-2]] - p[[2;;]] ]>=0];
	(* We add lvl to partition also, to allow for weight being 0 *)
	directedEdges = Join@@Table[Join@@Outer[If[isEdgeQ[#2,#1], DirectedEdge[{#1,lvl-1}, {#2,lvl}],Nothing]&,partitionLevels[[lvl-1]], partitionLevels[[lvl]], 1]
	,{lvl,2,Length[partitionLevels]}];
	graph=Graph[directedEdges];
	
	ssytPaths = If[Or[!MemberQ[VertexList[graph],{mu,1}],!MemberQ[VertexList[graph],{lam,Length[w]+1}]],{},
		(* Find all paths in the graph. *)
		FindPath[graph, {mu,1}, {lam,Length[w]+1}, Infinity, All]
	];
	Map[pathToSSYT[First/@#]&, ssytPaths]
];
SemiStandardTableaux[\[Lambda]_List,\[Rho]_List]/;!PartitionDominatesQ[\[Lambda],\[Rho]]:={}
SemiStandardTableaux[\[Lambda]_List,\[Rho]_List]:=SemiStandardTableaux[{\[Lambda],{}},\[Rho]]


(* ::Input::Initialization:: *)
TableauForm0[l:{{__}..},opts:OptionsPattern[{Alignment->{Center,Center},FrameStyle->Thin,Grid}]]:=Grid[l,Frame->{None,None,Thread@Rule[Flatten[Function[{a,b},{a,#}&/@b]@@@Transpose[{Range@Length@l,Range/@Length/@l}],1],True]},Alignment->OptionValue[Alignment],FrameStyle->OptionValue[FrameStyle]];
sqrow[x_,n_]:=Table[Rectangle[{x,-i},{x+1,-(i+1)}],{i,n}];
(*TableauForm[tab_Bracelets]:=TableauForm[Sequence@@tab];*)
TableauForm[exp_]:=exp/.l_List|l_Bracelets:>TableauForm0[l];


(* ::Input::Initialization:: *)
plotEmptySet[contourSize_]:=With[{pr=PlotRange[Graphics[{Thickness[0.12547051442910914`], FilledCurve[{{{1, 4, 3}, {1, 3, 3}, {0, 1, 0}, {0, 1, 0}, {1, 3, 3}, {1, 3, 3}, {0, 1, 0}, {1, 3, 3}, {1, 3, 3}, {1, 3, 3}, {1, 3, 3}, {0, 1, 0}, {1, 3, 3}, {1, 3, 3}, {0, 1, 0}, {1, 3, 3}, {1, 3, 3}}, {{0, 2, 0}, {1, 3, 3}, {1, 3, 3}, {1, 3, 3}, {1, 3, 3}}, {{1, 4, 3}, {1, 3, 3}, {0, 1, 0}, {1, 3, 3}, {1, 3, 3}}}, {CompressedData["
1:eJxTTMoPSmViYGDQAmIQXXX/xy1jbQmHGhD9WsphR7BVxP90SYf93fuaTJzl
HM6AQI+kg/K1R8EMMopwvjEIXFaC8+csUt7557iKQ/Dbyx9nNEo6NPP6r5/S
qgE1TxSqTsvhINhcMYcZM4FAUseBAQQaxBzc99fKWrQj+FvMfxxKOaXj8MA1
3nGWoJiDqc3eoGmMulBzROH8NgV21TNXROD8vohuf8YNIg7+FyfG/Dus45AG
BiIOxw87rc2004G457iww/QJ/FVm2toOX/Z93JpuJuxwfNeOXrYAbYd+sH5B
iPxqbYevIPlr/HB+Otg8Ljj/Bu9tsVQzFoeM/A+tJ79oObysfZx9fg2DwymQ
fXKaDuult+meevPT/gTIfAN1h21eGyzm/PxhPwOkn1sVzoeFJ4wfzinWbhyv
COe7rzm6nOGHpEOTeC1r5jEWB5HKSSVnU8Qg7p/GBHF3gRCcr/5J5eWsl4JQ
cWaHN2253UbVgg4xqhEy52pY4PwXIPe+YYXzIf5hc2gFhesXQQcNkDkn2SDx
yijs0Ayyn40DEq5qog4Fy0s2/PPnctgJCtd2EYh5OrxQeRGH/yCwnx/Oh4S3
KJwPjq8AcYj5CyUc0NMjANtbJCo=
"], {{4.83906, 13.2391}, {2.7515599999999996`, 6.134379999999999}, {2.35938, 6.956250000000001}, {2.35938, 8.42344}, {2.35938, 9.556249999999999}, {2.35938, 10.521900000000002`}, {2.35938, 11.343800000000002`}, {2.52656, 12.1063}, {2.7515599999999996`, 13.215600000000002`}, {3.4437499999999996`, 13.5734}, {3.97969, 13.5734}, {4.218749999999999, 13.5734}, {4.52813, 13.501599999999996`}, {4.83906, 13.2391}}, {{5.44688, 7.00469}, {5.231249999999999, 5.75313}, {4.6000000000000005`, 5.300000000000001}, {3.9687499999999996`, 5.300000000000001}, {3.6937499999999996`, 5.300000000000001}, {3.407810000000001, 5.395309999999999}, {3.12188, 5.645309999999999}, {5.195309999999999, 12.762499999999998`}, {5.58906, 12.0703}, {5.58906, 10.6875}, {5.58906, 9.556249999999999}, {5.58906, 8.68594}, {5.58906, 7.8031299999999995`}, {5.44688, 7.00469}}}]}, AspectRatio -> Automatic, BaselinePosition -> Scaled[0.32439307852814453`], ImageSize -> {11., 22.142857142857146`}, PlotRange -> {{0., 7.970000000000001}, {0., 16.34}}]]},Show[Graphics[{White,Rectangle[{0-contourSize,0.-contourSize},{pr[[1,2]]+contourSize,pr[[2,2]]+contourSize}]}],Graphics[{Thickness[0.12547051442910914`], FilledCurve[{{{1, 4, 3}, {1, 3, 3}, {0, 1, 0}, {0, 1, 0}, {1, 3, 3}, {1, 3, 3}, {0, 1, 0}, {1, 3, 3}, {1, 3, 3}, {1, 3, 3}, {1, 3, 3}, {0, 1, 0}, {1, 3, 3}, {1, 3, 3}, {0, 1, 0}, {1, 3, 3}, {1, 3, 3}}, {{0, 2, 0}, {1, 3, 3}, {1, 3, 3}, {1, 3, 3}, {1, 3, 3}}, {{1, 4, 3}, {1, 3, 3}, {0, 1, 0}, {1, 3, 3}, {1, 3, 3}}}, {CompressedData["
1:eJxTTMoPSmViYGDQAmIQXXX/xy1jbQmHGhD9WsphR7BVxP90SYf93fuaTJzl
HM6AQI+kg/K1R8EMMopwvjEIXFaC8+csUt7557iKQ/Dbyx9nNEo6NPP6r5/S
qgE1TxSqTsvhINhcMYcZM4FAUseBAQQaxBzc99fKWrQj+FvMfxxKOaXj8MA1
3nGWoJiDqc3eoGmMulBzROH8NgV21TNXROD8vohuf8YNIg7+FyfG/Dus45AG
BiIOxw87rc2004G457iww/QJ/FVm2toOX/Z93JpuJuxwfNeOXrYAbYd+sH5B
iPxqbYevIPlr/HB+Otg8Ljj/Bu9tsVQzFoeM/A+tJ79oObysfZx9fg2DwymQ
fXKaDuult+meevPT/gTIfAN1h21eGyzm/PxhPwOkn1sVzoeFJ4wfzinWbhyv
COe7rzm6nOGHpEOTeC1r5jEWB5HKSSVnU8Qg7p/GBHF3gRCcr/5J5eWsl4JQ
cWaHN2253UbVgg4xqhEy52pY4PwXIPe+YYXzIf5hc2gFhesXQQcNkDkn2SDx
yijs0Ayyn40DEq5qog4Fy0s2/PPnctgJCtd2EYh5OrxQeRGH/yCwnx/Oh4S3
KJwPjq8AcYj5CyUc0NMjANtbJCo=
"], {{4.83906, 13.2391}, {2.7515599999999996`, 6.134379999999999}, {2.35938, 6.956250000000001}, {2.35938, 8.42344}, {2.35938, 9.556249999999999}, {2.35938, 10.521900000000002`}, {2.35938, 11.343800000000002`}, {2.52656, 12.1063}, {2.7515599999999996`, 13.215600000000002`}, {3.4437499999999996`, 13.5734}, {3.97969, 13.5734}, {4.218749999999999, 13.5734}, {4.52813, 13.501599999999996`}, {4.83906, 13.2391}}, {{5.44688, 7.00469}, {5.231249999999999, 5.75313}, {4.6000000000000005`, 5.300000000000001}, {3.9687499999999996`, 5.300000000000001}, {3.6937499999999996`, 5.300000000000001}, {3.407810000000001, 5.395309999999999}, {3.12188, 5.645309999999999}, {5.195309999999999, 12.762499999999998`}, {5.58906, 12.0703}, {5.58906, 10.6875}, {5.58906, 9.556249999999999}, {5.58906, 8.68594}, {5.58906, 7.8031299999999995`}, {5.44688, 7.00469}}}]}, AspectRatio -> Automatic, BaselinePosition -> Scaled[0.32439307852814453`], ImageSize -> {11., 22.142857142857146`}, PlotRange -> {{0., 7.970000000000001}, {0., 16.34}}],ImageSize->20]]
Origin[\[Mu]_]:=With[{n=Plus@@\[Mu]},{n/2-0.5*\[Mu][[1]],-n/2+0.5*Length[\[Mu]]}]
sqrow[\[Mu]_,nc_,l_]:=Map[Rectangle[{#-1+Origin[\[Mu]][[1]],-l}]&,Range[nc]]
rectangles[\[Mu]_]:=Table[sqrow[\[Mu],\[Mu][[i]],i-Origin[\[Mu]][[2]]],{i,Length[\[Mu]]}];
TableauForm[\[Mu]_,contourSize_]/;\[Mu]==={0}||\[Mu]==={}:=plotEmptySet[contourSize];
TableauForm[\[Mu]_List?(Depth[#]==2&),contourSize_]:=With[{n=Plus@@\[Mu]},Graphics[{White,Rectangle[{0-contourSize,-n-contourSize},{n+contourSize,0+contourSize}],White,EdgeForm[Thickness[0.01]],rectangles[\[Mu]]},ImageSize->Scaled[n*0.01]]];
TableauForm[\[Mu]_List?(Depth[#]==2&)]:=TableauForm[\[Mu],0.1];


(* ::Input::Initialization:: *)
RowWord[stdTab_]:=Flatten[Reverse[stdTab]]
RowWordToTab[list_]:=Reverse[Split[list,Less]]
RemoveLetter[stdTab_,n_]:=RowWordToTab[DeleteCases[RowWord[stdTab],n]]

BratteliPathSn[stdyoungtab_]:=With[{n=Length[Flatten[stdyoungtab]]},Map[Length,Reverse@FoldList[RemoveLetter,stdyoungtab,Reverse@Range[2,n]],{2}]];
BratteliDiagramSn0[n_]:=BratteliPathSn/@StandardTableaux[n];
Options[BratteliDiagramSn]:={Output->List,ImageSize->Automatic,Thickness->0.001,VertexSize->0.03,AspectRatio->1}
BratteliDiagramSn[n_,options:OptionsPattern[]]:=Module[{bratteli=BratteliDiagramSn0[n],output,imagesize,thickness,vsize,aspectratio},
{output,imagesize,thickness,vsize,aspectratio}=OptionValue[{BratteliDiagramSn},{options},{Output,ImageSize,Thickness,VertexSize,AspectRatio}];
If[output===List,
Return[BratteliDiagramSn0[n],Module]
];
If[output===Graph,
Return[BratteliGraphSn[bratteli,n,ImageSize->imagesize,Thickness->thickness,VertexSize->vsize,AspectRatio->aspectratio],Module]
]
]


(* ::Input::Initialization:: *)
numberOfvertexSn[n_]:=Plus@@(Map[PartitionsP[#]&,Range[n]])+1;
partitionsRuleVerticesSn[n_,nvertices_]:=Thread[Rule[Flatten[Join[{{{}}},IntegerPartitions[#]&/@Range[n]],1],Range[nvertices]]];


(* ::Input::Initialization:: *)
xcoordinates0[n0_,step_]:=((Range[PartitionsP[n0]]-1)*step-((PartitionsP[n0]-1)*(step)/2));
HorizontaleStep[n0_,scale_]:=4*n0/(n0*scale);
xcoordinates[n_,scale_]:=Join[{{0}},Map[xcoordinates0[#,HorizontaleStep[#,scale]]&,Range[n]]];


(* ::Input::Initialization:: *)
VerticalStep[n0_,scale_]:=n0/(scale);
ycoordinates0[n0_,scale_]:=Plus@@Map[VerticalStep[#,scale]&,Range[n0]];
ycoordinates[n_,scale_]:=Join[{{0}},Map[{-ycoordinates0[#,scale]-ycoordinates0[1,scale]}&,Range[n]]];


(* ::Input::Initialization:: *)
mergecoordinates[list1_,list2_]:=Map[{#,list2}&,list1]
vertexcoordinatesSn[1,horizontalscale_,verticalscale_]:=Flatten/@MapThread[{#1,#2}&,{xcoordinates[1,horizontalscale],ycoordinates[1,verticalscale]}]
vertexcoordinatesSn[n_,horizontalscale_,verticalscale_]:=Flatten[Inner[mergecoordinates,xcoordinates[n,horizontalscale],ycoordinates[n,verticalscale],List],2]


(* ::Input::Initialization:: *)
edgesBratteliSn[list1_,list2_,n_]:=Join[{UndirectedEdge[1,2]},DeleteDuplicates[Flatten[Map[UndirectedEdge@@@Partition[#,2,1]&,list1/.list2],1]]]
verticesSizeSn[list_,scale_]:=Map[#[[2]]->{"Scaled",Plus@@#[[1]]*scale}&,list]


(* ::Input::Initialization:: *)
Options[BratteliGraphSn]:={ImageSize->Automatic,Thickness->0.001,VertexSize->0.03,AspectRatio->1}
BratteliGraphSn[bratteli_List,n_Integer,options:OptionsPattern[]]:=Module[{coordinates,partitionsToVertex,imagesize,thickness,vertexsize,aspectratio,edges,vscale},
{imagesize,thickness,vertexsize,aspectratio}=OptionValue[{BratteliGraphSn},{options},{ImageSize,Thickness,VertexSize,AspectRatio}];
With[{nvertices=numberOfvertexSn[n]},
vscale=aspectratio;
coordinates=vertexcoordinatesSn[n,vertexsize,vertexsize*vscale];
partitionsToVertex=partitionsRuleVerticesSn[n,nvertices];
edges=edgesBratteliSn[bratteli,partitionsToVertex,n];
Graph[Range[nvertices],edges,VertexCoordinates ->coordinates,EdgeStyle ->{Directive[Opacity[1], Thickness[thickness],Black]},VertexShape->Map[#[[2]]->TableauForm[#[[1]],0.3]&,partitionsToVertex],VertexSize->Join[{1->{"Scaled",1.5*vertexsize},2->{"Scaled",1.3*vertexsize}},verticesSizeSn[Rest@Rest@partitionsToVertex,vertexsize]],VertexStyle->Join[Map[#->Black&,Range[nvertices]]],ImageSize->imagesize]]]
BratteliGraphSn[bratteli_List,options:OptionsPattern[]]:=BratteliGraphSn[bratteli,Plus@@Last[bratteli[[1]]],options];


(* ::Input::Initialization:: *)
TransposePartition[partition_List]:=Length/@Flatten[Range/@partition,{2}];
TransposePartition[{}]:={};


(* ::Input::Initialization:: *)
TransposeTableau[tab_]:=Flatten[tab,{2}];


(* ::Input::Initialization:: *)
(**** Hook Length formula and dimension of irreducible representation of Subscript[S, n] ****)
HookLengthProduct[partition_]:=Times@@Flatten[Flatten[Reverse/@Range/@TransposePartition[partition],{2}]+Reverse/@Range/@partition-1];
DimOfIrrepSn[partition_List]:=(Plus@@partition)!/HookLengthProduct[partition];


(* ::Input::Initialization:: *)
NumberOfTableaux[partition_List]:=DimOfIrrepSn[partition]
NumberOfTableaux[n_Integer]:=Plus@@(DimOfIrrepSn[#]&/@IntegerPartitions[n])


(* ::Input::Initialization:: *)
GeneralLinearGroup/:MakeBoxes[GeneralLinearGroup[N_Integer|N_Symbol],StandardForm]:=RowBox[{UnderscriptBox["GL","_"],"[",ToString[N],"]"}];
MakeExpression[RowBox[{UnderscriptBox["GL","_"],"[",N_,"]"}],StandardForm]:=MakeExpression[RowBox[{"GeneralLinearGroup","[",N,"]"}],StandardForm];
OrthogonalGroup/:MakeBoxes[OrthogonalGroup[N_Integer|N_Symbol],StandardForm]:=RowBox[{UnderscriptBox["O","_"],"[",ToString[N],"]"}];
MakeExpression[RowBox[{UnderscriptBox["O","_"],"[",N_,"]"}],StandardForm]:=MakeExpression[RowBox[{"OrthogonalGroup","[",N,"]"}],StandardForm];
SymplecticGroup/:MakeBoxes[SymplecticGroup[N_Integer|N_Symbol],StandardForm]:=RowBox[{UnderscriptBox["Sp","_"],"[",ToString[N],"]"}];
MakeExpression[RowBox[{UnderscriptBox["Sp","_"],"[",N_,"]"}],StandardForm]:=MakeExpression[RowBox[{"SymplecticGroup","[",N,"]"}],StandardForm];


(* ::Input::Initialization:: *)
DimOfIrrepGL[partition_,\[Delta]_Symbol|\[Delta]_Integer]:=Module[{row=Length[partition],i=0,prod=1,j=0,hookprod},
While[i<row,i++;
While[j<partition[[i]],j++;
prod=prod*(\[Delta]-i+j)
];j=0];
hookprod=HookLengthProduct[partition];
Factor[prod/hookprod]
]
(*DimOfIrrepGL[partition_]:=DimOfIrrepGL[partition,BrauerParameter];*)


(* ::Input::Initialization:: *)
SchurPolynomialId[partition_,\[Delta]_Integer|\[Delta]_Symbol]:=DimOfIrrepGL[partition,\[Delta]];
SchurPolynomialId[partition_]:=DimOfIrrepGL[partition];


(* ::Input::Initialization:: *)
FrobeniusNotationNotRestricted[\[Lambda]_]:=Module[{\[Lambda]t=TransposePartition[\[Lambda]],r1=Length[\[Lambda]],r2=\[Lambda][[1]]},
{\[Lambda]-Range[r1],\[Lambda]t-Range[r2]}]
FrobeniusNotation[\[Lambda]_]:=Map[DeleteCases[#,x_/;x<0]&,FrobeniusNotationNotRestricted[\[Lambda]]]


(* ::Input::Initialization:: *)
DimOfIrrepOFrobenius[\[Lambda]_,\[Delta]_Symbol|\[Delta]_Plus]:=Module[{\[Lambda]t=TransposePartition[\[Lambda]],frobenius=FrobeniusNotation[\[Lambda]],frobenius2=FrobeniusNotationNotRestricted[\[Lambda]],r,a,b},
a=frobenius2[[1]];
b=frobenius2[[2]];
r=Length[frobenius[[1]]];
Product[Product[\[Delta]+a[[i]]+a[[j]],{j,i,\[Lambda]t[[i]]}]*Product[\[Delta]-b[[i]]-b[[j]]-2,{j,i+1,\[Lambda][[i]]}],{i,1,r}]/HookLengthProduct[\[Lambda]]
]


(* ::Input::Initialization:: *)
Value0BoxOrthogonal[list_,\[Delta]_Symbol|\[Delta]_Integer|\[Delta]_Plus]:=If[list[[1]]>=list[[2]],\[Delta]-Plus@@list,\[Delta]+Plus@@list-2]
Values0PartitionOrthogonal[\[Lambda]_,\[Delta]_Symbol|\[Delta]_Integer|\[Delta]_Plus]:=Map[Value0BoxOrthogonal[#,\[Delta]]&,boxlist[\[Lambda]]]
Value1BoxOrthogonal[\[Lambda]_,\[Lambda]t_,list_,\[Delta]_Symbol|\[Delta]_Integer|\[Delta]_Plus]:=If[list[[1]]>=list[[2]],\[Lambda][[list[[1]]]]+\[Lambda][[list[[2]]]],-\[Lambda]t[[list[[1]]]]-\[Lambda]t[[list[[2]]]]]
Value1PartitionOrthogonal[\[Lambda]_,\[Delta]_Symbol|\[Delta]_Integer|\[Delta]_Plus]:=With[{\[Lambda]t=TransposePartition[\[Lambda]]},Map[Value1BoxOrthogonal[\[Lambda],\[Lambda]t,#,\[Delta]]&,boxlist[\[Lambda]]]]


(* ::Input::Initialization:: *)
DimOfIrrepO[\[Lambda]_,\[Delta]_Symbol|\[Delta]_Plus]:=Times@@(Values0PartitionOrthogonal[\[Lambda],\[Delta]]+Value1PartitionOrthogonal[\[Lambda],\[Delta]])/HookLengthProduct[\[Lambda]];
DimOfIrrepO[\[Lambda]_,N_Integer]:=If[BrauerModuleRestrictionO[\[Lambda],N],Times@@(Values0PartitionOrthogonal[\[Lambda],N]+Value1PartitionOrthogonal[\[Lambda],N])/HookLengthProduct[\[Lambda]],0]
BrauerModuleRestrictionO[\[Lambda]_,dim_]:=With[{t\[Lambda]=TransposePartition[\[Lambda]]},If[Length[t\[Lambda]]==0,True,If[Length[t\[Lambda]]==1,t\[Lambda][[1]]<=dim,(t\[Lambda][[1]]+t\[Lambda][[2]]<=dim)]]]
(*DimOfIrrepO[\[Lambda]_]:=DimOfIrrepO[\[Lambda],BrauerParameter[]];*)


(* ::Input::Initialization:: *)
DimOfIrrepSpFrobenius[\[Lambda]_,\[Delta]_Symbol|\[Delta]_Plus]:=Module[{\[Lambda]t=TransposePartition[\[Lambda]],frobenius=FrobeniusNotation[\[Lambda]],frobenius2=FrobeniusNotationNotRestricted[\[Lambda]],r,a,b},
a=frobenius2[[1]];
b=frobenius2[[2]];
r=Length[frobenius[[1]]];
Product[Product[\[Delta]+a[[i]]+a[[j]]+2,{j,i+1,\[Lambda]t[[i]]}]*Product[\[Delta]-b[[i]]-b[[j]],{j,i,\[Lambda][[i]]}],{i,1,r}]/HookLengthProduct[\[Lambda]]
]


(* ::Input::Initialization:: *)
Value0BoxSymplectic[list_,\[Delta]_Symbol|\[Delta]_Integer|\[Delta]_Plus]:=If[list[[1]]<=list[[2]],\[Delta]+Plus@@list,\[Delta]-Plus@@list+2]
Values0PartitionSymplectic[\[Lambda]_,\[Delta]_Symbol|\[Delta]_Integer|\[Delta]_Plus]:=Map[Value0BoxSymplectic[#,\[Delta]]&,boxlist[\[Lambda]]]
Value1BoxSymplectic[\[Lambda]_,\[Lambda]t_,list_,\[Delta]_Symbol|\[Delta]_Integer|\[Delta]_Plus]:=If[list[[1]]<=list[[2]],-\[Lambda]t[[list[[1]]]]-\[Lambda]t[[list[[2]]]],\[Lambda][[list[[1]]]]+\[Lambda][[list[[2]]]]]
Value1PartitionSymplectic[\[Lambda]_,\[Delta]_Symbol|\[Delta]_Integer|\[Delta]_Plus]:=With[{\[Lambda]t=TransposePartition[\[Lambda]]},Map[Value1BoxSymplectic[\[Lambda],\[Lambda]t,#,\[Delta]]&,boxlist[\[Lambda]]]]


(* ::Input::Initialization:: *)
DimOfIrrepSp[\[Lambda]_,\[Delta]_Symbol|\[Delta]_Plus]:=Times@@(Values0PartitionSymplectic[\[Lambda],\[Delta]]+Value1PartitionSymplectic[\[Lambda],\[Delta]])/HookLengthProduct[\[Lambda]]
DimOfIrrepSp[\[Lambda]_,N_Integer]:=If[TransposePartition[\[Lambda]][[1]]<=N/2,Times@@(Values0PartitionSymplectic[\[Lambda],N]+Value1PartitionSymplectic[\[Lambda],N])/HookLengthProduct[\[Lambda]],0];
(*DimOfIrrepSp[\[Lambda]_]:=DimOfIrrepSp[\[Lambda],-BrauerParameter[]];*)


(* ::Input::Initialization:: *)
DimOfIrrep[\[Mu]_,GeneralLinearGroup[N_Integer|N_Symbol|N_Plus]]:=DimOfIrrepGL[\[Mu],N]
DimOfIrrep[\[Mu]_,OrthogonalGroup[N_Integer|N_Symbol|N_Plus]]:=DimOfIrrepO[\[Mu],N]
DimOfIrrep[\[Mu]_,SymplecticGroup[N_Integer|N_Symbol|N_Plus]]:=DimOfIrrepSp[\[Mu],N]


(* ::Input::Initialization:: *)
EvenPartition[f_]:=IntegerPartitions[2*f,f,Table[i,{i,2,2*f,2}]]
MaximalEvenPartitionIn[mu_]:=DeleteCases[2*IntegerPart[mu/2],0]
EvenPartitionIn[mu_,f_]:=With[{numax=MaximalEvenPartitionIn[mu]},
Select[EvenPartition[f],IncludedPartitionQ[numax,#]&]
]
EvenPartitionIn[{1,a___}]:={{}};
EvenPartitionIn[mu_]:=Module[{numax=MaximalEvenPartitionIn[mu],fs},
fs=Range[2,Plus@@numax-2,2];
Join[{{}},Flatten[Map[IntegerPartitions[#,{1,Length[numax]},Range[2,numax[[1]],2]]&,fs],1],{numax}]
]


(* ::Input::Initialization:: *)
BranchingRule[\[Mu]_,GeneralLinearGroup,OrthogonalGroup]:=SortBy[Flatten[Map[InverseLittlewoodRichardsonRule[\[Mu],#]&,EvenPartitionIn[\[Mu]]],1],Tr[#]&]
BranchingRule[\[Mu]_,GeneralLinearGroup,SymplecticGroup]:=SortBy[Flatten[Map[InverseLittlewoodRichardsonRule[\[Mu],#]&,EvenPartitionIn[\[Mu]]],1],Tr[#]&]
BranchingRule[\[Mu]_,GeneralLinearGroup[N_Symbol|N_Plus],OrthogonalGroup[N_Symbol|N_Plus]]:=BranchingRule[\[Mu],GeneralLinearGroup,OrthogonalGroup];
BranchingRule[\[Mu]_,GeneralLinearGroup[N_Symbol|N_Plus],SymplecticGroup[N_Symbol|N_Plus]]:=BranchingRule[\[Mu],GeneralLinearGroup,SymplecticGroup];
(********* Integer dimension : Stable regime Littlewood Richardson restriction rule ***********)
BranchingRule::GLrestriction="The number of raws in `1` is greater than `2`.";
BranchingRule::Orestriction="The number of raws in `1` is greater than `2`.";
BranchingRule::Sprestriction="The number of raws in `1` is greater than `2`.";
RestrictionO[\[Lambda]_,N_]:=With[{t\[Lambda]=TransposePartition[\[Lambda]]},If[Length[t\[Lambda]]==0,True,If[Length[t\[Lambda]]==1,t\[Lambda][[1]]<=N,(t\[Lambda][[1]]+t\[Lambda][[2]]<=N)]]];
RestrictionSp[\[Lambda]_,dim_]:=If[Length[\[Lambda]]==0,True,\[Lambda][[1]]<=dim/2];
BranchingRule[\[Mu]_,GeneralLinearGroup[N_Integer],OrthogonalGroup[N_Integer]]:=With[{Nraw\[Mu]=Length[\[Mu]]},
If[Nraw\[Mu]>N,Throw@Message[BranchingRule::GLrestriction,\[Mu],N]];
Select[BranchingRule[\[Mu],GeneralLinearGroup,OrthogonalGroup],RestrictionO[#,N]&]
]
BranchingRule[\[Mu]_,GeneralLinearGroup[N_Integer?EvenQ],SymplecticGroup[N_Integer?EvenQ]]:=With[{Nraw\[Mu]=Length[\[Mu]]},
If[Nraw\[Mu]>N,Throw@Message[BranchingRule::GLrestriction,\[Mu],N]];
Select[BranchingRule[\[Mu],GeneralLinearGroup,OrthogonalGroup],!RestrictionSp[#,N]&]
]
BranchingRule[\[Mu]_]:=BranchingRule[\[Mu],GeneralLinearGroup,OrthogonalGroup]
(***************************************)
(******** Symmetric Group branching ****)
(***************************************)
BranchingRule::SymmetricGroup="There partition `1` is not associated with a simple module of the symmetric group.";
BranchingRule[\[Mu]_,SymmetricGroup[n_],rest___]/;Tr[\[Mu]]!=n:=Throw[Message[BranchingRule::SymmetricGroup,\[Mu]]]
BranchingRule[\[Micro]_,SymmetricGroup]:=With[{l\[Mu]=Length[\[Micro]]},DeleteDuplicates@Map[DeleteCases[ReverseSort[\[Micro]-#],0]&,NestList[RotateLeft[#,1]&,PadLeft[{1},l\[Mu]],l\[Mu]-1]]]
BranchingRule[\[Micro]_,SymmetricGroup[n1_Integer],SymmetricGroup[n2_Integer]]/;n1==n2+1:=With[{l\[Mu]=Length[\[Micro]]},DeleteDuplicates@Map[DeleteCases[ReverseSort[\[Micro]-#],0]&,NestList[RotateLeft[#,1]&,PadLeft[{1},l\[Mu]],l\[Mu]-1]]]
BranchingRuleMap[list_,SymmetricGroup[n1_Integer],SymmetricGroup[n2_Integer]]:=Flatten[Map[BranchingRule[#,SymmetricGroup[n1],SymmetricGroup[n2]]&,list],1]
BranchingRule[\[Mu]_List,SymmetricGroup[n1_Integer],SymmetricGroup[n2_Integer]]:=Module[{temp=BranchingRule[\[Mu],SymmetricGroup[n1],SymmetricGroup[n1-1]]},
Do[temp=BranchingRuleMap[temp,SymmetricGroup[n1-i],SymmetricGroup[n1-i-1]],{i,1,n1-n2-1}];
SortBy[temp,Tr[#]&]
]


(* ::Input::Initialization:: *)
End[];
Protect@@Names["SymmetricFunctions`*"]
Unprotect["KostkaCoefficient","CharacterSymmetricGroup"]
EndPackage[];



